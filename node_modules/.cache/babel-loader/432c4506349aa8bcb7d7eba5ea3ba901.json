{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _core = require('../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _Texture = require('../core/textures/Texture');\n\nvar _Texture2 = _interopRequireDefault(_Texture);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar tempPoint = new core.Point();\nvar tempPolygon = new core.Polygon();\n/**\n * Base mesh class\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.mesh\n */\n\nvar Mesh = function (_core$Container) {\n  _inherits(Mesh, _core$Container);\n  /**\n   * @param {PIXI.Texture} texture - The texture to use\n   * @param {Float32Array} [vertices] - if you want to specify the vertices\n   * @param {Float32Array} [uvs] - if you want to specify the uvs\n   * @param {Uint16Array} [indices] - if you want to specify the indices\n   * @param {number} [drawMode] - the drawMode, can be any of the Mesh.DRAW_MODES consts\n   */\n\n\n  function Mesh(texture, vertices, uvs, indices, drawMode) {\n    _classCallCheck(this, Mesh);\n    /**\n     * The texture of the Mesh\n     *\n     * @member {PIXI.Texture}\n     * @default PIXI.Texture.EMPTY\n     * @private\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _core$Container.call(this));\n\n    _this._texture = texture || _Texture2.default.EMPTY;\n    /**\n     * The Uvs of the Mesh\n     *\n     * @member {Float32Array}\n     */\n\n    _this.uvs = uvs || new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]);\n    /**\n     * An array of vertices\n     *\n     * @member {Float32Array}\n     */\n\n    _this.vertices = vertices || new Float32Array([0, 0, 100, 0, 100, 100, 0, 100]);\n    /**\n     * An array containing the indices of the vertices\n     *\n     * @member {Uint16Array}\n     */\n    //  TODO auto generate this based on draw mode!\n\n    _this.indices = indices || new Uint16Array([0, 1, 3, 2]);\n    /**\n     * Version of mesh uvs are dirty or not\n     *\n     * @member {number}\n     */\n\n    _this.dirty = 0;\n    /**\n     * Version of mesh indices\n     *\n     * @member {number}\n     */\n\n    _this.indexDirty = 0;\n    /**\n     * Version of mesh verticies array\n     *\n     * @member {number}\n     */\n\n    _this.vertexDirty = 0;\n    /**\n     * For backwards compatibility the default is to re-upload verticies each render call.\n     * Set this to `false` and increase `vertexDirty` to manually re-upload the buffer.\n     *\n     * @member {boolean}\n     */\n\n    _this.autoUpdate = true;\n    /**\n     * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove\n     * any blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL\n     * @see PIXI.BLEND_MODES\n     */\n\n    _this.blendMode = core.BLEND_MODES.NORMAL;\n    /**\n     * Triangles in canvas mode are automatically antialiased, use this value to force triangles\n     * to overlap a bit with each other.\n     *\n     * @member {number}\n     */\n\n    _this.canvasPadding = core.settings.MESH_CANVAS_PADDING;\n    /**\n     * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts\n     *\n     * @member {number}\n     * @see PIXI.mesh.Mesh.DRAW_MODES\n     */\n\n    _this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;\n    /**\n     * The default shader that is used if a mesh doesn't have a more specific one.\n     *\n     * @member {PIXI.Shader}\n     */\n\n    _this.shader = null;\n    /**\n     * The tint applied to the mesh. This is a [r,g,b] value. A value of [1,1,1] will remove any\n     * tint effect.\n     *\n     * @member {number}\n     */\n\n    _this.tintRgb = new Float32Array([1, 1, 1]);\n    /**\n     * A map of renderer IDs to webgl render data\n     *\n     * @private\n     * @member {object<number, object>}\n     */\n\n    _this._glDatas = {};\n    /**\n     * transform that is applied to UV to get the texture coords\n     * its updated independently from texture uvTransform\n     * updates of uvs are tied to that thing\n     *\n     * @member {PIXI.TextureMatrix}\n     * @private\n     */\n\n    _this._uvTransform = new core.TextureMatrix(_this._texture);\n    /**\n     * whether or not upload uvTransform to shader\n     * if its false, then uvs should be pre-multiplied\n     * if you change it for generated mesh, please call 'refresh(true)'\n     * @member {boolean}\n     * @default false\n     */\n\n    _this.uploadUvTransform = false;\n    /**\n     * Plugin that is responsible for rendering this element.\n     * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.\n     * @member {string}\n     * @default 'mesh'\n     */\n\n    _this.pluginName = 'mesh';\n    return _this;\n  }\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - a reference to the WebGL renderer\n   */\n\n\n  Mesh.prototype._renderWebGL = function _renderWebGL(renderer) {\n    this.refresh();\n    renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  };\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n   */\n\n\n  Mesh.prototype._renderCanvas = function _renderCanvas(renderer) {\n    this.refresh();\n    renderer.plugins[this.pluginName].render(this);\n  };\n  /**\n   * When the texture is updated, this event will fire to update the scale and frame\n   *\n   * @private\n   */\n\n\n  Mesh.prototype._onTextureUpdate = function _onTextureUpdate() {\n    this._uvTransform.texture = this._texture;\n    this.refresh();\n  };\n  /**\n   * multiplies uvs only if uploadUvTransform is false\n   * call it after you change uvs manually\n   * make sure that texture is valid\n   */\n\n\n  Mesh.prototype.multiplyUvs = function multiplyUvs() {\n    if (!this.uploadUvTransform) {\n      this._uvTransform.multiplyUvs(this.uvs);\n    }\n  };\n  /**\n   * Refreshes uvs for generated meshes (rope, plane)\n   * sometimes refreshes vertices too\n   *\n   * @param {boolean} [forceUpdate=false] if true, matrices will be updated any case\n   */\n\n\n  Mesh.prototype.refresh = function refresh(forceUpdate) {\n    if (this.autoUpdate) {\n      this.vertexDirty++;\n    }\n\n    if (this._uvTransform.update(forceUpdate)) {\n      this._refresh();\n    }\n  };\n  /**\n   * re-calculates mesh coords\n   * @protected\n   */\n\n\n  Mesh.prototype._refresh = function _refresh() {}\n  /* empty */\n\n  /**\n   * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n   *\n   */\n  ;\n\n  Mesh.prototype._calculateBounds = function _calculateBounds() {\n    // TODO - we can cache local bounds and use them if they are dirty (like graphics)\n    this._bounds.addVertices(this.transform, this.vertices, 0, this.vertices.length);\n  };\n  /**\n   * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH\n   *\n   * @param {PIXI.Point} point - the point to test\n   * @return {boolean} the result of the test\n   */\n\n\n  Mesh.prototype.containsPoint = function containsPoint(point) {\n    if (!this.getBounds().contains(point.x, point.y)) {\n      return false;\n    }\n\n    this.worldTransform.applyInverse(point, tempPoint);\n    var vertices = this.vertices;\n    var points = tempPolygon.points;\n    var indices = this.indices;\n    var len = this.indices.length;\n    var step = this.drawMode === Mesh.DRAW_MODES.TRIANGLES ? 3 : 1;\n\n    for (var i = 0; i + 2 < len; i += step) {\n      var ind0 = indices[i] * 2;\n      var ind1 = indices[i + 1] * 2;\n      var ind2 = indices[i + 2] * 2;\n      points[0] = vertices[ind0];\n      points[1] = vertices[ind0 + 1];\n      points[2] = vertices[ind1];\n      points[3] = vertices[ind1 + 1];\n      points[4] = vertices[ind2];\n      points[5] = vertices[ind2 + 1];\n\n      if (tempPolygon.contains(tempPoint.x, tempPoint.y)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * The texture that the mesh uses.\n   *\n   * @member {PIXI.Texture}\n   */\n\n  /**\n   * Destroys the Mesh object.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n   *  options have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have\n   *  their destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n\n\n  Mesh.prototype.destroy = function destroy(options) {\n    // for each webgl data entry, destroy the WebGLGraphicsData\n    for (var id in this._glDatas) {\n      var data = this._glDatas[id];\n\n      if (data.destroy) {\n        data.destroy();\n      } else {\n        if (data.vertexBuffer) {\n          data.vertexBuffer.destroy();\n          data.vertexBuffer = null;\n        }\n\n        if (data.indexBuffer) {\n          data.indexBuffer.destroy();\n          data.indexBuffer = null;\n        }\n\n        if (data.uvBuffer) {\n          data.uvBuffer.destroy();\n          data.uvBuffer = null;\n        }\n\n        if (data.vao) {\n          data.vao.destroy();\n          data.vao = null;\n        }\n      }\n    }\n\n    this._glDatas = null;\n\n    _core$Container.prototype.destroy.call(this, options);\n  };\n\n  _createClass(Mesh, [{\n    key: 'texture',\n    get: function get() {\n      return this._texture;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      if (this._texture === value) {\n        return;\n      }\n\n      this._texture = value;\n\n      if (value) {\n        // wait for the texture to load\n        if (value.baseTexture.hasLoaded) {\n          this._onTextureUpdate();\n        } else {\n          value.once('update', this._onTextureUpdate, this);\n        }\n      }\n    }\n    /**\n     * The tint applied to the mesh. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n\n  }, {\n    key: 'tint',\n    get: function get() {\n      return core.utils.rgb2hex(this.tintRgb);\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.tintRgb = core.utils.hex2rgb(value, this.tintRgb);\n    }\n  }]);\n\n  return Mesh;\n}(core.Container);\n/**\n * Different drawing buffer modes supported\n *\n * @static\n * @constant\n * @type {object}\n * @property {number} TRIANGLE_MESH\n * @property {number} TRIANGLES\n */\n\n\nexports.default = Mesh;\nMesh.DRAW_MODES = {\n  TRIANGLE_MESH: 0,\n  TRIANGLES: 1\n};","map":{"version":3,"sources":["../../src/mesh/Mesh.js"],"names":["core","tempPoint","tempPolygon","Mesh","Container","texture","uvs","vertices","indices","drawMode","_renderWebGL","renderer","_renderCanvas","_onTextureUpdate","multiplyUvs","refresh","forceUpdate","_refresh","_calculateBounds","containsPoint","point","points","len","step","i","ind0","ind1","ind2","value","destroy","options","data","TRIANGLE_MESH","TRIANGLES"],"mappings":"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","sourcesContent":["import * as core from '../core';\nimport Texture from '../core/textures/Texture';\n\nconst tempPoint = new core.Point();\nconst tempPolygon = new core.Polygon();\n\n/**\n * Base mesh class\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.mesh\n */\nexport default class Mesh extends core.Container\n{\n    /**\n     * @param {PIXI.Texture} texture - The texture to use\n     * @param {Float32Array} [vertices] - if you want to specify the vertices\n     * @param {Float32Array} [uvs] - if you want to specify the uvs\n     * @param {Uint16Array} [indices] - if you want to specify the indices\n     * @param {number} [drawMode] - the drawMode, can be any of the Mesh.DRAW_MODES consts\n     */\n    constructor(texture, vertices, uvs, indices, drawMode)\n    {\n        super();\n\n        /**\n         * The texture of the Mesh\n         *\n         * @member {PIXI.Texture}\n         * @default PIXI.Texture.EMPTY\n         * @private\n         */\n        this._texture = texture || Texture.EMPTY;\n\n        /**\n         * The Uvs of the Mesh\n         *\n         * @member {Float32Array}\n         */\n        this.uvs = uvs || new Float32Array([\n            0, 0,\n            1, 0,\n            1, 1,\n            0, 1]);\n\n        /**\n         * An array of vertices\n         *\n         * @member {Float32Array}\n         */\n        this.vertices = vertices || new Float32Array([\n            0, 0,\n            100, 0,\n            100, 100,\n            0, 100]);\n\n        /**\n         * An array containing the indices of the vertices\n         *\n         * @member {Uint16Array}\n         */\n        //  TODO auto generate this based on draw mode!\n        this.indices = indices || new Uint16Array([0, 1, 3, 2]);\n\n        /**\n         * Version of mesh uvs are dirty or not\n         *\n         * @member {number}\n         */\n        this.dirty = 0;\n\n        /**\n         * Version of mesh indices\n         *\n         * @member {number}\n         */\n        this.indexDirty = 0;\n\n        /**\n         * Version of mesh verticies array\n         *\n         * @member {number}\n         */\n        this.vertexDirty = 0;\n\n        /**\n         * For backwards compatibility the default is to re-upload verticies each render call.\n         * Set this to `false` and increase `vertexDirty` to manually re-upload the buffer.\n         *\n         * @member {boolean}\n         */\n        this.autoUpdate = true;\n\n        /**\n         * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove\n         * any blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL\n         * @see PIXI.BLEND_MODES\n         */\n        this.blendMode = core.BLEND_MODES.NORMAL;\n\n        /**\n         * Triangles in canvas mode are automatically antialiased, use this value to force triangles\n         * to overlap a bit with each other.\n         *\n         * @member {number}\n         */\n        this.canvasPadding = core.settings.MESH_CANVAS_PADDING;\n\n        /**\n         * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts\n         *\n         * @member {number}\n         * @see PIXI.mesh.Mesh.DRAW_MODES\n         */\n        this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;\n\n        /**\n         * The default shader that is used if a mesh doesn't have a more specific one.\n         *\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        /**\n         * The tint applied to the mesh. This is a [r,g,b] value. A value of [1,1,1] will remove any\n         * tint effect.\n         *\n         * @member {number}\n         */\n        this.tintRgb = new Float32Array([1, 1, 1]);\n\n        /**\n         * A map of renderer IDs to webgl render data\n         *\n         * @private\n         * @member {object<number, object>}\n         */\n        this._glDatas = {};\n\n        /**\n         * transform that is applied to UV to get the texture coords\n         * its updated independently from texture uvTransform\n         * updates of uvs are tied to that thing\n         *\n         * @member {PIXI.TextureMatrix}\n         * @private\n         */\n        this._uvTransform = new core.TextureMatrix(this._texture);\n\n        /**\n         * whether or not upload uvTransform to shader\n         * if its false, then uvs should be pre-multiplied\n         * if you change it for generated mesh, please call 'refresh(true)'\n         * @member {boolean}\n         * @default false\n         */\n        this.uploadUvTransform = false;\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.\n         * @member {string}\n         * @default 'mesh'\n         */\n        this.pluginName = 'mesh';\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - a reference to the WebGL renderer\n     */\n    _renderWebGL(renderer)\n    {\n        this.refresh();\n        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n     */\n    _renderCanvas(renderer)\n    {\n        this.refresh();\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * When the texture is updated, this event will fire to update the scale and frame\n     *\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        this._uvTransform.texture = this._texture;\n        this.refresh();\n    }\n\n    /**\n     * multiplies uvs only if uploadUvTransform is false\n     * call it after you change uvs manually\n     * make sure that texture is valid\n     */\n    multiplyUvs()\n    {\n        if (!this.uploadUvTransform)\n        {\n            this._uvTransform.multiplyUvs(this.uvs);\n        }\n    }\n\n    /**\n     * Refreshes uvs for generated meshes (rope, plane)\n     * sometimes refreshes vertices too\n     *\n     * @param {boolean} [forceUpdate=false] if true, matrices will be updated any case\n     */\n    refresh(forceUpdate)\n    {\n        if (this.autoUpdate)\n        {\n            this.vertexDirty++;\n        }\n        if (this._uvTransform.update(forceUpdate))\n        {\n            this._refresh();\n        }\n    }\n\n    /**\n     * re-calculates mesh coords\n     * @protected\n     */\n    _refresh()\n    {\n        /* empty */\n    }\n\n    /**\n     * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n     *\n     */\n    _calculateBounds()\n    {\n        // TODO - we can cache local bounds and use them if they are dirty (like graphics)\n        this._bounds.addVertices(this.transform, this.vertices, 0, this.vertices.length);\n    }\n\n    /**\n     * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH\n     *\n     * @param {PIXI.Point} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    containsPoint(point)\n    {\n        if (!this.getBounds().contains(point.x, point.y))\n        {\n            return false;\n        }\n\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const vertices = this.vertices;\n        const points = tempPolygon.points;\n        const indices = this.indices;\n        const len = this.indices.length;\n        const step = this.drawMode === Mesh.DRAW_MODES.TRIANGLES ? 3 : 1;\n\n        for (let i = 0; i + 2 < len; i += step)\n        {\n            const ind0 = indices[i] * 2;\n            const ind1 = indices[i + 1] * 2;\n            const ind2 = indices[i + 2] * 2;\n\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0 + 1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1 + 1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2 + 1];\n\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * The texture that the mesh uses.\n     *\n     * @member {PIXI.Texture}\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    set texture(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._texture === value)\n        {\n            return;\n        }\n\n        this._texture = value;\n\n        if (value)\n        {\n            // wait for the texture to load\n            if (value.baseTexture.hasLoaded)\n            {\n                this._onTextureUpdate();\n            }\n            else\n            {\n                value.once('update', this._onTextureUpdate, this);\n            }\n        }\n    }\n\n    /**\n     * The tint applied to the mesh. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    get tint()\n    {\n        return core.utils.rgb2hex(this.tintRgb);\n    }\n\n    set tint(value) // eslint-disable-line require-jsdoc\n    {\n        this.tintRgb = core.utils.hex2rgb(value, this.tintRgb);\n    }\n\n    /**\n     * Destroys the Mesh object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        // for each webgl data entry, destroy the WebGLGraphicsData\n        for (const id in this._glDatas)\n        {\n            const data = this._glDatas[id];\n\n            if (data.destroy)\n            {\n                data.destroy();\n            }\n            else\n            {\n                if (data.vertexBuffer)\n                {\n                    data.vertexBuffer.destroy();\n                    data.vertexBuffer = null;\n                }\n                if (data.indexBuffer)\n                {\n                    data.indexBuffer.destroy();\n                    data.indexBuffer = null;\n                }\n                if (data.uvBuffer)\n                {\n                    data.uvBuffer.destroy();\n                    data.uvBuffer = null;\n                }\n                if (data.vao)\n                {\n                    data.vao.destroy();\n                    data.vao = null;\n                }\n            }\n        }\n\n        this._glDatas = null;\n\n        super.destroy(options);\n    }\n}\n\n/**\n * Different drawing buffer modes supported\n *\n * @static\n * @constant\n * @type {object}\n * @property {number} TRIANGLE_MESH\n * @property {number} TRIANGLES\n */\nMesh.DRAW_MODES = {\n    TRIANGLE_MESH: 0,\n    TRIANGLES: 1,\n};\n"]},"metadata":{},"sourceType":"script"}