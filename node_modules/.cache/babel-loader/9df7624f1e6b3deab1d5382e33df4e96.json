{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.calculateScreenSpaceMatrix = calculateScreenSpaceMatrix;\nexports.calculateNormalizedScreenSpaceMatrix = calculateNormalizedScreenSpaceMatrix;\nexports.calculateSpriteMatrix = calculateSpriteMatrix;\n\nvar _math = require('../../../math');\n/**\n * Calculates the mapped matrix\n * @param filterArea {Rectangle} The filter area\n * @param sprite {Sprite} the target sprite\n * @param outputMatrix {Matrix} @alvin\n * @private\n */\n// TODO playing around here.. this is temporary - (will end up in the shader)\n// this returns a matrix that will normalise map filter cords in the filter to screen space\n\n\nfunction calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {\n  // let worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX),\n  // let texture = {width:1136, height:700};//sprite._texture.baseTexture;\n  // TODO unwrap?\n  var mappedMatrix = outputMatrix.identity();\n  mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n  mappedMatrix.scale(textureSize.width, textureSize.height);\n  return mappedMatrix;\n}\n\nfunction calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize) {\n  var mappedMatrix = outputMatrix.identity();\n  mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n  var translateScaleX = textureSize.width / filterArea.width;\n  var translateScaleY = textureSize.height / filterArea.height;\n  mappedMatrix.scale(translateScaleX, translateScaleY);\n  return mappedMatrix;\n} // this will map the filter coord so that a texture can be used based on the transform of a sprite\n\n\nfunction calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite) {\n  var orig = sprite._texture.orig;\n  var mappedMatrix = outputMatrix.set(textureSize.width, 0, 0, textureSize.height, filterArea.x, filterArea.y);\n  var worldTransform = sprite.worldTransform.copy(_math.Matrix.TEMP_MATRIX);\n  worldTransform.invert();\n  mappedMatrix.prepend(worldTransform);\n  mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);\n  mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n  return mappedMatrix;\n}","map":{"version":3,"sources":["../../../../../src/core/renderers/webgl/filters/filterTransforms.js"],"names":["calculateScreenSpaceMatrix","mappedMatrix","outputMatrix","filterArea","textureSize","calculateNormalizedScreenSpaceMatrix","translateScaleX","translateScaleY","calculateSpriteMatrix","orig","sprite","worldTransform"],"mappings":";;;QAWgBA,0B,GAAAA,0B;QAeAK,oC,GAAAA,oC;QAeAG,qB,GAAAA,qB;;AAzChB,IAAA,KAAA,GAAA,OAAA,CAAA,eAAA,CAAA;AAEA;;;;;;;AAOA;AACA;;;AACO,SAAA,0BAAA,CAAA,YAAA,EAAA,UAAA,EAAA,WAAA,EACP;AACK;AACD;AAEA;AACA,MAAMP,YAAAA,GAAeC,YAAAA,CAArB,QAAqBA,EAArB;AAEAD,EAAAA,YAAAA,CAAAA,SAAAA,CAAuBE,UAAAA,CAAAA,CAAAA,GAAeC,WAAAA,CAAtCH,KAAAA,EAAyDE,UAAAA,CAAAA,CAAAA,GAAeC,WAAAA,CAAxEH,MAAAA;AAEAA,EAAAA,YAAAA,CAAAA,KAAAA,CAAmBG,WAAAA,CAAnBH,KAAAA,EAAsCG,WAAAA,CAAtCH,MAAAA;AAEA,SAAA,YAAA;AACH;;AAEM,SAAA,oCAAA,CAAA,YAAA,EAAA,UAAA,EAAA,WAAA,EACP;AACI,MAAMA,YAAAA,GAAeC,YAAAA,CAArB,QAAqBA,EAArB;AAEAD,EAAAA,YAAAA,CAAAA,SAAAA,CAAuBE,UAAAA,CAAAA,CAAAA,GAAeC,WAAAA,CAAtCH,KAAAA,EAAyDE,UAAAA,CAAAA,CAAAA,GAAeC,WAAAA,CAAxEH,MAAAA;AAEA,MAAMK,eAAAA,GAAmBF,WAAAA,CAAAA,KAAAA,GAAoBD,UAAAA,CAA7C,KAAA;AACA,MAAMI,eAAAA,GAAmBH,WAAAA,CAAAA,MAAAA,GAAqBD,UAAAA,CAA9C,MAAA;AAEAF,EAAAA,YAAAA,CAAAA,KAAAA,CAAAA,eAAAA,EAAAA,eAAAA;AAEA,SAAA,YAAA;AACH,C,CAED;;;AACO,SAAA,qBAAA,CAAA,YAAA,EAAA,UAAA,EAAA,WAAA,EAAA,MAAA,EACP;AACI,MAAMQ,IAAAA,GAAOC,MAAAA,CAAAA,QAAAA,CAAb,IAAA;AACA,MAAMT,YAAAA,GAAeC,YAAAA,CAAAA,GAAAA,CAAiBE,WAAAA,CAAjBF,KAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAA0CE,WAAAA,CAA1CF,MAAAA,EAA8DC,UAAAA,CAA9DD,CAAAA,EAA4EC,UAAAA,CAAjG,CAAqBD,CAArB;AACA,MAAMS,cAAAA,GAAiBD,MAAAA,CAAAA,cAAAA,CAAAA,IAAAA,CAA2B,KAAA,CAAA,MAAA,CAAlD,WAAuBA,CAAvB;AAEAC,EAAAA,cAAAA,CAAAA,MAAAA;AACAV,EAAAA,YAAAA,CAAAA,OAAAA,CAAAA,cAAAA;AACAA,EAAAA,YAAAA,CAAAA,KAAAA,CAAmB,MAAMQ,IAAAA,CAAzBR,KAAAA,EAAqC,MAAMQ,IAAAA,CAA3CR,MAAAA;AACAA,EAAAA,YAAAA,CAAAA,SAAAA,CAAuBS,MAAAA,CAAAA,MAAAA,CAAvBT,CAAAA,EAAwCS,MAAAA,CAAAA,MAAAA,CAAxCT,CAAAA;AAEA,SAAA,YAAA;AACH","sourcesContent":["import { Matrix } from '../../../math';\n\n/**\n * Calculates the mapped matrix\n * @param filterArea {Rectangle} The filter area\n * @param sprite {Sprite} the target sprite\n * @param outputMatrix {Matrix} @alvin\n * @private\n */\n// TODO playing around here.. this is temporary - (will end up in the shader)\n// this returns a matrix that will normalise map filter cords in the filter to screen space\nexport function calculateScreenSpaceMatrix(outputMatrix, filterArea, textureSize)\n{\n     // let worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX),\n    // let texture = {width:1136, height:700};//sprite._texture.baseTexture;\n\n    // TODO unwrap?\n    const mappedMatrix = outputMatrix.identity();\n\n    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n\n    mappedMatrix.scale(textureSize.width, textureSize.height);\n\n    return mappedMatrix;\n}\n\nexport function calculateNormalizedScreenSpaceMatrix(outputMatrix, filterArea, textureSize)\n{\n    const mappedMatrix = outputMatrix.identity();\n\n    mappedMatrix.translate(filterArea.x / textureSize.width, filterArea.y / textureSize.height);\n\n    const translateScaleX = (textureSize.width / filterArea.width);\n    const translateScaleY = (textureSize.height / filterArea.height);\n\n    mappedMatrix.scale(translateScaleX, translateScaleY);\n\n    return mappedMatrix;\n}\n\n// this will map the filter coord so that a texture can be used based on the transform of a sprite\nexport function calculateSpriteMatrix(outputMatrix, filterArea, textureSize, sprite)\n{\n    const orig = sprite._texture.orig;\n    const mappedMatrix = outputMatrix.set(textureSize.width, 0, 0, textureSize.height, filterArea.x, filterArea.y);\n    const worldTransform = sprite.worldTransform.copy(Matrix.TEMP_MATRIX);\n\n    worldTransform.invert();\n    mappedMatrix.prepend(worldTransform);\n    mappedMatrix.scale(1.0 / orig.width, 1.0 / orig.height);\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n    return mappedMatrix;\n}\n"]},"metadata":{},"sourceType":"script"}