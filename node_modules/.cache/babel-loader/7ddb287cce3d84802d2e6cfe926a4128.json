{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _GroupD = require('../math/GroupD8');\n\nvar _GroupD2 = _interopRequireDefault(_GroupD);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * A standard object to store the Uvs of a texture\n *\n * @class\n * @private\n * @memberof PIXI\n */\n\n\nvar TextureUvs = function () {\n  /**\n   *\n   */\n  function TextureUvs() {\n    _classCallCheck(this, TextureUvs);\n\n    this.x0 = 0;\n    this.y0 = 0;\n    this.x1 = 1;\n    this.y1 = 0;\n    this.x2 = 1;\n    this.y2 = 1;\n    this.x3 = 0;\n    this.y3 = 1;\n    this.uvsUint32 = new Uint32Array(4);\n  }\n  /**\n   * Sets the texture Uvs based on the given frame information.\n   *\n   * @private\n   * @param {PIXI.Rectangle} frame - The frame of the texture\n   * @param {PIXI.Rectangle} baseFrame - The base frame of the texture\n   * @param {number} rotate - Rotation of frame, see {@link PIXI.GroupD8}\n   */\n\n\n  TextureUvs.prototype.set = function set(frame, baseFrame, rotate) {\n    var tw = baseFrame.width;\n    var th = baseFrame.height;\n\n    if (rotate) {\n      // width and height div 2 div baseFrame size\n      var w2 = frame.width / 2 / tw;\n      var h2 = frame.height / 2 / th; // coordinates of center\n\n      var cX = frame.x / tw + w2;\n      var cY = frame.y / th + h2;\n      rotate = _GroupD2.default.add(rotate, _GroupD2.default.NW); // NW is top-left corner\n\n      this.x0 = cX + w2 * _GroupD2.default.uX(rotate);\n      this.y0 = cY + h2 * _GroupD2.default.uY(rotate);\n      rotate = _GroupD2.default.add(rotate, 2); // rotate 90 degrees clockwise\n\n      this.x1 = cX + w2 * _GroupD2.default.uX(rotate);\n      this.y1 = cY + h2 * _GroupD2.default.uY(rotate);\n      rotate = _GroupD2.default.add(rotate, 2);\n      this.x2 = cX + w2 * _GroupD2.default.uX(rotate);\n      this.y2 = cY + h2 * _GroupD2.default.uY(rotate);\n      rotate = _GroupD2.default.add(rotate, 2);\n      this.x3 = cX + w2 * _GroupD2.default.uX(rotate);\n      this.y3 = cY + h2 * _GroupD2.default.uY(rotate);\n    } else {\n      this.x0 = frame.x / tw;\n      this.y0 = frame.y / th;\n      this.x1 = (frame.x + frame.width) / tw;\n      this.y1 = frame.y / th;\n      this.x2 = (frame.x + frame.width) / tw;\n      this.y2 = (frame.y + frame.height) / th;\n      this.x3 = frame.x / tw;\n      this.y3 = (frame.y + frame.height) / th;\n    }\n\n    this.uvsUint32[0] = (Math.round(this.y0 * 65535) & 0xFFFF) << 16 | Math.round(this.x0 * 65535) & 0xFFFF;\n    this.uvsUint32[1] = (Math.round(this.y1 * 65535) & 0xFFFF) << 16 | Math.round(this.x1 * 65535) & 0xFFFF;\n    this.uvsUint32[2] = (Math.round(this.y2 * 65535) & 0xFFFF) << 16 | Math.round(this.x2 * 65535) & 0xFFFF;\n    this.uvsUint32[3] = (Math.round(this.y3 * 65535) & 0xFFFF) << 16 | Math.round(this.x3 * 65535) & 0xFFFF;\n  };\n\n  return TextureUvs;\n}();\n\nexports.default = TextureUvs;","map":{"version":3,"sources":["../../../src/core/textures/TextureUvs.js"],"names":["TextureUvs","set","frame","baseFrame","rotate","tw","th","w2","h2","cX","cY","Math"],"mappings":"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","sourcesContent":["import GroupD8 from '../math/GroupD8';\n\n/**\n * A standard object to store the Uvs of a texture\n *\n * @class\n * @private\n * @memberof PIXI\n */\nexport default class TextureUvs\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        this.x0 = 0;\n        this.y0 = 0;\n\n        this.x1 = 1;\n        this.y1 = 0;\n\n        this.x2 = 1;\n        this.y2 = 1;\n\n        this.x3 = 0;\n        this.y3 = 1;\n\n        this.uvsUint32 = new Uint32Array(4);\n    }\n\n    /**\n     * Sets the texture Uvs based on the given frame information.\n     *\n     * @private\n     * @param {PIXI.Rectangle} frame - The frame of the texture\n     * @param {PIXI.Rectangle} baseFrame - The base frame of the texture\n     * @param {number} rotate - Rotation of frame, see {@link PIXI.GroupD8}\n     */\n    set(frame, baseFrame, rotate)\n    {\n        const tw = baseFrame.width;\n        const th = baseFrame.height;\n\n        if (rotate)\n        {\n            // width and height div 2 div baseFrame size\n            const w2 = frame.width / 2 / tw;\n            const h2 = frame.height / 2 / th;\n\n            // coordinates of center\n            const cX = (frame.x / tw) + w2;\n            const cY = (frame.y / th) + h2;\n\n            rotate = GroupD8.add(rotate, GroupD8.NW); // NW is top-left corner\n            this.x0 = cX + (w2 * GroupD8.uX(rotate));\n            this.y0 = cY + (h2 * GroupD8.uY(rotate));\n\n            rotate = GroupD8.add(rotate, 2); // rotate 90 degrees clockwise\n            this.x1 = cX + (w2 * GroupD8.uX(rotate));\n            this.y1 = cY + (h2 * GroupD8.uY(rotate));\n\n            rotate = GroupD8.add(rotate, 2);\n            this.x2 = cX + (w2 * GroupD8.uX(rotate));\n            this.y2 = cY + (h2 * GroupD8.uY(rotate));\n\n            rotate = GroupD8.add(rotate, 2);\n            this.x3 = cX + (w2 * GroupD8.uX(rotate));\n            this.y3 = cY + (h2 * GroupD8.uY(rotate));\n        }\n        else\n        {\n            this.x0 = frame.x / tw;\n            this.y0 = frame.y / th;\n\n            this.x1 = (frame.x + frame.width) / tw;\n            this.y1 = frame.y / th;\n\n            this.x2 = (frame.x + frame.width) / tw;\n            this.y2 = (frame.y + frame.height) / th;\n\n            this.x3 = frame.x / tw;\n            this.y3 = (frame.y + frame.height) / th;\n        }\n\n        this.uvsUint32[0] = ((Math.round(this.y0 * 65535) & 0xFFFF) << 16) | (Math.round(this.x0 * 65535) & 0xFFFF);\n        this.uvsUint32[1] = ((Math.round(this.y1 * 65535) & 0xFFFF) << 16) | (Math.round(this.x1 * 65535) & 0xFFFF);\n        this.uvsUint32[2] = ((Math.round(this.y2 * 65535) & 0xFFFF) << 16) | (Math.round(this.x2 * 65535) & 0xFFFF);\n        this.uvsUint32[3] = ((Math.round(this.y3 * 65535) & 0xFFFF) << 16) | (Math.round(this.x3 * 65535) & 0xFFFF);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}