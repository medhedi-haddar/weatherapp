{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.Resource = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _parseUri = require('parse-uri');\n\nvar _parseUri2 = _interopRequireDefault(_parseUri);\n\nvar _miniSignals = require('mini-signals');\n\nvar _miniSignals2 = _interopRequireDefault(_miniSignals);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // tests if CORS is supported in XHR, if not we need to use XDR\n\n\nvar useXdr = !!(window.XDomainRequest && !('withCredentials' in new XMLHttpRequest()));\nvar tempAnchor = null; // some status constants\n\nvar STATUS_NONE = 0;\nvar STATUS_OK = 200;\nvar STATUS_EMPTY = 204;\nvar STATUS_IE_BUG_EMPTY = 1223;\nvar STATUS_TYPE_OK = 2; // noop\n\nfunction _noop() {}\n/* empty */\n\n/**\n * Manages the state and loading of a resource and all child resources.\n *\n * @class\n */\n\n\nvar Resource = exports.Resource = function () {\n  /**\n   * Sets the load type to be used for a specific extension.\n   *\n   * @static\n   * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n   * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n   */\n  Resource.setExtensionLoadType = function setExtensionLoadType(extname, loadType) {\n    setExtMap(Resource._loadTypeMap, extname, loadType);\n  };\n  /**\n   * Sets the load type to be used for a specific extension.\n   *\n   * @static\n   * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n   * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n   */\n\n\n  Resource.setExtensionXhrType = function setExtensionXhrType(extname, xhrType) {\n    setExtMap(Resource._xhrTypeMap, extname, xhrType);\n  };\n  /**\n   * @param {string} name - The name of the resource to load.\n   * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n   *      an array of sources.\n   * @param {object} [options] - The options for the load.\n   * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n   *      determine automatically.\n   * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n   *      longer than this time it is cancelled and the load is considered a failure. If this value is\n   *      set to `0` then there is no explicit timeout.\n   * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n   *      be loaded?\n   * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n   *      should the data being loaded be interpreted when using XHR?\n   * @param {Resource.IMetadata} [options.metadata] - Extra configuration for middleware and the Resource object.\n   */\n\n\n  function Resource(name, url, options) {\n    _classCallCheck(this, Resource);\n\n    if (typeof name !== 'string' || typeof url !== 'string') {\n      throw new Error('Both name and url are required for constructing a resource.');\n    }\n\n    options = options || {};\n    /**\n     * The state flags of this resource.\n     *\n     * @private\n     * @member {number}\n     */\n\n    this._flags = 0; // set data url flag, needs to be set early for some _determineX checks to work.\n\n    this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);\n    /**\n     * The name of this resource.\n     *\n     * @readonly\n     * @member {string}\n     */\n\n\n    this.name = name;\n    /**\n     * The url used to load this resource.\n     *\n     * @readonly\n     * @member {string}\n     */\n\n    this.url = url;\n    /**\n     * The extension used to load this resource.\n     *\n     * @readonly\n     * @member {string}\n     */\n\n    this.extension = this._getExtension();\n    /**\n     * The data that was loaded by the resource.\n     *\n     * @member {any}\n     */\n\n    this.data = null;\n    /**\n     * Is this request cross-origin? If unset, determined automatically.\n     *\n     * @member {string}\n     */\n\n    this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n    /**\n     * A timeout in milliseconds for the load. If the load takes longer than this time\n     * it is cancelled and the load is considered a failure. If this value is set to `0`\n     * then there is no explicit timeout.\n     *\n     * @member {number}\n     */\n\n    this.timeout = options.timeout || 0;\n    /**\n     * The method of loading to use for this resource.\n     *\n     * @member {Resource.LOAD_TYPE}\n     */\n\n    this.loadType = options.loadType || this._determineLoadType();\n    /**\n     * The type used to load the resource via XHR. If unset, determined automatically.\n     *\n     * @member {string}\n     */\n\n    this.xhrType = options.xhrType;\n    /**\n     * Extra info for middleware, and controlling specifics about how the resource loads.\n     *\n     * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n     * Meaning it will modify it as it sees fit.\n     *\n     * @member {Resource.IMetadata}\n     */\n\n    this.metadata = options.metadata || {};\n    /**\n     * The error that occurred while loading (if any).\n     *\n     * @readonly\n     * @member {Error}\n     */\n\n    this.error = null;\n    /**\n     * The XHR object that was used to load this resource. This is only set\n     * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n     *\n     * @readonly\n     * @member {XMLHttpRequest}\n     */\n\n    this.xhr = null;\n    /**\n     * The child resources this resource owns.\n     *\n     * @readonly\n     * @member {Resource[]}\n     */\n\n    this.children = [];\n    /**\n     * The resource type.\n     *\n     * @readonly\n     * @member {Resource.TYPE}\n     */\n\n    this.type = Resource.TYPE.UNKNOWN;\n    /**\n     * The progress chunk owned by this resource.\n     *\n     * @readonly\n     * @member {number}\n     */\n\n    this.progressChunk = 0;\n    /**\n     * The `dequeue` method that will be used a storage place for the async queue dequeue method\n     * used privately by the loader.\n     *\n     * @private\n     * @member {function}\n     */\n\n    this._dequeue = _noop;\n    /**\n     * Used a storage place for the on load binding used privately by the loader.\n     *\n     * @private\n     * @member {function}\n     */\n\n    this._onLoadBinding = null;\n    /**\n     * The timer for element loads to check if they timeout.\n     *\n     * @private\n     * @member {number}\n     */\n\n    this._elementTimer = 0;\n    /**\n     * The `complete` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n\n    this._boundComplete = this.complete.bind(this);\n    /**\n     * The `_onError` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n\n    this._boundOnError = this._onError.bind(this);\n    /**\n     * The `_onProgress` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n\n    this._boundOnProgress = this._onProgress.bind(this);\n    /**\n     * The `_onTimeout` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n\n    this._boundOnTimeout = this._onTimeout.bind(this); // xhr callbacks\n\n    this._boundXhrOnError = this._xhrOnError.bind(this);\n    this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n    /**\n     * Dispatched when the resource beings to load.\n     *\n     * The callback looks like {@link Resource.OnStartSignal}.\n     *\n     * @member {Signal<Resource.OnStartSignal>}\n     */\n\n    this.onStart = new _miniSignals2.default();\n    /**\n     * Dispatched each time progress of this resource load updates.\n     * Not all resources types and loader systems can support this event\n     * so sometimes it may not be available. If the resource\n     * is being loaded on a modern browser, using XHR, and the remote server\n     * properly sets Content-Length headers, then this will be available.\n     *\n     * The callback looks like {@link Resource.OnProgressSignal}.\n     *\n     * @member {Signal<Resource.OnProgressSignal>}\n     */\n\n    this.onProgress = new _miniSignals2.default();\n    /**\n     * Dispatched once this resource has loaded, if there was an error it will\n     * be in the `error` property.\n     *\n     * The callback looks like {@link Resource.OnCompleteSignal}.\n     *\n     * @member {Signal<Resource.OnCompleteSignal>}\n     */\n\n    this.onComplete = new _miniSignals2.default();\n    /**\n     * Dispatched after this resource has had all the *after* middleware run on it.\n     *\n     * The callback looks like {@link Resource.OnCompleteSignal}.\n     *\n     * @member {Signal<Resource.OnCompleteSignal>}\n     */\n\n    this.onAfterMiddleware = new _miniSignals2.default();\n  }\n  /**\n   * When the resource starts to load.\n   *\n   * @memberof Resource\n   * @callback OnStartSignal\n   * @param {Resource} resource - The resource that the event happened on.\n   */\n\n  /**\n   * When the resource reports loading progress.\n   *\n   * @memberof Resource\n   * @callback OnProgressSignal\n   * @param {Resource} resource - The resource that the event happened on.\n   * @param {number} percentage - The progress of the load in the range [0, 1].\n   */\n\n  /**\n   * When the resource finishes loading.\n   *\n   * @memberof Resource\n   * @callback OnCompleteSignal\n   * @param {Resource} resource - The resource that the event happened on.\n   */\n\n  /**\n   * @memberof Resource\n   * @typedef {object} IMetadata\n   * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n   *      element to use for loading, instead of creating one.\n   * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n   *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n   * @property {string|string[]} [mimeType] - The mime type to use for the source element\n   *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n   *      where each index is the mime type to use for the corresponding url index.\n   */\n\n  /**\n   * Stores whether or not this url is a data url.\n   *\n   * @readonly\n   * @member {boolean}\n   */\n\n  /**\n   * Marks the resource as complete.\n   *\n   */\n\n\n  Resource.prototype.complete = function complete() {\n    this._clearEvents();\n\n    this._finish();\n  };\n  /**\n   * Aborts the loading of this resource, with an optional message.\n   *\n   * @param {string} message - The message to use for the error\n   */\n\n\n  Resource.prototype.abort = function abort(message) {\n    // abort can be called multiple times, ignore subsequent calls.\n    if (this.error) {\n      return;\n    } // store error\n\n\n    this.error = new Error(message); // clear events before calling aborts\n\n    this._clearEvents(); // abort the actual loading\n\n\n    if (this.xhr) {\n      this.xhr.abort();\n    } else if (this.xdr) {\n      this.xdr.abort();\n    } else if (this.data) {\n      // single source\n      if (this.data.src) {\n        this.data.src = Resource.EMPTY_GIF;\n      } // multi-source\n      else {\n        while (this.data.firstChild) {\n          this.data.removeChild(this.data.firstChild);\n        }\n      }\n    } // done now.\n\n\n    this._finish();\n  };\n  /**\n   * Kicks off loading of this resource. This method is asynchronous.\n   *\n   * @param {Resource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n   */\n\n\n  Resource.prototype.load = function load(cb) {\n    var _this = this;\n\n    if (this.isLoading) {\n      return;\n    }\n\n    if (this.isComplete) {\n      if (cb) {\n        setTimeout(function () {\n          return cb(_this);\n        }, 1);\n      }\n\n      return;\n    } else if (cb) {\n      this.onComplete.once(cb);\n    }\n\n    this._setFlag(Resource.STATUS_FLAGS.LOADING, true);\n\n    this.onStart.dispatch(this); // if unset, determine the value\n\n    if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n      this.crossOrigin = this._determineCrossOrigin(this.url);\n    }\n\n    switch (this.loadType) {\n      case Resource.LOAD_TYPE.IMAGE:\n        this.type = Resource.TYPE.IMAGE;\n\n        this._loadElement('image');\n\n        break;\n\n      case Resource.LOAD_TYPE.AUDIO:\n        this.type = Resource.TYPE.AUDIO;\n\n        this._loadSourceElement('audio');\n\n        break;\n\n      case Resource.LOAD_TYPE.VIDEO:\n        this.type = Resource.TYPE.VIDEO;\n\n        this._loadSourceElement('video');\n\n        break;\n\n      case Resource.LOAD_TYPE.XHR:\n      /* falls through */\n\n      default:\n        if (useXdr && this.crossOrigin) {\n          this._loadXdr();\n        } else {\n          this._loadXhr();\n        }\n\n        break;\n    }\n  };\n  /**\n   * Checks if the flag is set.\n   *\n   * @private\n   * @param {number} flag - The flag to check.\n   * @return {boolean} True if the flag is set.\n   */\n\n\n  Resource.prototype._hasFlag = function _hasFlag(flag) {\n    return (this._flags & flag) !== 0;\n  };\n  /**\n   * (Un)Sets the flag.\n   *\n   * @private\n   * @param {number} flag - The flag to (un)set.\n   * @param {boolean} value - Whether to set or (un)set the flag.\n   */\n\n\n  Resource.prototype._setFlag = function _setFlag(flag, value) {\n    this._flags = value ? this._flags | flag : this._flags & ~flag;\n  };\n  /**\n   * Clears all the events from the underlying loading source.\n   *\n   * @private\n   */\n\n\n  Resource.prototype._clearEvents = function _clearEvents() {\n    clearTimeout(this._elementTimer);\n\n    if (this.data && this.data.removeEventListener) {\n      this.data.removeEventListener('error', this._boundOnError, false);\n      this.data.removeEventListener('load', this._boundComplete, false);\n      this.data.removeEventListener('progress', this._boundOnProgress, false);\n      this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n    }\n\n    if (this.xhr) {\n      if (this.xhr.removeEventListener) {\n        this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n        this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);\n        this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n        this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n        this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n      } else {\n        this.xhr.onerror = null;\n        this.xhr.ontimeout = null;\n        this.xhr.onprogress = null;\n        this.xhr.onload = null;\n      }\n    }\n  };\n  /**\n   * Finalizes the load.\n   *\n   * @private\n   */\n\n\n  Resource.prototype._finish = function _finish() {\n    if (this.isComplete) {\n      throw new Error('Complete called again for an already completed resource.');\n    }\n\n    this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);\n\n    this._setFlag(Resource.STATUS_FLAGS.LOADING, false);\n\n    this.onComplete.dispatch(this);\n  };\n  /**\n   * Loads this resources using an element that has a single source,\n   * like an HTMLImageElement.\n   *\n   * @private\n   * @param {string} type - The type of element to use.\n   */\n\n\n  Resource.prototype._loadElement = function _loadElement(type) {\n    if (this.metadata.loadElement) {\n      this.data = this.metadata.loadElement;\n    } else if (type === 'image' && typeof window.Image !== 'undefined') {\n      this.data = new Image();\n    } else {\n      this.data = document.createElement(type);\n    }\n\n    if (this.crossOrigin) {\n      this.data.crossOrigin = this.crossOrigin;\n    }\n\n    if (!this.metadata.skipSource) {\n      this.data.src = this.url;\n    }\n\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n\n    if (this.timeout) {\n      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n    }\n  };\n  /**\n   * Loads this resources using an element that has multiple sources,\n   * like an HTMLAudioElement or HTMLVideoElement.\n   *\n   * @private\n   * @param {string} type - The type of element to use.\n   */\n\n\n  Resource.prototype._loadSourceElement = function _loadSourceElement(type) {\n    if (this.metadata.loadElement) {\n      this.data = this.metadata.loadElement;\n    } else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n      this.data = new Audio();\n    } else {\n      this.data = document.createElement(type);\n    }\n\n    if (this.data === null) {\n      this.abort('Unsupported element: ' + type);\n      return;\n    }\n\n    if (this.crossOrigin) {\n      this.data.crossOrigin = this.crossOrigin;\n    }\n\n    if (!this.metadata.skipSource) {\n      // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n      if (navigator.isCocoonJS) {\n        this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n      } else if (Array.isArray(this.url)) {\n        var mimeTypes = this.metadata.mimeType;\n\n        for (var i = 0; i < this.url.length; ++i) {\n          this.data.appendChild(this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes));\n        }\n      } else {\n        var _mimeTypes = this.metadata.mimeType;\n        this.data.appendChild(this._createSource(type, this.url, Array.isArray(_mimeTypes) ? _mimeTypes[0] : _mimeTypes));\n      }\n    }\n\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n    this.data.addEventListener('canplaythrough', this._boundComplete, false);\n    this.data.load();\n\n    if (this.timeout) {\n      this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n    }\n  };\n  /**\n   * Loads this resources using an XMLHttpRequest.\n   *\n   * @private\n   */\n\n\n  Resource.prototype._loadXhr = function _loadXhr() {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n      this.xhrType = this._determineXhrType();\n    }\n\n    var xhr = this.xhr = new XMLHttpRequest(); // set the request type and url\n\n    xhr.open('GET', this.url, true);\n    xhr.timeout = this.timeout; // load json as text and parse it ourselves. We do this because some browsers\n    // *cough* safari *cough* can't deal with it.\n\n    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n      xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n    } else {\n      xhr.responseType = this.xhrType;\n    }\n\n    xhr.addEventListener('error', this._boundXhrOnError, false);\n    xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);\n    xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n    xhr.addEventListener('progress', this._boundOnProgress, false);\n    xhr.addEventListener('load', this._boundXhrOnLoad, false);\n    xhr.send();\n  };\n  /**\n   * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n   *\n   * @private\n   */\n\n\n  Resource.prototype._loadXdr = function _loadXdr() {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n      this.xhrType = this._determineXhrType();\n    }\n\n    var xdr = this.xhr = new XDomainRequest(); // eslint-disable-line no-undef\n    // XDomainRequest has a few quirks. Occasionally it will abort requests\n    // A way to avoid this is to make sure ALL callbacks are set even if not used\n    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n\n    xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9\n\n    xdr.onerror = this._boundXhrOnError;\n    xdr.ontimeout = this._boundXhrOnTimeout;\n    xdr.onprogress = this._boundOnProgress;\n    xdr.onload = this._boundXhrOnLoad;\n    xdr.open('GET', this.url, true); // Note: The xdr.send() call is wrapped in a timeout to prevent an\n    // issue with the interface where some requests are lost if multiple\n    // XDomainRequests are being sent at the same time.\n    // Some info here: https://github.com/photonstorm/phaser/issues/1248\n\n    setTimeout(function () {\n      return xdr.send();\n    }, 1);\n  };\n  /**\n   * Creates a source used in loading via an element.\n   *\n   * @private\n   * @param {string} type - The element type (video or audio).\n   * @param {string} url - The source URL to load from.\n   * @param {string} [mime] - The mime type of the video\n   * @return {HTMLSourceElement} The source element.\n   */\n\n\n  Resource.prototype._createSource = function _createSource(type, url, mime) {\n    if (!mime) {\n      mime = type + '/' + this._getExtension(url);\n    }\n\n    var source = document.createElement('source');\n    source.src = url;\n    source.type = mime;\n    return source;\n  };\n  /**\n   * Called if a load errors out.\n   *\n   * @param {Event} event - The error event from the element that emits it.\n   * @private\n   */\n\n\n  Resource.prototype._onError = function _onError(event) {\n    this.abort('Failed to load element using: ' + event.target.nodeName);\n  };\n  /**\n   * Called if a load progress event fires for an element or xhr/xdr.\n   *\n   * @private\n   * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n   */\n\n\n  Resource.prototype._onProgress = function _onProgress(event) {\n    if (event && event.lengthComputable) {\n      this.onProgress.dispatch(this, event.loaded / event.total);\n    }\n  };\n  /**\n   * Called if a timeout event fires for an element.\n   *\n   * @private\n   */\n\n\n  Resource.prototype._onTimeout = function _onTimeout() {\n    this.abort('Load timed out.');\n  };\n  /**\n   * Called if an error event fires for xhr/xdr.\n   *\n   * @private\n   */\n\n\n  Resource.prototype._xhrOnError = function _xhrOnError() {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: \"' + xhr.statusText + '\"');\n  };\n  /**\n   * Called if an error event fires for xhr/xdr.\n   *\n   * @private\n   */\n\n\n  Resource.prototype._xhrOnTimeout = function _xhrOnTimeout() {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + ' Request timed out.');\n  };\n  /**\n   * Called if an abort event fires for xhr/xdr.\n   *\n   * @private\n   */\n\n\n  Resource.prototype._xhrOnAbort = function _xhrOnAbort() {\n    var xhr = this.xhr;\n    this.abort(reqType(xhr) + ' Request was aborted by the user.');\n  };\n  /**\n   * Called when data successfully loads from an xhr/xdr request.\n   *\n   * @private\n   * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n   */\n\n\n  Resource.prototype._xhrOnLoad = function _xhrOnLoad() {\n    var xhr = this.xhr;\n    var text = '';\n    var status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.\n    // responseText is accessible only if responseType is '' or 'text' and on older browsers\n\n    if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {\n      text = xhr.responseText;\n    } // status can be 0 when using the `file://` protocol so we also check if a response is set.\n    // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n\n\n    if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER)) {\n      status = STATUS_OK;\n    } // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n    else if (status === STATUS_IE_BUG_EMPTY) {\n      status = STATUS_EMPTY;\n    }\n\n    var statusType = status / 100 | 0;\n\n    if (statusType === STATUS_TYPE_OK) {\n      // if text, just return it\n      if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n        this.data = text;\n        this.type = Resource.TYPE.TEXT;\n      } // if json, parse into json object\n      else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n        try {\n          this.data = JSON.parse(text);\n          this.type = Resource.TYPE.JSON;\n        } catch (e) {\n          this.abort('Error trying to parse loaded json: ' + e);\n          return;\n        }\n      } // if xml, parse into an xml document or div element\n      else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n        try {\n          if (window.DOMParser) {\n            var domparser = new DOMParser();\n            this.data = domparser.parseFromString(text, 'text/xml');\n          } else {\n            var div = document.createElement('div');\n            div.innerHTML = text;\n            this.data = div;\n          }\n\n          this.type = Resource.TYPE.XML;\n        } catch (e) {\n          this.abort('Error trying to parse loaded xml: ' + e);\n          return;\n        }\n      } // other types just return the response\n      else {\n        this.data = xhr.response || text;\n      }\n    } else {\n      this.abort('[' + xhr.status + '] ' + xhr.statusText + ': ' + xhr.responseURL);\n      return;\n    }\n\n    this.complete();\n  };\n  /**\n   * Sets the `crossOrigin` property for this resource based on if the url\n   * for this resource is cross-origin. If crossOrigin was manually set, this\n   * function does nothing.\n   *\n   * @private\n   * @param {string} url - The url to test.\n   * @param {object} [loc=window.location] - The location object to test against.\n   * @return {string} The crossOrigin value to use (or empty string for none).\n   */\n\n\n  Resource.prototype._determineCrossOrigin = function _determineCrossOrigin(url, loc) {\n    // data: and javascript: urls are considered same-origin\n    if (url.indexOf('data:') === 0) {\n      return '';\n    } // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n    // origin designed not to match window.location.origin, and will always require\n    // crossOrigin requests regardless of whether the location matches.\n\n\n    if (window.origin !== window.location.origin) {\n      return 'anonymous';\n    } // default is window.location\n\n\n    loc = loc || window.location;\n\n    if (!tempAnchor) {\n      tempAnchor = document.createElement('a');\n    } // let the browser determine the full href for the url of this resource and then\n    // parse with the node url lib, we can't use the properties of the anchor element\n    // because they don't work in IE9 :(\n\n\n    tempAnchor.href = url;\n    url = (0, _parseUri2.default)(tempAnchor.href, {\n      strictMode: true\n    });\n    var samePort = !url.port && loc.port === '' || url.port === loc.port;\n    var protocol = url.protocol ? url.protocol + ':' : ''; // if cross origin\n\n    if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n      return 'anonymous';\n    }\n\n    return '';\n  };\n  /**\n   * Determines the responseType of an XHR request based on the extension of the\n   * resource being loaded.\n   *\n   * @private\n   * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n   */\n\n\n  Resource.prototype._determineXhrType = function _determineXhrType() {\n    return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;\n  };\n  /**\n   * Determines the loadType of a resource based on the extension of the\n   * resource being loaded.\n   *\n   * @private\n   * @return {Resource.LOAD_TYPE} The loadType to use.\n   */\n\n\n  Resource.prototype._determineLoadType = function _determineLoadType() {\n    return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;\n  };\n  /**\n   * Extracts the extension (sans '.') of the file being loaded by the resource.\n   *\n   * @private\n   * @return {string} The extension.\n   */\n\n\n  Resource.prototype._getExtension = function _getExtension() {\n    var url = this.url;\n    var ext = '';\n\n    if (this.isDataUrl) {\n      var slashIndex = url.indexOf('/');\n      ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n    } else {\n      var queryStart = url.indexOf('?');\n      var hashStart = url.indexOf('#');\n      var index = Math.min(queryStart > -1 ? queryStart : url.length, hashStart > -1 ? hashStart : url.length);\n      url = url.substring(0, index);\n      ext = url.substring(url.lastIndexOf('.') + 1);\n    }\n\n    return ext.toLowerCase();\n  };\n  /**\n   * Determines the mime type of an XHR request based on the responseType of\n   * resource being loaded.\n   *\n   * @private\n   * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n   * @return {string} The mime type to use.\n   */\n\n\n  Resource.prototype._getMimeFromXhrType = function _getMimeFromXhrType(type) {\n    switch (type) {\n      case Resource.XHR_RESPONSE_TYPE.BUFFER:\n        return 'application/octet-binary';\n\n      case Resource.XHR_RESPONSE_TYPE.BLOB:\n        return 'application/blob';\n\n      case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n        return 'application/xml';\n\n      case Resource.XHR_RESPONSE_TYPE.JSON:\n        return 'application/json';\n\n      case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n      case Resource.XHR_RESPONSE_TYPE.TEXT:\n      /* falls through */\n\n      default:\n        return 'text/plain';\n    }\n  };\n\n  _createClass(Resource, [{\n    key: 'isDataUrl',\n    get: function get() {\n      return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);\n    }\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n  }, {\n    key: 'isComplete',\n    get: function get() {\n      return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);\n    }\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n\n  }, {\n    key: 'isLoading',\n    get: function get() {\n      return this._hasFlag(Resource.STATUS_FLAGS.LOADING);\n    }\n  }]);\n\n  return Resource;\n}();\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\n\n\nResource.STATUS_FLAGS = {\n  NONE: 0,\n  DATA_URL: 1 << 0,\n  COMPLETE: 1 << 1,\n  LOADING: 1 << 2\n};\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\n\nResource.TYPE = {\n  UNKNOWN: 0,\n  JSON: 1,\n  XML: 2,\n  IMAGE: 3,\n  AUDIO: 4,\n  VIDEO: 5,\n  TEXT: 6\n};\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @readonly\n * @enum {number}\n */\n\nResource.LOAD_TYPE = {\n  /** Uses XMLHttpRequest to load the resource. */\n  XHR: 1,\n\n  /** Uses an `Image` object to load the resource. */\n  IMAGE: 2,\n\n  /** Uses an `Audio` object to load the resource. */\n  AUDIO: 3,\n\n  /** Uses a `Video` object to load the resource. */\n  VIDEO: 4\n};\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @readonly\n * @enum {string}\n */\n\nResource.XHR_RESPONSE_TYPE = {\n  /** string */\n  DEFAULT: 'text',\n\n  /** ArrayBuffer */\n  BUFFER: 'arraybuffer',\n\n  /** Blob */\n  BLOB: 'blob',\n\n  /** Document */\n  DOCUMENT: 'document',\n\n  /** Object */\n  JSON: 'json',\n\n  /** String */\n  TEXT: 'text'\n};\nResource._loadTypeMap = {\n  // images\n  gif: Resource.LOAD_TYPE.IMAGE,\n  png: Resource.LOAD_TYPE.IMAGE,\n  bmp: Resource.LOAD_TYPE.IMAGE,\n  jpg: Resource.LOAD_TYPE.IMAGE,\n  jpeg: Resource.LOAD_TYPE.IMAGE,\n  tif: Resource.LOAD_TYPE.IMAGE,\n  tiff: Resource.LOAD_TYPE.IMAGE,\n  webp: Resource.LOAD_TYPE.IMAGE,\n  tga: Resource.LOAD_TYPE.IMAGE,\n  svg: Resource.LOAD_TYPE.IMAGE,\n  'svg+xml': Resource.LOAD_TYPE.IMAGE,\n  // for SVG data urls\n  // audio\n  mp3: Resource.LOAD_TYPE.AUDIO,\n  ogg: Resource.LOAD_TYPE.AUDIO,\n  wav: Resource.LOAD_TYPE.AUDIO,\n  // videos\n  mp4: Resource.LOAD_TYPE.VIDEO,\n  webm: Resource.LOAD_TYPE.VIDEO\n};\nResource._xhrTypeMap = {\n  // xml\n  xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n  // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n  // this should probably be fine.\n  tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  // images\n  gif: Resource.XHR_RESPONSE_TYPE.BLOB,\n  png: Resource.XHR_RESPONSE_TYPE.BLOB,\n  bmp: Resource.XHR_RESPONSE_TYPE.BLOB,\n  jpg: Resource.XHR_RESPONSE_TYPE.BLOB,\n  jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tif: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tiff: Resource.XHR_RESPONSE_TYPE.BLOB,\n  webp: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tga: Resource.XHR_RESPONSE_TYPE.BLOB,\n  // json\n  json: Resource.XHR_RESPONSE_TYPE.JSON,\n  // text\n  text: Resource.XHR_RESPONSE_TYPE.TEXT,\n  txt: Resource.XHR_RESPONSE_TYPE.TEXT,\n  // fonts\n  ttf: Resource.XHR_RESPONSE_TYPE.BUFFER,\n  otf: Resource.XHR_RESPONSE_TYPE.BUFFER\n}; // We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\n\nResource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n/**\n * Quick helper to set a value on one of the extension maps. Ensures there is no\n * dot at the start of the extension.\n *\n * @ignore\n * @param {object} map - The map to set on.\n * @param {string} extname - The extension (or key) to set.\n * @param {number} val - The value to set.\n */\n\nfunction setExtMap(map, extname, val) {\n  if (extname && extname.indexOf('.') === 0) {\n    extname = extname.substring(1);\n  }\n\n  if (!extname) {\n    return;\n  }\n\n  map[extname] = val;\n}\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n * @return {string} The type.\n */\n\n\nfunction reqType(xhr) {\n  return xhr.toString().replace('object ', '');\n} // Backwards compat\n\n\nif (typeof module !== 'undefined') {\n  module.exports.default = Resource; // eslint-disable-line no-undef\n}","map":{"version":3,"sources":["../src/Resource.js"],"names":["useXdr","window","tempAnchor","STATUS_NONE","STATUS_OK","STATUS_EMPTY","STATUS_IE_BUG_EMPTY","STATUS_TYPE_OK","Resource","setExtensionLoadType","extname","loadType","setExtMap","setExtensionXhrType","xhrType","options","url","Signal","complete","abort","message","load","cb","setTimeout","_hasFlag","flag","_setFlag","value","_clearEvents","clearTimeout","_finish","_loadElement","type","document","_loadSourceElement","navigator","Array","mimeTypes","i","_loadXhr","xhr","_loadXdr","xdr","_createSource","mime","source","_onError","event","_onProgress","_onTimeout","_xhrOnError","reqType","_xhrOnTimeout","_xhrOnAbort","_xhrOnLoad","text","status","statusType","JSON","domparser","div","_determineCrossOrigin","loc","strictMode","samePort","protocol","_determineXhrType","_determineLoadType","_getExtension","ext","slashIndex","queryStart","hashStart","index","Math","_getMimeFromXhrType","NONE","DATA_URL","COMPLETE","LOADING","UNKNOWN","XML","IMAGE","AUDIO","VIDEO","TEXT","XHR","DEFAULT","BUFFER","BLOB","DOCUMENT","gif","png","bmp","jpg","jpeg","tif","tiff","webp","tga","svg","mp3","ogg","wav","mp4","webm","xhtml","html","htm","xml","tmx","tsx","json","txt","ttf","otf","map","module"],"mappings":"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","sourcesContent":["import parseUri from 'parse-uri';\nimport Signal from 'mini-signals';\n\n// tests if CORS is supported in XHR, if not we need to use XDR\nconst useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest())));\nlet tempAnchor = null;\n\n// some status constants\nconst STATUS_NONE = 0;\nconst STATUS_OK = 200;\nconst STATUS_EMPTY = 204;\nconst STATUS_IE_BUG_EMPTY = 1223;\nconst STATUS_TYPE_OK = 2;\n\n// noop\nfunction _noop() { /* empty */ }\n\n/**\n * Manages the state and loading of a resource and all child resources.\n *\n * @class\n */\nexport class Resource {\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n     */\n    static setExtensionLoadType(extname, loadType) {\n        setExtMap(Resource._loadTypeMap, extname, loadType);\n    }\n\n    /**\n     * Sets the load type to be used for a specific extension.\n     *\n     * @static\n     * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n     * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n     */\n    static setExtensionXhrType(extname, xhrType) {\n        setExtMap(Resource._xhrTypeMap, extname, xhrType);\n    }\n\n    /**\n     * @param {string} name - The name of the resource to load.\n     * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass\n     *      an array of sources.\n     * @param {object} [options] - The options for the load.\n     * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to\n     *      determine automatically.\n     * @param {number} [options.timeout=0] - A timeout in milliseconds for the load. If the load takes\n     *      longer than this time it is cancelled and the load is considered a failure. If this value is\n     *      set to `0` then there is no explicit timeout.\n     * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n     *      be loaded?\n     * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n     *      should the data being loaded be interpreted when using XHR?\n     * @param {Resource.IMetadata} [options.metadata] - Extra configuration for middleware and the Resource object.\n     */\n    constructor(name, url, options) {\n        if (typeof name !== 'string' || typeof url !== 'string') {\n            throw new Error('Both name and url are required for constructing a resource.');\n        }\n\n        options = options || {};\n\n        /**\n         * The state flags of this resource.\n         *\n         * @private\n         * @member {number}\n         */\n        this._flags = 0;\n\n        // set data url flag, needs to be set early for some _determineX checks to work.\n        this._setFlag(Resource.STATUS_FLAGS.DATA_URL, url.indexOf('data:') === 0);\n\n        /**\n         * The name of this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.name = name;\n\n        /**\n         * The url used to load this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.url = url;\n\n        /**\n         * The extension used to load this resource.\n         *\n         * @readonly\n         * @member {string}\n         */\n        this.extension = this._getExtension();\n\n        /**\n         * The data that was loaded by the resource.\n         *\n         * @member {any}\n         */\n        this.data = null;\n\n        /**\n         * Is this request cross-origin? If unset, determined automatically.\n         *\n         * @member {string}\n         */\n        this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n\n        /**\n         * A timeout in milliseconds for the load. If the load takes longer than this time\n         * it is cancelled and the load is considered a failure. If this value is set to `0`\n         * then there is no explicit timeout.\n         *\n         * @member {number}\n         */\n        this.timeout = options.timeout || 0;\n\n        /**\n         * The method of loading to use for this resource.\n         *\n         * @member {Resource.LOAD_TYPE}\n         */\n        this.loadType = options.loadType || this._determineLoadType();\n\n        /**\n         * The type used to load the resource via XHR. If unset, determined automatically.\n         *\n         * @member {string}\n         */\n        this.xhrType = options.xhrType;\n\n        /**\n         * Extra info for middleware, and controlling specifics about how the resource loads.\n         *\n         * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n         * Meaning it will modify it as it sees fit.\n         *\n         * @member {Resource.IMetadata}\n         */\n        this.metadata = options.metadata || {};\n\n        /**\n         * The error that occurred while loading (if any).\n         *\n         * @readonly\n         * @member {Error}\n         */\n        this.error = null;\n\n        /**\n         * The XHR object that was used to load this resource. This is only set\n         * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n         *\n         * @readonly\n         * @member {XMLHttpRequest}\n         */\n        this.xhr = null;\n\n        /**\n         * The child resources this resource owns.\n         *\n         * @readonly\n         * @member {Resource[]}\n         */\n        this.children = [];\n\n        /**\n         * The resource type.\n         *\n         * @readonly\n         * @member {Resource.TYPE}\n         */\n        this.type = Resource.TYPE.UNKNOWN;\n\n        /**\n         * The progress chunk owned by this resource.\n         *\n         * @readonly\n         * @member {number}\n         */\n        this.progressChunk = 0;\n\n        /**\n         * The `dequeue` method that will be used a storage place for the async queue dequeue method\n         * used privately by the loader.\n         *\n         * @private\n         * @member {function}\n         */\n        this._dequeue = _noop;\n\n        /**\n         * Used a storage place for the on load binding used privately by the loader.\n         *\n         * @private\n         * @member {function}\n         */\n        this._onLoadBinding = null;\n\n        /**\n         * The timer for element loads to check if they timeout.\n         *\n         * @private\n         * @member {number}\n         */\n        this._elementTimer = 0;\n\n        /**\n         * The `complete` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundComplete = this.complete.bind(this);\n\n        /**\n         * The `_onError` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnError = this._onError.bind(this);\n\n        /**\n         * The `_onProgress` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnProgress = this._onProgress.bind(this);\n\n        /**\n         * The `_onTimeout` function bound to this resource's context.\n         *\n         * @private\n         * @member {function}\n         */\n        this._boundOnTimeout = this._onTimeout.bind(this);\n\n        // xhr callbacks\n        this._boundXhrOnError = this._xhrOnError.bind(this);\n        this._boundXhrOnTimeout = this._xhrOnTimeout.bind(this);\n        this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n        this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n\n        /**\n         * Dispatched when the resource beings to load.\n         *\n         * The callback looks like {@link Resource.OnStartSignal}.\n         *\n         * @member {Signal<Resource.OnStartSignal>}\n         */\n        this.onStart = new Signal();\n\n        /**\n         * Dispatched each time progress of this resource load updates.\n         * Not all resources types and loader systems can support this event\n         * so sometimes it may not be available. If the resource\n         * is being loaded on a modern browser, using XHR, and the remote server\n         * properly sets Content-Length headers, then this will be available.\n         *\n         * The callback looks like {@link Resource.OnProgressSignal}.\n         *\n         * @member {Signal<Resource.OnProgressSignal>}\n         */\n        this.onProgress = new Signal();\n\n        /**\n         * Dispatched once this resource has loaded, if there was an error it will\n         * be in the `error` property.\n         *\n         * The callback looks like {@link Resource.OnCompleteSignal}.\n         *\n         * @member {Signal<Resource.OnCompleteSignal>}\n         */\n        this.onComplete = new Signal();\n\n        /**\n         * Dispatched after this resource has had all the *after* middleware run on it.\n         *\n         * The callback looks like {@link Resource.OnCompleteSignal}.\n         *\n         * @member {Signal<Resource.OnCompleteSignal>}\n         */\n        this.onAfterMiddleware = new Signal();\n    }\n\n    /**\n     * When the resource starts to load.\n     *\n     * @memberof Resource\n     * @callback OnStartSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * When the resource reports loading progress.\n     *\n     * @memberof Resource\n     * @callback OnProgressSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     * @param {number} percentage - The progress of the load in the range [0, 1].\n     */\n\n    /**\n     * When the resource finishes loading.\n     *\n     * @memberof Resource\n     * @callback OnCompleteSignal\n     * @param {Resource} resource - The resource that the event happened on.\n     */\n\n    /**\n     * @memberof Resource\n     * @typedef {object} IMetadata\n     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n     *      element to use for loading, instead of creating one.\n     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n     *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n     * @property {string|string[]} [mimeType] - The mime type to use for the source element\n     *      of a video/audio elment. If the urls are an array, you can pass this as an array as well\n     *      where each index is the mime type to use for the corresponding url index.\n     */\n\n    /**\n     * Stores whether or not this url is a data url.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isDataUrl() {\n        return this._hasFlag(Resource.STATUS_FLAGS.DATA_URL);\n    }\n\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isComplete() {\n        return this._hasFlag(Resource.STATUS_FLAGS.COMPLETE);\n    }\n\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    get isLoading() {\n        return this._hasFlag(Resource.STATUS_FLAGS.LOADING);\n    }\n\n    /**\n     * Marks the resource as complete.\n     *\n     */\n    complete() {\n        this._clearEvents();\n        this._finish();\n    }\n\n    /**\n     * Aborts the loading of this resource, with an optional message.\n     *\n     * @param {string} message - The message to use for the error\n     */\n    abort(message) {\n        // abort can be called multiple times, ignore subsequent calls.\n        if (this.error) {\n            return;\n        }\n\n        // store error\n        this.error = new Error(message);\n\n        // clear events before calling aborts\n        this._clearEvents();\n\n        // abort the actual loading\n        if (this.xhr) {\n            this.xhr.abort();\n        }\n        else if (this.xdr) {\n            this.xdr.abort();\n        }\n        else if (this.data) {\n            // single source\n            if (this.data.src) {\n                this.data.src = Resource.EMPTY_GIF;\n            }\n            // multi-source\n            else {\n                while (this.data.firstChild) {\n                    this.data.removeChild(this.data.firstChild);\n                }\n            }\n        }\n\n        // done now.\n        this._finish();\n    }\n\n    /**\n     * Kicks off loading of this resource. This method is asynchronous.\n     *\n     * @param {Resource.OnCompleteSignal} [cb] - Optional callback to call once the resource is loaded.\n     */\n    load(cb) {\n        if (this.isLoading) {\n            return;\n        }\n\n        if (this.isComplete) {\n            if (cb) {\n                setTimeout(() => cb(this), 1);\n            }\n\n            return;\n        }\n        else if (cb) {\n            this.onComplete.once(cb);\n        }\n\n        this._setFlag(Resource.STATUS_FLAGS.LOADING, true);\n\n        this.onStart.dispatch(this);\n\n        // if unset, determine the value\n        if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n            this.crossOrigin = this._determineCrossOrigin(this.url);\n        }\n\n        switch (this.loadType) {\n            case Resource.LOAD_TYPE.IMAGE:\n                this.type = Resource.TYPE.IMAGE;\n                this._loadElement('image');\n                break;\n\n            case Resource.LOAD_TYPE.AUDIO:\n                this.type = Resource.TYPE.AUDIO;\n                this._loadSourceElement('audio');\n                break;\n\n            case Resource.LOAD_TYPE.VIDEO:\n                this.type = Resource.TYPE.VIDEO;\n                this._loadSourceElement('video');\n                break;\n\n            case Resource.LOAD_TYPE.XHR:\n                /* falls through */\n            default:\n                if (useXdr && this.crossOrigin) {\n                    this._loadXdr();\n                }\n                else {\n                    this._loadXhr();\n                }\n                break;\n        }\n    }\n\n    /**\n     * Checks if the flag is set.\n     *\n     * @private\n     * @param {number} flag - The flag to check.\n     * @return {boolean} True if the flag is set.\n     */\n    _hasFlag(flag) {\n        return (this._flags & flag) !== 0;\n    }\n\n    /**\n     * (Un)Sets the flag.\n     *\n     * @private\n     * @param {number} flag - The flag to (un)set.\n     * @param {boolean} value - Whether to set or (un)set the flag.\n     */\n    _setFlag(flag, value) {\n        this._flags = value ? (this._flags | flag) : (this._flags & ~flag);\n    }\n\n    /**\n     * Clears all the events from the underlying loading source.\n     *\n     * @private\n     */\n    _clearEvents() {\n        clearTimeout(this._elementTimer);\n\n        if (this.data && this.data.removeEventListener) {\n            this.data.removeEventListener('error', this._boundOnError, false);\n            this.data.removeEventListener('load', this._boundComplete, false);\n            this.data.removeEventListener('progress', this._boundOnProgress, false);\n            this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n        }\n\n        if (this.xhr) {\n            if (this.xhr.removeEventListener) {\n                this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n                this.xhr.removeEventListener('timeout', this._boundXhrOnTimeout, false);\n                this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n                this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n                this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n            }\n            else {\n                this.xhr.onerror = null;\n                this.xhr.ontimeout = null;\n                this.xhr.onprogress = null;\n                this.xhr.onload = null;\n            }\n        }\n    }\n\n    /**\n     * Finalizes the load.\n     *\n     * @private\n     */\n    _finish() {\n        if (this.isComplete) {\n            throw new Error('Complete called again for an already completed resource.');\n        }\n\n        this._setFlag(Resource.STATUS_FLAGS.COMPLETE, true);\n        this._setFlag(Resource.STATUS_FLAGS.LOADING, false);\n\n        this.onComplete.dispatch(this);\n    }\n\n    /**\n     * Loads this resources using an element that has a single source,\n     * like an HTMLImageElement.\n     *\n     * @private\n     * @param {string} type - The type of element to use.\n     */\n    _loadElement(type) {\n        if (this.metadata.loadElement) {\n            this.data = this.metadata.loadElement;\n        }\n        else if (type === 'image' && typeof window.Image !== 'undefined') {\n            this.data = new Image();\n        }\n        else {\n            this.data = document.createElement(type);\n        }\n\n        if (this.crossOrigin) {\n            this.data.crossOrigin = this.crossOrigin;\n        }\n\n        if (!this.metadata.skipSource) {\n            this.data.src = this.url;\n        }\n\n        this.data.addEventListener('error', this._boundOnError, false);\n        this.data.addEventListener('load', this._boundComplete, false);\n        this.data.addEventListener('progress', this._boundOnProgress, false);\n\n        if (this.timeout) {\n            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n        }\n    }\n\n    /**\n     * Loads this resources using an element that has multiple sources,\n     * like an HTMLAudioElement or HTMLVideoElement.\n     *\n     * @private\n     * @param {string} type - The type of element to use.\n     */\n    _loadSourceElement(type) {\n        if (this.metadata.loadElement) {\n            this.data = this.metadata.loadElement;\n        }\n        else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n            this.data = new Audio();\n        }\n        else {\n            this.data = document.createElement(type);\n        }\n\n        if (this.data === null) {\n            this.abort(`Unsupported element: ${type}`);\n\n            return;\n        }\n\n        if (this.crossOrigin) {\n            this.data.crossOrigin = this.crossOrigin;\n        }\n\n        if (!this.metadata.skipSource) {\n            // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n            if (navigator.isCocoonJS) {\n                this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n            }\n            else if (Array.isArray(this.url)) {\n                const mimeTypes = this.metadata.mimeType;\n\n                for (let i = 0; i < this.url.length; ++i) {\n                    this.data.appendChild(\n                        this._createSource(type, this.url[i], Array.isArray(mimeTypes) ? mimeTypes[i] : mimeTypes)\n                    );\n                }\n            }\n            else {\n                const mimeTypes = this.metadata.mimeType;\n\n                this.data.appendChild(\n                    this._createSource(type, this.url, Array.isArray(mimeTypes) ? mimeTypes[0] : mimeTypes)\n                );\n            }\n        }\n\n        this.data.addEventListener('error', this._boundOnError, false);\n        this.data.addEventListener('load', this._boundComplete, false);\n        this.data.addEventListener('progress', this._boundOnProgress, false);\n        this.data.addEventListener('canplaythrough', this._boundComplete, false);\n\n        this.data.load();\n\n        if (this.timeout) {\n            this._elementTimer = setTimeout(this._boundOnTimeout, this.timeout);\n        }\n    }\n\n    /**\n     * Loads this resources using an XMLHttpRequest.\n     *\n     * @private\n     */\n    _loadXhr() {\n        // if unset, determine the value\n        if (typeof this.xhrType !== 'string') {\n            this.xhrType = this._determineXhrType();\n        }\n\n        const xhr = this.xhr = new XMLHttpRequest();\n\n        // set the request type and url\n        xhr.open('GET', this.url, true);\n\n        xhr.timeout = this.timeout;\n\n        // load json as text and parse it ourselves. We do this because some browsers\n        // *cough* safari *cough* can't deal with it.\n        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n            xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n        }\n        else {\n            xhr.responseType = this.xhrType;\n        }\n\n        xhr.addEventListener('error', this._boundXhrOnError, false);\n        xhr.addEventListener('timeout', this._boundXhrOnTimeout, false);\n        xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n        xhr.addEventListener('progress', this._boundOnProgress, false);\n        xhr.addEventListener('load', this._boundXhrOnLoad, false);\n\n        xhr.send();\n    }\n\n    /**\n     * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n     *\n     * @private\n     */\n    _loadXdr() {\n        // if unset, determine the value\n        if (typeof this.xhrType !== 'string') {\n            this.xhrType = this._determineXhrType();\n        }\n\n        const xdr = this.xhr = new XDomainRequest(); // eslint-disable-line no-undef\n\n        // XDomainRequest has a few quirks. Occasionally it will abort requests\n        // A way to avoid this is to make sure ALL callbacks are set even if not used\n        // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n        xdr.timeout = this.timeout || 5000; // XDR needs a timeout value or it breaks in IE9\n\n        xdr.onerror = this._boundXhrOnError;\n        xdr.ontimeout = this._boundXhrOnTimeout;\n        xdr.onprogress = this._boundOnProgress;\n        xdr.onload = this._boundXhrOnLoad;\n\n        xdr.open('GET', this.url, true);\n\n        // Note: The xdr.send() call is wrapped in a timeout to prevent an\n        // issue with the interface where some requests are lost if multiple\n        // XDomainRequests are being sent at the same time.\n        // Some info here: https://github.com/photonstorm/phaser/issues/1248\n        setTimeout(() => xdr.send(), 1);\n    }\n\n    /**\n     * Creates a source used in loading via an element.\n     *\n     * @private\n     * @param {string} type - The element type (video or audio).\n     * @param {string} url - The source URL to load from.\n     * @param {string} [mime] - The mime type of the video\n     * @return {HTMLSourceElement} The source element.\n     */\n    _createSource(type, url, mime) {\n        if (!mime) {\n            mime = `${type}/${this._getExtension(url)}`;\n        }\n\n        const source = document.createElement('source');\n\n        source.src = url;\n        source.type = mime;\n\n        return source;\n    }\n\n    /**\n     * Called if a load errors out.\n     *\n     * @param {Event} event - The error event from the element that emits it.\n     * @private\n     */\n    _onError(event) {\n        this.abort(`Failed to load element using: ${event.target.nodeName}`);\n    }\n\n    /**\n     * Called if a load progress event fires for an element or xhr/xdr.\n     *\n     * @private\n     * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n     */\n    _onProgress(event) {\n        if (event && event.lengthComputable) {\n            this.onProgress.dispatch(this, event.loaded / event.total);\n        }\n    }\n\n    /**\n     * Called if a timeout event fires for an element.\n     *\n     * @private\n     */\n    _onTimeout() {\n        this.abort(`Load timed out.`);\n    }\n\n    /**\n     * Called if an error event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnError() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request failed. Status: ${xhr.status}, text: \"${xhr.statusText}\"`);\n    }\n\n    /**\n     * Called if an error event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnTimeout() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request timed out.`);\n    }\n\n    /**\n     * Called if an abort event fires for xhr/xdr.\n     *\n     * @private\n     */\n    _xhrOnAbort() {\n        const xhr = this.xhr;\n\n        this.abort(`${reqType(xhr)} Request was aborted by the user.`);\n    }\n\n    /**\n     * Called when data successfully loads from an xhr/xdr request.\n     *\n     * @private\n     * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n     */\n    _xhrOnLoad() {\n        const xhr = this.xhr;\n        let text = '';\n        let status = typeof xhr.status === 'undefined' ? STATUS_OK : xhr.status; // XDR has no `.status`, assume 200.\n\n        // responseText is accessible only if responseType is '' or 'text' and on older browsers\n        if (xhr.responseType === '' || xhr.responseType === 'text' || typeof xhr.responseType === 'undefined') {\n            text = xhr.responseText;\n        }\n\n        // status can be 0 when using the `file://` protocol so we also check if a response is set.\n        // If it has a response, we assume 200; otherwise a 0 status code with no contents is an aborted request.\n        if (status === STATUS_NONE && (text.length > 0 || xhr.responseType === Resource.XHR_RESPONSE_TYPE.BUFFER)) {\n            status = STATUS_OK;\n        }\n        // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n        else if (status === STATUS_IE_BUG_EMPTY) {\n            status = STATUS_EMPTY;\n        }\n\n        const statusType = (status / 100) | 0;\n\n        if (statusType === STATUS_TYPE_OK) {\n            // if text, just return it\n            if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n                this.data = text;\n                this.type = Resource.TYPE.TEXT;\n            }\n            // if json, parse into json object\n            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n                try {\n                    this.data = JSON.parse(text);\n                    this.type = Resource.TYPE.JSON;\n                }\n                catch (e) {\n                    this.abort(`Error trying to parse loaded json: ${e}`);\n\n                    return;\n                }\n            }\n            // if xml, parse into an xml document or div element\n            else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n                try {\n                    if (window.DOMParser) {\n                        const domparser = new DOMParser();\n\n                        this.data = domparser.parseFromString(text, 'text/xml');\n                    }\n                    else {\n                        const div = document.createElement('div');\n\n                        div.innerHTML = text;\n\n                        this.data = div;\n                    }\n\n                    this.type = Resource.TYPE.XML;\n                }\n                catch (e) {\n                    this.abort(`Error trying to parse loaded xml: ${e}`);\n\n                    return;\n                }\n            }\n            // other types just return the response\n            else {\n                this.data = xhr.response || text;\n            }\n        }\n        else {\n            this.abort(`[${xhr.status}] ${xhr.statusText}: ${xhr.responseURL}`);\n\n            return;\n        }\n\n        this.complete();\n    }\n\n    /**\n     * Sets the `crossOrigin` property for this resource based on if the url\n     * for this resource is cross-origin. If crossOrigin was manually set, this\n     * function does nothing.\n     *\n     * @private\n     * @param {string} url - The url to test.\n     * @param {object} [loc=window.location] - The location object to test against.\n     * @return {string} The crossOrigin value to use (or empty string for none).\n     */\n    _determineCrossOrigin(url, loc) {\n        // data: and javascript: urls are considered same-origin\n        if (url.indexOf('data:') === 0) {\n            return '';\n        }\n\n        // A sandboxed iframe without the 'allow-same-origin' attribute will have a special\n        // origin designed not to match window.location.origin, and will always require\n        // crossOrigin requests regardless of whether the location matches.\n        if (window.origin !== window.location.origin) {\n            return 'anonymous';\n        }\n\n        // default is window.location\n        loc = loc || window.location;\n\n        if (!tempAnchor) {\n            tempAnchor = document.createElement('a');\n        }\n\n        // let the browser determine the full href for the url of this resource and then\n        // parse with the node url lib, we can't use the properties of the anchor element\n        // because they don't work in IE9 :(\n        tempAnchor.href = url;\n        url = parseUri(tempAnchor.href, { strictMode: true });\n\n        const samePort = (!url.port && loc.port === '') || (url.port === loc.port);\n        const protocol = url.protocol ? `${url.protocol}:` : '';\n\n        // if cross origin\n        if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n            return 'anonymous';\n        }\n\n        return '';\n    }\n\n    /**\n     * Determines the responseType of an XHR request based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n     */\n    _determineXhrType() {\n        return Resource._xhrTypeMap[this.extension] || Resource.XHR_RESPONSE_TYPE.TEXT;\n    }\n\n    /**\n     * Determines the loadType of a resource based on the extension of the\n     * resource being loaded.\n     *\n     * @private\n     * @return {Resource.LOAD_TYPE} The loadType to use.\n     */\n    _determineLoadType() {\n        return Resource._loadTypeMap[this.extension] || Resource.LOAD_TYPE.XHR;\n    }\n\n    /**\n     * Extracts the extension (sans '.') of the file being loaded by the resource.\n     *\n     * @private\n     * @return {string} The extension.\n     */\n    _getExtension() {\n        let url = this.url;\n        let ext = '';\n\n        if (this.isDataUrl) {\n            const slashIndex = url.indexOf('/');\n\n            ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n        }\n        else {\n            const queryStart = url.indexOf('?');\n            const hashStart = url.indexOf('#');\n            const index = Math.min(\n                queryStart > -1 ? queryStart : url.length,\n                hashStart > -1 ? hashStart : url.length\n            );\n\n            url = url.substring(0, index);\n            ext = url.substring(url.lastIndexOf('.') + 1);\n        }\n\n        return ext.toLowerCase();\n    }\n\n    /**\n     * Determines the mime type of an XHR request based on the responseType of\n     * resource being loaded.\n     *\n     * @private\n     * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n     * @return {string} The mime type to use.\n     */\n    _getMimeFromXhrType(type) {\n        switch (type) {\n            case Resource.XHR_RESPONSE_TYPE.BUFFER:\n                return 'application/octet-binary';\n\n            case Resource.XHR_RESPONSE_TYPE.BLOB:\n                return 'application/blob';\n\n            case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n                return 'application/xml';\n\n            case Resource.XHR_RESPONSE_TYPE.JSON:\n                return 'application/json';\n\n            case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n            case Resource.XHR_RESPONSE_TYPE.TEXT:\n                /* falls through */\n            default:\n                return 'text/plain';\n        }\n    }\n}\n\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.STATUS_FLAGS = {\n    NONE:       0,\n    DATA_URL:   (1 << 0),\n    COMPLETE:   (1 << 1),\n    LOADING:    (1 << 2),\n};\n\n/**\n * The types of resources a resource could represent.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.TYPE = {\n    UNKNOWN:    0,\n    JSON:       1,\n    XML:        2,\n    IMAGE:      3,\n    AUDIO:      4,\n    VIDEO:      5,\n    TEXT:       6,\n};\n\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.LOAD_TYPE = {\n    /** Uses XMLHttpRequest to load the resource. */\n    XHR:    1,\n    /** Uses an `Image` object to load the resource. */\n    IMAGE:  2,\n    /** Uses an `Audio` object to load the resource. */\n    AUDIO:  3,\n    /** Uses a `Video` object to load the resource. */\n    VIDEO:  4,\n};\n\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @readonly\n * @enum {string}\n */\nResource.XHR_RESPONSE_TYPE = {\n    /** string */\n    DEFAULT:    'text',\n    /** ArrayBuffer */\n    BUFFER:     'arraybuffer',\n    /** Blob */\n    BLOB:       'blob',\n    /** Document */\n    DOCUMENT:   'document',\n    /** Object */\n    JSON:       'json',\n    /** String */\n    TEXT:       'text',\n};\n\nResource._loadTypeMap = {\n    // images\n    gif:        Resource.LOAD_TYPE.IMAGE,\n    png:        Resource.LOAD_TYPE.IMAGE,\n    bmp:        Resource.LOAD_TYPE.IMAGE,\n    jpg:        Resource.LOAD_TYPE.IMAGE,\n    jpeg:       Resource.LOAD_TYPE.IMAGE,\n    tif:        Resource.LOAD_TYPE.IMAGE,\n    tiff:       Resource.LOAD_TYPE.IMAGE,\n    webp:       Resource.LOAD_TYPE.IMAGE,\n    tga:        Resource.LOAD_TYPE.IMAGE,\n    svg:        Resource.LOAD_TYPE.IMAGE,\n    'svg+xml':  Resource.LOAD_TYPE.IMAGE, // for SVG data urls\n\n    // audio\n    mp3:        Resource.LOAD_TYPE.AUDIO,\n    ogg:        Resource.LOAD_TYPE.AUDIO,\n    wav:        Resource.LOAD_TYPE.AUDIO,\n\n    // videos\n    mp4:        Resource.LOAD_TYPE.VIDEO,\n    webm:       Resource.LOAD_TYPE.VIDEO,\n};\n\nResource._xhrTypeMap = {\n    // xml\n    xhtml:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    html:       Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // This was added to handle Tiled Tileset XML, but .tsx is also a TypeScript React Component.\n    // Since it is way less likely for people to be loading TypeScript files instead of Tiled files,\n    // this should probably be fine.\n    tsx:        Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // images\n    gif:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    png:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    bmp:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpg:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpeg:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    tif:        Resource.XHR_RESPONSE_TYPE.BLOB,\n    tiff:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    webp:       Resource.XHR_RESPONSE_TYPE.BLOB,\n    tga:        Resource.XHR_RESPONSE_TYPE.BLOB,\n\n    // json\n    json:       Resource.XHR_RESPONSE_TYPE.JSON,\n\n    // text\n    text:       Resource.XHR_RESPONSE_TYPE.TEXT,\n    txt:        Resource.XHR_RESPONSE_TYPE.TEXT,\n\n    // fonts\n    ttf:        Resource.XHR_RESPONSE_TYPE.BUFFER,\n    otf:        Resource.XHR_RESPONSE_TYPE.BUFFER,\n};\n\n// We can't set the `src` attribute to empty string, so on abort we set it to this 1px transparent gif\nResource.EMPTY_GIF = 'data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==';\n\n/**\n * Quick helper to set a value on one of the extension maps. Ensures there is no\n * dot at the start of the extension.\n *\n * @ignore\n * @param {object} map - The map to set on.\n * @param {string} extname - The extension (or key) to set.\n * @param {number} val - The value to set.\n */\nfunction setExtMap(map, extname, val) {\n    if (extname && extname.indexOf('.') === 0) {\n        extname = extname.substring(1);\n    }\n\n    if (!extname) {\n        return;\n    }\n\n    map[extname] = val;\n}\n\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n * @return {string} The type.\n */\nfunction reqType(xhr) {\n    return xhr.toString().replace('object ', '');\n}\n\n// Backwards compat\nif (typeof module !== 'undefined') {\n    module.exports.default = Resource; // eslint-disable-line no-undef\n}\n"]},"metadata":{},"sourceType":"script"}