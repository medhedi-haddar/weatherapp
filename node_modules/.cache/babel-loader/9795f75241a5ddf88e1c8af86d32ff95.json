{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _eventemitter = require('eventemitter3');\n\nvar _eventemitter2 = _interopRequireDefault(_eventemitter);\n\nvar _const = require('../const');\n\nvar _settings = require('../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nvar _TransformStatic = require('./TransformStatic');\n\nvar _TransformStatic2 = _interopRequireDefault(_TransformStatic);\n\nvar _Transform = require('./Transform');\n\nvar _Transform2 = _interopRequireDefault(_Transform);\n\nvar _Bounds = require('./Bounds');\n\nvar _Bounds2 = _interopRequireDefault(_Bounds);\n\nvar _math = require('../math');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n} // _tempDisplayObjectParent = new DisplayObject();\n\n/**\n * The base class for all objects that are rendered on the screen.\n * This is an abstract class and should not be used on its own rather it should be extended.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\n\n\nvar DisplayObject = function (_EventEmitter) {\n  _inherits(DisplayObject, _EventEmitter);\n  /**\n   *\n   */\n\n\n  function DisplayObject() {\n    _classCallCheck(this, DisplayObject);\n\n    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));\n\n    var TransformClass = _settings2.default.TRANSFORM_MODE === _const.TRANSFORM_MODE.STATIC ? _TransformStatic2.default : _Transform2.default;\n    _this.tempDisplayObjectParent = null; // TODO: need to create Transform from factory\n\n    /**\n     * World transform and local transform of this object.\n     * This will become read-only later, please do not assign anything there unless you know what are you doing\n     *\n     * @member {PIXI.TransformBase}\n     */\n\n    _this.transform = new TransformClass();\n    /**\n     * The opacity of the object.\n     *\n     * @member {number}\n     */\n\n    _this.alpha = 1;\n    /**\n     * The visibility of the object. If false the object will not be drawn, and\n     * the updateTransform function will not be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually\n     *\n     * @member {boolean}\n     */\n\n    _this.visible = true;\n    /**\n     * Can this object be rendered, if false the object will not be drawn but the updateTransform\n     * methods will still be called.\n     *\n     * Only affects recursive calls from parent. You can ask for bounds manually\n     *\n     * @member {boolean}\n     */\n\n    _this.renderable = true;\n    /**\n     * The display object container that contains this display object.\n     *\n     * @member {PIXI.Container}\n     * @readonly\n     */\n\n    _this.parent = null;\n    /**\n     * The multiplied alpha of the displayObject\n     *\n     * @member {number}\n     * @readonly\n     */\n\n    _this.worldAlpha = 1;\n    /**\n     * The area the filter is applied to. This is used as more of an optimisation\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle\n     *\n     * Also works as an interaction mask\n     *\n     * @member {PIXI.Rectangle}\n     */\n\n    _this.filterArea = null;\n    _this._filters = null;\n    _this._enabledFilters = null;\n    /**\n     * The bounds object, this is used to calculate and store the bounds of the displayObject\n     *\n     * @member {PIXI.Rectangle}\n     * @private\n     */\n\n    _this._bounds = new _Bounds2.default();\n    _this._boundsID = 0;\n    _this._lastBoundsID = -1;\n    _this._boundsRect = null;\n    _this._localBoundsRect = null;\n    /**\n     * The original, cached mask of the object\n     *\n     * @member {PIXI.Graphics|PIXI.Sprite}\n     * @private\n     */\n\n    _this._mask = null;\n    /**\n     * If the object has been destroyed via destroy(). If true, it should not be used.\n     *\n     * @member {boolean}\n     * @private\n     * @readonly\n     */\n\n    _this._destroyed = false;\n    /**\n     * Fired when this DisplayObject is added to a Container.\n     *\n     * @event PIXI.DisplayObject#added\n     * @param {PIXI.Container} container - The container added to.\n     */\n\n    /**\n     * Fired when this DisplayObject is removed from a Container.\n     *\n     * @event PIXI.DisplayObject#removed\n     * @param {PIXI.Container} container - The container removed from.\n     */\n\n    return _this;\n  }\n  /**\n   * @private\n   * @member {PIXI.DisplayObject}\n   */\n\n  /**\n   * Updates the object transform for rendering\n   *\n   * TODO - Optimization pass!\n   */\n\n\n  DisplayObject.prototype.updateTransform = function updateTransform() {\n    this.transform.updateTransform(this.parent.transform); // multiply the alphas..\n\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n    this._bounds.updateID++;\n  };\n  /**\n   * recursively updates transform of all objects from the root to this one\n   * internal function for toLocal()\n   */\n\n\n  DisplayObject.prototype._recursivePostUpdateTransform = function _recursivePostUpdateTransform() {\n    if (this.parent) {\n      this.parent._recursivePostUpdateTransform();\n\n      this.transform.updateTransform(this.parent.transform);\n    } else {\n      this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n    }\n  };\n  /**\n   * Retrieves the bounds of the displayObject as a rectangle object.\n   *\n   * @param {boolean} skipUpdate - setting to true will stop the transforms of the scene graph from\n   *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n   *  nice performance boost\n   * @param {PIXI.Rectangle} rect - Optional rectangle to store the result of the bounds calculation\n   * @return {PIXI.Rectangle} the rectangular bounding area\n   */\n\n\n  DisplayObject.prototype.getBounds = function getBounds(skipUpdate, rect) {\n    if (!skipUpdate) {\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.updateTransform();\n        this.parent = null;\n      } else {\n        this._recursivePostUpdateTransform();\n\n        this.updateTransform();\n      }\n    }\n\n    if (this._boundsID !== this._lastBoundsID) {\n      this.calculateBounds();\n    }\n\n    if (!rect) {\n      if (!this._boundsRect) {\n        this._boundsRect = new _math.Rectangle();\n      }\n\n      rect = this._boundsRect;\n    }\n\n    return this._bounds.getRectangle(rect);\n  };\n  /**\n   * Retrieves the local bounds of the displayObject as a rectangle object\n   *\n   * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation\n   * @return {PIXI.Rectangle} the rectangular bounding area\n   */\n\n\n  DisplayObject.prototype.getLocalBounds = function getLocalBounds(rect) {\n    var transformRef = this.transform;\n    var parentRef = this.parent;\n    this.parent = null;\n    this.transform = this._tempDisplayObjectParent.transform;\n\n    if (!rect) {\n      if (!this._localBoundsRect) {\n        this._localBoundsRect = new _math.Rectangle();\n      }\n\n      rect = this._localBoundsRect;\n    }\n\n    var bounds = this.getBounds(false, rect);\n    this.parent = parentRef;\n    this.transform = transformRef;\n    return bounds;\n  };\n  /**\n   * Calculates the global position of the display object\n   *\n   * @param {PIXI.Point} position - The world origin to calculate from\n   * @param {PIXI.Point} [point] - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point)\n   * @param {boolean} [skipUpdate=false] - Should we skip the update transform.\n   * @return {PIXI.Point} A point object representing the position of this object\n   */\n\n\n  DisplayObject.prototype.toGlobal = function toGlobal(position, point) {\n    var skipUpdate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform(); // this parent check is for just in case the item is a root object.\n      // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n      // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n\n\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    } // don't need to update the lot\n\n\n    return this.worldTransform.apply(position, point);\n  };\n  /**\n   * Calculates the local position of the display object relative to another point\n   *\n   * @param {PIXI.Point} position - The world origin to calculate from\n   * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from\n   * @param {PIXI.Point} [point] - A Point object in which to store the value, optional\n   *  (otherwise will create a new Point)\n   * @param {boolean} [skipUpdate=false] - Should we skip the update transform\n   * @return {PIXI.Point} A point object representing the position of this object\n   */\n\n\n  DisplayObject.prototype.toLocal = function toLocal(position, from, point, skipUpdate) {\n    if (from) {\n      position = from.toGlobal(position, point, skipUpdate);\n    }\n\n    if (!skipUpdate) {\n      this._recursivePostUpdateTransform(); // this parent check is for just in case the item is a root object.\n      // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n      // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n\n\n      if (!this.parent) {\n        this.parent = this._tempDisplayObjectParent;\n        this.displayObjectUpdateTransform();\n        this.parent = null;\n      } else {\n        this.displayObjectUpdateTransform();\n      }\n    } // simply apply the matrix..\n\n\n    return this.worldTransform.applyInverse(position, point);\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n\n  DisplayObject.prototype.renderWebGL = function renderWebGL(renderer) // eslint-disable-line no-unused-vars\n  {} // OVERWRITE;\n\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */\n  ;\n\n  DisplayObject.prototype.renderCanvas = function renderCanvas(renderer) // eslint-disable-line no-unused-vars\n  {} // OVERWRITE;\n\n  /**\n   * Set the parent Container of this DisplayObject\n   *\n   * @param {PIXI.Container} container - The Container to add this DisplayObject to\n   * @return {PIXI.Container} The Container that this DisplayObject was added to\n   */\n  ;\n\n  DisplayObject.prototype.setParent = function setParent(container) {\n    if (!container || !container.addChild) {\n      throw new Error('setParent: Argument must be a Container');\n    }\n\n    container.addChild(this);\n    return container;\n  };\n  /**\n   * Convenience function to set the position, scale, skew and pivot at once.\n   *\n   * @param {number} [x=0] - The X position\n   * @param {number} [y=0] - The Y position\n   * @param {number} [scaleX=1] - The X scale value\n   * @param {number} [scaleY=1] - The Y scale value\n   * @param {number} [rotation=0] - The rotation\n   * @param {number} [skewX=0] - The X skew value\n   * @param {number} [skewY=0] - The Y skew value\n   * @param {number} [pivotX=0] - The X pivot value\n   * @param {number} [pivotY=0] - The Y pivot value\n   * @return {PIXI.DisplayObject} The DisplayObject instance\n   */\n\n\n  DisplayObject.prototype.setTransform = function setTransform() {\n    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var scaleX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var scaleY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var skewX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    var skewY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n    var pivotX = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n    var pivotY = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;\n    this.position.x = x;\n    this.position.y = y;\n    this.scale.x = !scaleX ? 1 : scaleX;\n    this.scale.y = !scaleY ? 1 : scaleY;\n    this.rotation = rotation;\n    this.skew.x = skewX;\n    this.skew.y = skewY;\n    this.pivot.x = pivotX;\n    this.pivot.y = pivotY;\n    return this;\n  };\n  /**\n   * Base destroy method for generic display objects. This will automatically\n   * remove the display object from its parent Container as well as remove\n   * all current event listeners and internal references. Do not use a DisplayObject\n   * after calling `destroy`.\n   *\n   */\n\n\n  DisplayObject.prototype.destroy = function destroy() {\n    this.removeAllListeners();\n\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n\n    this.transform = null;\n    this.parent = null;\n    this._bounds = null;\n    this._currentBounds = null;\n    this._mask = null;\n    this.filterArea = null;\n    this.interactive = false;\n    this.interactiveChildren = false;\n    this._destroyed = true;\n  };\n  /**\n   * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n   * An alias to position.x\n   *\n   * @member {number}\n   */\n\n\n  _createClass(DisplayObject, [{\n    key: '_tempDisplayObjectParent',\n    get: function get() {\n      if (this.tempDisplayObjectParent === null) {\n        this.tempDisplayObjectParent = new DisplayObject();\n      }\n\n      return this.tempDisplayObjectParent;\n    }\n  }, {\n    key: 'x',\n    get: function get() {\n      return this.position.x;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.transform.position.x = value;\n    }\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: 'y',\n    get: function get() {\n      return this.position.y;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.transform.position.y = value;\n    }\n    /**\n     * Current transform of the object based on world (parent) factors\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n\n  }, {\n    key: 'worldTransform',\n    get: function get() {\n      return this.transform.worldTransform;\n    }\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n\n  }, {\n    key: 'localTransform',\n    get: function get() {\n      return this.transform.localTransform;\n    }\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.Point|PIXI.ObservablePoint}\n     */\n\n  }, {\n    key: 'position',\n    get: function get() {\n      return this.transform.position;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.transform.position.copy(value);\n    }\n    /**\n     * The scale factor of the object.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.Point|PIXI.ObservablePoint}\n     */\n\n  }, {\n    key: 'scale',\n    get: function get() {\n      return this.transform.scale;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.transform.scale.copy(value);\n    }\n    /**\n     * The pivot point of the displayObject that it rotates around.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.Point|PIXI.ObservablePoint}\n     */\n\n  }, {\n    key: 'pivot',\n    get: function get() {\n      return this.transform.pivot;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.transform.pivot.copy(value);\n    }\n    /**\n     * The skew factor for the object in radians.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n\n  }, {\n    key: 'skew',\n    get: function get() {\n      return this.transform.skew;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.transform.skew.copy(value);\n    }\n    /**\n     * The rotation of the object in radians.\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: 'rotation',\n    get: function get() {\n      return this.transform.rotation;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.transform.rotation = value;\n    }\n    /**\n     * Indicates if the object is globally visible.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n\n  }, {\n    key: 'worldVisible',\n    get: function get() {\n      var item = this;\n\n      do {\n        if (!item.visible) {\n          return false;\n        }\n\n        item = item.parent;\n      } while (item);\n\n      return true;\n    }\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PIXI a regular mask must be a\n     * PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it\n     * utilises shape clipping. To remove a mask, set this property to null.\n     *\n     * @todo For the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n     *\n     * @member {PIXI.Graphics|PIXI.Sprite}\n     */\n\n  }, {\n    key: 'mask',\n    get: function get() {\n      return this._mask;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      if (this._mask) {\n        this._mask.renderable = true;\n        this._mask.isMask = false;\n      }\n\n      this._mask = value;\n\n      if (this._mask) {\n        this._mask.renderable = false;\n        this._mask.isMask = true;\n      }\n    }\n    /**\n     * Sets the filters for the displayObject.\n     * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to 'null'\n     *\n     * @member {PIXI.Filter[]}\n     */\n\n  }, {\n    key: 'filters',\n    get: function get() {\n      return this._filters && this._filters.slice();\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this._filters = value && value.slice();\n    }\n  }]);\n\n  return DisplayObject;\n}(_eventemitter2.default); // performance increase to avoid using call.. (10x faster)\n\n\nexports.default = DisplayObject;\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;","map":{"version":3,"sources":["../../../src/core/display/DisplayObject.js"],"names":["DisplayObject","TransformClass","updateTransform","_recursivePostUpdateTransform","getBounds","skipUpdate","rect","getLocalBounds","transformRef","parentRef","bounds","toGlobal","position","point","toLocal","from","renderWebGL","renderer","renderCanvas","setParent","container","setTransform","x","y","scaleX","scaleY","rotation","skewX","skewY","pivotX","pivotY","destroy","value","item"],"mappings":"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","sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { TRANSFORM_MODE } from '../const';\nimport settings from '../settings';\nimport TransformStatic from './TransformStatic';\nimport Transform from './Transform';\nimport Bounds from './Bounds';\nimport { Rectangle } from '../math';\n// _tempDisplayObjectParent = new DisplayObject();\n\n/**\n * The base class for all objects that are rendered on the screen.\n * This is an abstract class and should not be used on its own rather it should be extended.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\nexport default class DisplayObject extends EventEmitter\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        super();\n\n        const TransformClass = settings.TRANSFORM_MODE === TRANSFORM_MODE.STATIC ? TransformStatic : Transform;\n\n        this.tempDisplayObjectParent = null;\n\n        // TODO: need to create Transform from factory\n        /**\n         * World transform and local transform of this object.\n         * This will become read-only later, please do not assign anything there unless you know what are you doing\n         *\n         * @member {PIXI.TransformBase}\n         */\n        this.transform = new TransformClass();\n\n        /**\n         * The opacity of the object.\n         *\n         * @member {number}\n         */\n        this.alpha = 1;\n\n        /**\n         * The visibility of the object. If false the object will not be drawn, and\n         * the updateTransform function will not be called.\n         *\n         * Only affects recursive calls from parent. You can ask for bounds or call updateTransform manually\n         *\n         * @member {boolean}\n         */\n        this.visible = true;\n\n        /**\n         * Can this object be rendered, if false the object will not be drawn but the updateTransform\n         * methods will still be called.\n         *\n         * Only affects recursive calls from parent. You can ask for bounds manually\n         *\n         * @member {boolean}\n         */\n        this.renderable = true;\n\n        /**\n         * The display object container that contains this display object.\n         *\n         * @member {PIXI.Container}\n         * @readonly\n         */\n        this.parent = null;\n\n        /**\n         * The multiplied alpha of the displayObject\n         *\n         * @member {number}\n         * @readonly\n         */\n        this.worldAlpha = 1;\n\n        /**\n         * The area the filter is applied to. This is used as more of an optimisation\n         * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle\n         *\n         * Also works as an interaction mask\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.filterArea = null;\n\n        this._filters = null;\n        this._enabledFilters = null;\n\n        /**\n         * The bounds object, this is used to calculate and store the bounds of the displayObject\n         *\n         * @member {PIXI.Rectangle}\n         * @private\n         */\n        this._bounds = new Bounds();\n        this._boundsID = 0;\n        this._lastBoundsID = -1;\n        this._boundsRect = null;\n        this._localBoundsRect = null;\n\n        /**\n         * The original, cached mask of the object\n         *\n         * @member {PIXI.Graphics|PIXI.Sprite}\n         * @private\n         */\n        this._mask = null;\n\n        /**\n         * If the object has been destroyed via destroy(). If true, it should not be used.\n         *\n         * @member {boolean}\n         * @private\n         * @readonly\n         */\n        this._destroyed = false;\n\n        /**\n         * Fired when this DisplayObject is added to a Container.\n         *\n         * @event PIXI.DisplayObject#added\n         * @param {PIXI.Container} container - The container added to.\n         */\n\n        /**\n         * Fired when this DisplayObject is removed from a Container.\n         *\n         * @event PIXI.DisplayObject#removed\n         * @param {PIXI.Container} container - The container removed from.\n         */\n    }\n\n    /**\n     * @private\n     * @member {PIXI.DisplayObject}\n     */\n    get _tempDisplayObjectParent()\n    {\n        if (this.tempDisplayObjectParent === null)\n        {\n            this.tempDisplayObjectParent = new DisplayObject();\n        }\n\n        return this.tempDisplayObjectParent;\n    }\n\n    /**\n     * Updates the object transform for rendering\n     *\n     * TODO - Optimization pass!\n     */\n    updateTransform()\n    {\n        this.transform.updateTransform(this.parent.transform);\n        // multiply the alphas..\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        this._bounds.updateID++;\n    }\n\n    /**\n     * recursively updates transform of all objects from the root to this one\n     * internal function for toLocal()\n     */\n    _recursivePostUpdateTransform()\n    {\n        if (this.parent)\n        {\n            this.parent._recursivePostUpdateTransform();\n            this.transform.updateTransform(this.parent.transform);\n        }\n        else\n        {\n            this.transform.updateTransform(this._tempDisplayObjectParent.transform);\n        }\n    }\n\n    /**\n     * Retrieves the bounds of the displayObject as a rectangle object.\n     *\n     * @param {boolean} skipUpdate - setting to true will stop the transforms of the scene graph from\n     *  being updated. This means the calculation returned MAY be out of date BUT will give you a\n     *  nice performance boost\n     * @param {PIXI.Rectangle} rect - Optional rectangle to store the result of the bounds calculation\n     * @return {PIXI.Rectangle} the rectangular bounding area\n     */\n    getBounds(skipUpdate, rect)\n    {\n        if (!skipUpdate)\n        {\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent;\n                this.updateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this._recursivePostUpdateTransform();\n                this.updateTransform();\n            }\n        }\n\n        if (this._boundsID !== this._lastBoundsID)\n        {\n            this.calculateBounds();\n        }\n\n        if (!rect)\n        {\n            if (!this._boundsRect)\n            {\n                this._boundsRect = new Rectangle();\n            }\n\n            rect = this._boundsRect;\n        }\n\n        return this._bounds.getRectangle(rect);\n    }\n\n    /**\n     * Retrieves the local bounds of the displayObject as a rectangle object\n     *\n     * @param {PIXI.Rectangle} [rect] - Optional rectangle to store the result of the bounds calculation\n     * @return {PIXI.Rectangle} the rectangular bounding area\n     */\n    getLocalBounds(rect)\n    {\n        const transformRef = this.transform;\n        const parentRef = this.parent;\n\n        this.parent = null;\n        this.transform = this._tempDisplayObjectParent.transform;\n\n        if (!rect)\n        {\n            if (!this._localBoundsRect)\n            {\n                this._localBoundsRect = new Rectangle();\n            }\n\n            rect = this._localBoundsRect;\n        }\n\n        const bounds = this.getBounds(false, rect);\n\n        this.parent = parentRef;\n        this.transform = transformRef;\n\n        return bounds;\n    }\n\n    /**\n     * Calculates the global position of the display object\n     *\n     * @param {PIXI.Point} position - The world origin to calculate from\n     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point)\n     * @param {boolean} [skipUpdate=false] - Should we skip the update transform.\n     * @return {PIXI.Point} A point object representing the position of this object\n     */\n    toGlobal(position, point, skipUpdate = false)\n    {\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // don't need to update the lot\n        return this.worldTransform.apply(position, point);\n    }\n\n    /**\n     * Calculates the local position of the display object relative to another point\n     *\n     * @param {PIXI.Point} position - The world origin to calculate from\n     * @param {PIXI.DisplayObject} [from] - The DisplayObject to calculate the global position from\n     * @param {PIXI.Point} [point] - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point)\n     * @param {boolean} [skipUpdate=false] - Should we skip the update transform\n     * @return {PIXI.Point} A point object representing the position of this object\n     */\n    toLocal(position, from, point, skipUpdate)\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this._recursivePostUpdateTransform();\n\n            // this parent check is for just in case the item is a root object.\n            // If it is we need to give it a temporary parent so that displayObjectUpdateTransform works correctly\n            // this is mainly to avoid a parent check in the main loop. Every little helps for performance :)\n            if (!this.parent)\n            {\n                this.parent = this._tempDisplayObjectParent;\n                this.displayObjectUpdateTransform();\n                this.parent = null;\n            }\n            else\n            {\n                this.displayObjectUpdateTransform();\n            }\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse(position, point);\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    renderWebGL(renderer) // eslint-disable-line no-unused-vars\n    {\n        // OVERWRITE;\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    renderCanvas(renderer) // eslint-disable-line no-unused-vars\n    {\n        // OVERWRITE;\n    }\n\n    /**\n     * Set the parent Container of this DisplayObject\n     *\n     * @param {PIXI.Container} container - The Container to add this DisplayObject to\n     * @return {PIXI.Container} The Container that this DisplayObject was added to\n     */\n    setParent(container)\n    {\n        if (!container || !container.addChild)\n        {\n            throw new Error('setParent: Argument must be a Container');\n        }\n\n        container.addChild(this);\n\n        return container;\n    }\n\n    /**\n     * Convenience function to set the position, scale, skew and pivot at once.\n     *\n     * @param {number} [x=0] - The X position\n     * @param {number} [y=0] - The Y position\n     * @param {number} [scaleX=1] - The X scale value\n     * @param {number} [scaleY=1] - The Y scale value\n     * @param {number} [rotation=0] - The rotation\n     * @param {number} [skewX=0] - The X skew value\n     * @param {number} [skewY=0] - The Y skew value\n     * @param {number} [pivotX=0] - The X pivot value\n     * @param {number} [pivotY=0] - The Y pivot value\n     * @return {PIXI.DisplayObject} The DisplayObject instance\n     */\n    setTransform(x = 0, y = 0, scaleX = 1, scaleY = 1, rotation = 0, skewX = 0, skewY = 0, pivotX = 0, pivotY = 0)\n    {\n        this.position.x = x;\n        this.position.y = y;\n        this.scale.x = !scaleX ? 1 : scaleX;\n        this.scale.y = !scaleY ? 1 : scaleY;\n        this.rotation = rotation;\n        this.skew.x = skewX;\n        this.skew.y = skewY;\n        this.pivot.x = pivotX;\n        this.pivot.y = pivotY;\n\n        return this;\n    }\n\n    /**\n     * Base destroy method for generic display objects. This will automatically\n     * remove the display object from its parent Container as well as remove\n     * all current event listeners and internal references. Do not use a DisplayObject\n     * after calling `destroy`.\n     *\n     */\n    destroy()\n    {\n        this.removeAllListeners();\n        if (this.parent)\n        {\n            this.parent.removeChild(this);\n        }\n        this.transform = null;\n\n        this.parent = null;\n\n        this._bounds = null;\n        this._currentBounds = null;\n        this._mask = null;\n\n        this.filterArea = null;\n\n        this.interactive = false;\n        this.interactiveChildren = false;\n\n        this._destroyed = true;\n    }\n\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     * An alias to position.x\n     *\n     * @member {number}\n     */\n    get x()\n    {\n        return this.position.x;\n    }\n\n    set x(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.position.x = value;\n    }\n\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     * An alias to position.y\n     *\n     * @member {number}\n     */\n    get y()\n    {\n        return this.position.y;\n    }\n\n    set y(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.position.y = value;\n    }\n\n    /**\n     * Current transform of the object based on world (parent) factors\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n    get worldTransform()\n    {\n        return this.transform.worldTransform;\n    }\n\n    /**\n     * Current transform of the object based on local factors: position, scale, other stuff\n     *\n     * @member {PIXI.Matrix}\n     * @readonly\n     */\n    get localTransform()\n    {\n        return this.transform.localTransform;\n    }\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.Point|PIXI.ObservablePoint}\n     */\n    get position()\n    {\n        return this.transform.position;\n    }\n\n    set position(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.position.copy(value);\n    }\n\n    /**\n     * The scale factor of the object.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.Point|PIXI.ObservablePoint}\n     */\n    get scale()\n    {\n        return this.transform.scale;\n    }\n\n    set scale(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.scale.copy(value);\n    }\n\n    /**\n     * The pivot point of the displayObject that it rotates around.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.Point|PIXI.ObservablePoint}\n     */\n    get pivot()\n    {\n        return this.transform.pivot;\n    }\n\n    set pivot(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.pivot.copy(value);\n    }\n\n    /**\n     * The skew factor for the object in radians.\n     * Assignment by value since pixi-v4.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get skew()\n    {\n        return this.transform.skew;\n    }\n\n    set skew(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.skew.copy(value);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     *\n     * @member {number}\n     */\n    get rotation()\n    {\n        return this.transform.rotation;\n    }\n\n    set rotation(value) // eslint-disable-line require-jsdoc\n    {\n        this.transform.rotation = value;\n    }\n\n    /**\n     * Indicates if the object is globally visible.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    get worldVisible()\n    {\n        let item = this;\n\n        do\n        {\n            if (!item.visible)\n            {\n                return false;\n            }\n\n            item = item.parent;\n        } while (item);\n\n        return true;\n    }\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an\n     * object to the shape of the mask applied to it. In PIXI a regular mask must be a\n     * PIXI.Graphics or a PIXI.Sprite object. This allows for much faster masking in canvas as it\n     * utilises shape clipping. To remove a mask, set this property to null.\n     *\n     * @todo For the moment, PIXI.CanvasRenderer doesn't support PIXI.Sprite as mask.\n     *\n     * @member {PIXI.Graphics|PIXI.Sprite}\n     */\n    get mask()\n    {\n        return this._mask;\n    }\n\n    set mask(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._mask)\n        {\n            this._mask.renderable = true;\n            this._mask.isMask = false;\n        }\n\n        this._mask = value;\n\n        if (this._mask)\n        {\n            this._mask.renderable = false;\n            this._mask.isMask = true;\n        }\n    }\n\n    /**\n     * Sets the filters for the displayObject.\n     * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to 'null'\n     *\n     * @member {PIXI.Filter[]}\n     */\n    get filters()\n    {\n        return this._filters && this._filters.slice();\n    }\n\n    set filters(value) // eslint-disable-line require-jsdoc\n    {\n        this._filters = value && value.slice();\n    }\n}\n\n// performance increase to avoid using call.. (10x faster)\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n"]},"metadata":{},"sourceType":"script"}