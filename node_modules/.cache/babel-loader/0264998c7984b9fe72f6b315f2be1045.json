{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _Point = require('../Point');\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _const = require('../../const');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * @class\n * @memberof PIXI\n */\n\n\nvar Polygon = function () {\n  /**\n   * @param {PIXI.Point[]|number[]} points - This can be an array of Points\n   *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n   *  the arguments passed can be all the points of the polygon e.g.\n   *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat\n   *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n   */\n  function Polygon() {\n    for (var _len = arguments.length, points = Array(_len), _key = 0; _key < _len; _key++) {\n      points[_key] = arguments[_key];\n    }\n\n    _classCallCheck(this, Polygon);\n\n    if (Array.isArray(points[0])) {\n      points = points[0];\n    } // if this is an array of points, convert it to a flat array of numbers\n\n\n    if (points[0] instanceof _Point2.default) {\n      var p = [];\n\n      for (var i = 0, il = points.length; i < il; i++) {\n        p.push(points[i].x, points[i].y);\n      }\n\n      points = p;\n    }\n\n    this.closed = true;\n    /**\n     * An array of the points of this polygon\n     *\n     * @member {number[]}\n     */\n\n    this.points = points;\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     *\n     * @member {number}\n     * @readOnly\n     * @default PIXI.SHAPES.POLY\n     * @see PIXI.SHAPES\n     */\n\n    this.type = _const.SHAPES.POLY;\n  }\n  /**\n   * Creates a clone of this polygon\n   *\n   * @return {PIXI.Polygon} a copy of the polygon\n   */\n\n\n  Polygon.prototype.clone = function clone() {\n    return new Polygon(this.points.slice());\n  };\n  /**\n   * Closes the polygon, adding points if necessary.\n   *\n   */\n\n\n  Polygon.prototype.close = function close() {\n    var points = this.points; // close the poly if the value is true!\n\n    if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1]) {\n      points.push(points[0], points[1]);\n    }\n  };\n  /**\n   * Checks whether the x and y coordinates passed to this function are contained within this polygon\n   *\n   * @param {number} x - The X coordinate of the point to test\n   * @param {number} y - The Y coordinate of the point to test\n   * @return {boolean} Whether the x/y coordinates are within this polygon\n   */\n\n\n  Polygon.prototype.contains = function contains(x, y) {\n    var inside = false; // use some raycasting to test hits\n    // https://github.com/substack/point-in-polygon/blob/master/index.js\n\n    var length = this.points.length / 2;\n\n    for (var i = 0, j = length - 1; i < length; j = i++) {\n      var xi = this.points[i * 2];\n      var yi = this.points[i * 2 + 1];\n      var xj = this.points[j * 2];\n      var yj = this.points[j * 2 + 1];\n      var intersect = yi > y !== yj > y && x < (xj - xi) * ((y - yi) / (yj - yi)) + xi;\n\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n\n    return inside;\n  };\n\n  return Polygon;\n}();\n\nexports.default = Polygon;","map":{"version":3,"sources":["../../../../src/core/math/shapes/Polygon.js"],"names":["Polygon","points","Array","p","i","il","clone","close","contains","x","y","inside","length","j","xi","yi","xj","yj","intersect"],"mappings":"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","sourcesContent":["import Point from '../Point';\nimport { SHAPES } from '../../const';\n\n/**\n * @class\n * @memberof PIXI\n */\nexport default class Polygon\n{\n    /**\n     * @param {PIXI.Point[]|number[]} points - This can be an array of Points\n     *  that form the polygon, a flat array of numbers that will be interpreted as [x,y, x,y, ...], or\n     *  the arguments passed can be all the points of the polygon e.g.\n     *  `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the arguments passed can be flat\n     *  x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are Numbers.\n     */\n    constructor(...points)\n    {\n        if (Array.isArray(points[0]))\n        {\n            points = points[0];\n        }\n\n        // if this is an array of points, convert it to a flat array of numbers\n        if (points[0] instanceof Point)\n        {\n            const p = [];\n\n            for (let i = 0, il = points.length; i < il; i++)\n            {\n                p.push(points[i].x, points[i].y);\n            }\n\n            points = p;\n        }\n\n        this.closed = true;\n\n        /**\n         * An array of the points of this polygon\n         *\n         * @member {number[]}\n         */\n        this.points = points;\n\n        /**\n         * The type of the object, mainly used to avoid `instanceof` checks\n         *\n         * @member {number}\n         * @readOnly\n         * @default PIXI.SHAPES.POLY\n         * @see PIXI.SHAPES\n         */\n        this.type = SHAPES.POLY;\n    }\n\n    /**\n     * Creates a clone of this polygon\n     *\n     * @return {PIXI.Polygon} a copy of the polygon\n     */\n    clone()\n    {\n        return new Polygon(this.points.slice());\n    }\n\n    /**\n     * Closes the polygon, adding points if necessary.\n     *\n     */\n    close()\n    {\n        const points = this.points;\n\n        // close the poly if the value is true!\n        if (points[0] !== points[points.length - 2] || points[1] !== points[points.length - 1])\n        {\n            points.push(points[0], points[1]);\n        }\n    }\n\n    /**\n     * Checks whether the x and y coordinates passed to this function are contained within this polygon\n     *\n     * @param {number} x - The X coordinate of the point to test\n     * @param {number} y - The Y coordinate of the point to test\n     * @return {boolean} Whether the x/y coordinates are within this polygon\n     */\n    contains(x, y)\n    {\n        let inside = false;\n\n        // use some raycasting to test hits\n        // https://github.com/substack/point-in-polygon/blob/master/index.js\n        const length = this.points.length / 2;\n\n        for (let i = 0, j = length - 1; i < length; j = i++)\n        {\n            const xi = this.points[i * 2];\n            const yi = this.points[(i * 2) + 1];\n            const xj = this.points[j * 2];\n            const yj = this.points[(j * 2) + 1];\n            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * ((y - yi) / (yj - yi))) + xi);\n\n            if (intersect)\n            {\n                inside = !inside;\n            }\n        }\n\n        return inside;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}