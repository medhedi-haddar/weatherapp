{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _core = require('../../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _pixiGlCore = require('pixi-gl-core');\n\nvar _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);\n\nvar _Mesh = require('../Mesh');\n\nvar _Mesh2 = _interopRequireDefault(_Mesh);\n\nvar _path = require('path');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar matrixIdentity = core.Matrix.IDENTITY;\n/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\n\nvar MeshRenderer = function (_core$ObjectRenderer) {\n  _inherits(MeshRenderer, _core$ObjectRenderer);\n  /**\n   * constructor for renderer\n   *\n   * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.\n   */\n\n\n  function MeshRenderer(renderer) {\n    _classCallCheck(this, MeshRenderer);\n\n    var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));\n\n    _this.shader = null;\n    return _this;\n  }\n  /**\n   * Sets up the renderer context and necessary buffers.\n   *\n   * @private\n   */\n\n\n  MeshRenderer.prototype.onContextChange = function onContextChange() {\n    var gl = this.renderer.gl;\n    this.shader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n', 'varying vec2 vTextureCoord;\\nuniform vec4 uColor;\\n\\nuniform sampler2D uSampler;\\n\\nvoid main(void)\\n{\\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\\n}\\n');\n  };\n  /**\n   * renders mesh\n   *\n   * @param {PIXI.mesh.Mesh} mesh mesh instance\n   */\n\n\n  MeshRenderer.prototype.render = function render(mesh) {\n    var renderer = this.renderer;\n    var gl = renderer.gl;\n    var texture = mesh._texture;\n\n    if (!texture.valid) {\n      return;\n    }\n\n    var glData = mesh._glDatas[renderer.CONTEXT_UID];\n\n    if (!glData) {\n      renderer.bindVao(null);\n      glData = {\n        shader: this.shader,\n        vertexBuffer: _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),\n        uvBuffer: _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, mesh.uvs, gl.STREAM_DRAW),\n        indexBuffer: _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),\n        // build the vao object that will render..\n        vao: null,\n        dirty: mesh.dirty,\n        indexDirty: mesh.indexDirty,\n        vertexDirty: mesh.vertexDirty\n      }; // build the vao object that will render..\n\n      glData.vao = new _pixiGlCore2.default.VertexArrayObject(gl).addIndex(glData.indexBuffer).addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0).addAttribute(glData.uvBuffer, glData.shader.attributes.aTextureCoord, gl.FLOAT, false, 2 * 4, 0);\n      mesh._glDatas[renderer.CONTEXT_UID] = glData;\n    }\n\n    renderer.bindVao(glData.vao);\n\n    if (mesh.dirty !== glData.dirty) {\n      glData.dirty = mesh.dirty;\n      glData.uvBuffer.upload(mesh.uvs);\n    }\n\n    if (mesh.indexDirty !== glData.indexDirty) {\n      glData.indexDirty = mesh.indexDirty;\n      glData.indexBuffer.upload(mesh.indices);\n    }\n\n    if (mesh.vertexDirty !== glData.vertexDirty) {\n      glData.vertexDirty = mesh.vertexDirty;\n      glData.vertexBuffer.upload(mesh.vertices);\n    }\n\n    renderer.bindShader(glData.shader);\n    glData.shader.uniforms.uSampler = renderer.bindTexture(texture);\n    renderer.state.setBlendMode(core.utils.correctBlendMode(mesh.blendMode, texture.baseTexture.premultipliedAlpha));\n\n    if (glData.shader.uniforms.uTransform) {\n      if (mesh.uploadUvTransform) {\n        glData.shader.uniforms.uTransform = mesh._uvTransform.mapCoord.toArray(true);\n      } else {\n        glData.shader.uniforms.uTransform = matrixIdentity.toArray(true);\n      }\n    }\n\n    glData.shader.uniforms.translationMatrix = mesh.worldTransform.toArray(true);\n    glData.shader.uniforms.uColor = core.utils.premultiplyRgba(mesh.tintRgb, mesh.worldAlpha, glData.shader.uniforms.uColor, texture.baseTexture.premultipliedAlpha);\n    var drawMode = mesh.drawMode === _Mesh2.default.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;\n    glData.vao.draw(drawMode, mesh.indices.length, 0);\n  };\n\n  return MeshRenderer;\n}(core.ObjectRenderer);\n\nexports.default = MeshRenderer;\ncore.WebGLRenderer.registerPlugin('mesh', MeshRenderer);","map":{"version":3,"sources":["../../../src/mesh/webgl/MeshRenderer.js"],"names":["core","matrixIdentity","MeshRenderer","ObjectRenderer","onContextChange","gl","render","mesh","renderer","texture","glData","shader","vertexBuffer","uvBuffer","indexBuffer","vao","dirty","indexDirty","vertexDirty","drawMode"],"mappings":";;;;AAAA,IAAA,KAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;IAAYA,I;;AACZ,IAAA,WAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;;;AAEA,IAAA,KAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAMC,cAAAA,GAAiBD,IAAAA,CAAAA,MAAAA,CAAvB,QAAA;AAEA;;;;;;;;IAOqBE,Y;;AAGjB;;;;;;;AAKA,WAAA,YAAA,CAAA,QAAA,EACA;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,YAAA,CAAA;;AAAA,QAAA,KAAA,GAAA,0BAAA,CAAA,IAAA,EACI,oBAAA,CAAA,IAAA,CAAA,IAAA,EADJ,QACI,CADJ,CAAA;;AAGI,IAAA,KAAA,CAAA,MAAA,GAAA,IAAA;AAHJ,WAAA,KAAA;AAIC;AAED;;;;;;;yBAKAE,e,8BACA;AACI,QAAMC,EAAAA,GAAK,KAAA,QAAA,CAAX,EAAA;AAEA,SAAA,MAAA,GAAc,IAAIL,IAAAA,CAAJ,MAAA,CAAA,EAAA,EAAA,qYAAA,EAAd,8KAAc,CAAd;;AAKJ;;;;;;;yBAKAM,M,mBAAOC,I,EACP;AACI,QAAMC,QAAAA,GAAW,KAAjB,QAAA;AACA,QAAMH,EAAAA,GAAKG,QAAAA,CAAX,EAAA;AACA,QAAMC,OAAAA,GAAUF,IAAAA,CAAhB,QAAA;;AAEA,QAAI,CAACE,OAAAA,CAAL,KAAA,EACA;AACI;AACH;;AAED,QAAIC,MAAAA,GAASH,IAAAA,CAAAA,QAAAA,CAAcC,QAAAA,CAA3B,WAAaD,CAAb;;AAEA,QAAI,CAAJ,MAAA,EACA;AACIC,MAAAA,QAAAA,CAAAA,OAAAA,CAAAA,IAAAA;AAEAE,MAAAA,MAAAA,GAAS;AACLC,QAAAA,MAAAA,EAAQ,KADH,MAAA;AAELC,QAAAA,YAAAA,EAAc,YAAA,CAAA,OAAA,CAAA,QAAA,CAAA,kBAAA,CAAA,EAAA,EAAuCL,IAAAA,CAAvC,QAAA,EAAsDF,EAAAA,CAF/D,WAES,CAFT;AAGLQ,QAAAA,QAAAA,EAAU,YAAA,CAAA,OAAA,CAAA,QAAA,CAAA,kBAAA,CAAA,EAAA,EAAuCN,IAAAA,CAAvC,GAAA,EAAiDF,EAAAA,CAHtD,WAGK,CAHL;AAILS,QAAAA,WAAAA,EAAa,YAAA,CAAA,OAAA,CAAA,QAAA,CAAA,iBAAA,CAAA,EAAA,EAAsCP,IAAAA,CAAtC,OAAA,EAAoDF,EAAAA,CAJ5D,WAIQ,CAJR;AAKL;AACAU,QAAAA,GAAAA,EANK,IAAA;AAOLC,QAAAA,KAAAA,EAAOT,IAAAA,CAPF,KAAA;AAQLU,QAAAA,UAAAA,EAAYV,IAAAA,CARP,UAAA;AASLW,QAAAA,WAAAA,EAAaX,IAAAA,CAAKW;AATb,OAATR,CAHJ,CAeI;;AACAA,MAAAA,MAAAA,CAAAA,GAAAA,GAAa,IAAI,YAAA,CAAA,OAAA,CAAJ,iBAAA,CAAA,EAAA,EAAA,QAAA,CACCA,MAAAA,CADD,WAAA,EAAA,YAAA,CAEKA,MAAAA,CAFL,YAAA,EAE0BA,MAAAA,CAAAA,MAAAA,CAAAA,UAAAA,CAF1B,eAAA,EAEoEL,EAAAA,CAFpE,KAAA,EAAA,KAAA,EAEqF,IAFrF,CAAA,EAAA,CAAA,EAAA,YAAA,CAGKK,MAAAA,CAHL,QAAA,EAGsBA,MAAAA,CAAAA,MAAAA,CAAAA,UAAAA,CAHtB,aAAA,EAG8DL,EAAAA,CAH9D,KAAA,EAAA,KAAA,EAG+E,IAH/E,CAAA,EAAbK,CAAa,CAAbA;AAKAH,MAAAA,IAAAA,CAAAA,QAAAA,CAAcC,QAAAA,CAAdD,WAAAA,IAAAA,MAAAA;AACH;;AAEDC,IAAAA,QAAAA,CAAAA,OAAAA,CAAiBE,MAAAA,CAAjBF,GAAAA;;AAEA,QAAID,IAAAA,CAAAA,KAAAA,KAAeG,MAAAA,CAAnB,KAAA,EACA;AACIA,MAAAA,MAAAA,CAAAA,KAAAA,GAAeH,IAAAA,CAAfG,KAAAA;AACAA,MAAAA,MAAAA,CAAAA,QAAAA,CAAAA,MAAAA,CAAuBH,IAAAA,CAAvBG,GAAAA;AACH;;AAED,QAAIH,IAAAA,CAAAA,UAAAA,KAAoBG,MAAAA,CAAxB,UAAA,EACA;AACIA,MAAAA,MAAAA,CAAAA,UAAAA,GAAoBH,IAAAA,CAApBG,UAAAA;AACAA,MAAAA,MAAAA,CAAAA,WAAAA,CAAAA,MAAAA,CAA0BH,IAAAA,CAA1BG,OAAAA;AACH;;AAED,QAAIH,IAAAA,CAAAA,WAAAA,KAAqBG,MAAAA,CAAzB,WAAA,EACA;AACIA,MAAAA,MAAAA,CAAAA,WAAAA,GAAqBH,IAAAA,CAArBG,WAAAA;AACAA,MAAAA,MAAAA,CAAAA,YAAAA,CAAAA,MAAAA,CAA2BH,IAAAA,CAA3BG,QAAAA;AACH;;AAEDF,IAAAA,QAAAA,CAAAA,UAAAA,CAAoBE,MAAAA,CAApBF,MAAAA;AAEAE,IAAAA,MAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,QAAAA,GAAkCF,QAAAA,CAAAA,WAAAA,CAAlCE,OAAkCF,CAAlCE;AAEAF,IAAAA,QAAAA,CAAAA,KAAAA,CAAAA,YAAAA,CAA4BR,IAAAA,CAAAA,KAAAA,CAAAA,gBAAAA,CAA4BO,IAAAA,CAA5BP,SAAAA,EAA4CS,OAAAA,CAAAA,WAAAA,CAAxED,kBAA4BR,CAA5BQ;;AAEA,QAAIE,MAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAJ,UAAA,EACA;AACI,UAAIH,IAAAA,CAAJ,iBAAA,EACA;AACIG,QAAAA,MAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,UAAAA,GAAoCH,IAAAA,CAAAA,YAAAA,CAAAA,QAAAA,CAAAA,OAAAA,CAApCG,IAAoCH,CAApCG;AAFJ,OAAA,MAKA;AACIA,QAAAA,MAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,UAAAA,GAAoCT,cAAAA,CAAAA,OAAAA,CAApCS,IAAoCT,CAApCS;AACH;AACJ;;AACDA,IAAAA,MAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,iBAAAA,GAA2CH,IAAAA,CAAAA,cAAAA,CAAAA,OAAAA,CAA3CG,IAA2CH,CAA3CG;AAEAA,IAAAA,MAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CAAAA,MAAAA,GAAgCV,IAAAA,CAAAA,KAAAA,CAAAA,eAAAA,CAA2BO,IAAAA,CAA3BP,OAAAA,EAC5BO,IAAAA,CAD4BP,UAAAA,EACXU,MAAAA,CAAAA,MAAAA,CAAAA,QAAAA,CADWV,MAAAA,EACoBS,OAAAA,CAAAA,WAAAA,CADpDC,kBAAgCV,CAAhCU;AAGA,QAAMS,QAAAA,GAAWZ,IAAAA,CAAAA,QAAAA,KAAkB,MAAA,CAAA,OAAA,CAAA,UAAA,CAAlBA,aAAAA,GAAkDF,EAAAA,CAAlDE,cAAAA,GAAsEF,EAAAA,CAAvF,SAAA;AAEAK,IAAAA,MAAAA,CAAAA,GAAAA,CAAAA,IAAAA,CAAAA,QAAAA,EAA0BH,IAAAA,CAAAA,OAAAA,CAA1BG,MAAAA,EAAAA,CAAAA;;;;EApHkCV,IAAAA,CAAKG,c;;kBAA1BD,Y;AAwHrBF,IAAAA,CAAAA,aAAAA,CAAAA,cAAAA,CAAAA,MAAAA,EAAAA,YAAAA","sourcesContent":["import * as core from '../../core';\nimport glCore from 'pixi-gl-core';\nimport { default as Mesh } from '../Mesh';\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\n\nconst matrixIdentity = core.Matrix.IDENTITY;\n\n/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport default class MeshRenderer extends core.ObjectRenderer\n{\n\n    /**\n     * constructor for renderer\n     *\n     * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.shader = null;\n    }\n\n    /**\n     * Sets up the renderer context and necessary buffers.\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        this.shader = new core.Shader(gl,\n            readFileSync(join(__dirname, './mesh.vert'), 'utf8'),\n            readFileSync(join(__dirname, './mesh.frag'), 'utf8'));\n    }\n\n    /**\n     * renders mesh\n     *\n     * @param {PIXI.mesh.Mesh} mesh mesh instance\n     */\n    render(mesh)\n    {\n        const renderer = this.renderer;\n        const gl = renderer.gl;\n        const texture = mesh._texture;\n\n        if (!texture.valid)\n        {\n            return;\n        }\n\n        let glData = mesh._glDatas[renderer.CONTEXT_UID];\n\n        if (!glData)\n        {\n            renderer.bindVao(null);\n\n            glData = {\n                shader: this.shader,\n                vertexBuffer: glCore.GLBuffer.createVertexBuffer(gl, mesh.vertices, gl.STREAM_DRAW),\n                uvBuffer: glCore.GLBuffer.createVertexBuffer(gl, mesh.uvs, gl.STREAM_DRAW),\n                indexBuffer: glCore.GLBuffer.createIndexBuffer(gl, mesh.indices, gl.STATIC_DRAW),\n                // build the vao object that will render..\n                vao: null,\n                dirty: mesh.dirty,\n                indexDirty: mesh.indexDirty,\n                vertexDirty: mesh.vertexDirty,\n            };\n\n            // build the vao object that will render..\n            glData.vao = new glCore.VertexArrayObject(gl)\n                .addIndex(glData.indexBuffer)\n                .addAttribute(glData.vertexBuffer, glData.shader.attributes.aVertexPosition, gl.FLOAT, false, 2 * 4, 0)\n                .addAttribute(glData.uvBuffer, glData.shader.attributes.aTextureCoord, gl.FLOAT, false, 2 * 4, 0);\n\n            mesh._glDatas[renderer.CONTEXT_UID] = glData;\n        }\n\n        renderer.bindVao(glData.vao);\n\n        if (mesh.dirty !== glData.dirty)\n        {\n            glData.dirty = mesh.dirty;\n            glData.uvBuffer.upload(mesh.uvs);\n        }\n\n        if (mesh.indexDirty !== glData.indexDirty)\n        {\n            glData.indexDirty = mesh.indexDirty;\n            glData.indexBuffer.upload(mesh.indices);\n        }\n\n        if (mesh.vertexDirty !== glData.vertexDirty)\n        {\n            glData.vertexDirty = mesh.vertexDirty;\n            glData.vertexBuffer.upload(mesh.vertices);\n        }\n\n        renderer.bindShader(glData.shader);\n\n        glData.shader.uniforms.uSampler = renderer.bindTexture(texture);\n\n        renderer.state.setBlendMode(core.utils.correctBlendMode(mesh.blendMode, texture.baseTexture.premultipliedAlpha));\n\n        if (glData.shader.uniforms.uTransform)\n        {\n            if (mesh.uploadUvTransform)\n            {\n                glData.shader.uniforms.uTransform = mesh._uvTransform.mapCoord.toArray(true);\n            }\n            else\n            {\n                glData.shader.uniforms.uTransform = matrixIdentity.toArray(true);\n            }\n        }\n        glData.shader.uniforms.translationMatrix = mesh.worldTransform.toArray(true);\n\n        glData.shader.uniforms.uColor = core.utils.premultiplyRgba(mesh.tintRgb,\n            mesh.worldAlpha, glData.shader.uniforms.uColor, texture.baseTexture.premultipliedAlpha);\n\n        const drawMode = mesh.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH ? gl.TRIANGLE_STRIP : gl.TRIANGLES;\n\n        glData.vao.draw(drawMode, mesh.indices.length, 0);\n    }\n}\n\ncore.WebGLRenderer.registerPlugin('mesh', MeshRenderer);\n"]},"metadata":{},"sourceType":"script"}