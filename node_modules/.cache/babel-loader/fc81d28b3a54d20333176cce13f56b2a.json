{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.encodeBinary = encodeBinary;\nvar _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n/**\n * Encodes binary into base64.\n *\n * @param {string} input The input data to encode.\n * @returns {string} The encoded base64 string\n */\n\nfunction encodeBinary(input) {\n  var output = '';\n  var inx = 0;\n\n  while (inx < input.length) {\n    // Fill byte buffer array\n    var bytebuffer = [0, 0, 0];\n    var encodedCharIndexes = [0, 0, 0, 0];\n\n    for (var jnx = 0; jnx < bytebuffer.length; ++jnx) {\n      if (inx < input.length) {\n        // throw away high-order byte, as documented at:\n        // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n        bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n      } else {\n        bytebuffer[jnx] = 0;\n      }\n    } // Get each encoded character, 6 bits at a time\n    // index 1: first 6 bits\n\n\n    encodedCharIndexes[0] = bytebuffer[0] >> 2; // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n\n    encodedCharIndexes[1] = (bytebuffer[0] & 0x3) << 4 | bytebuffer[1] >> 4; // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n\n    encodedCharIndexes[2] = (bytebuffer[1] & 0x0f) << 2 | bytebuffer[2] >> 6; // index 3: forth 6 bits (6 least significant bits from input byte 3)\n\n    encodedCharIndexes[3] = bytebuffer[2] & 0x3f; // Determine whether padding happened, and adjust accordingly\n\n    var paddingBytes = inx - (input.length - 1);\n\n    switch (paddingBytes) {\n      case 2:\n        // Set last 2 characters to padding char\n        encodedCharIndexes[3] = 64;\n        encodedCharIndexes[2] = 64;\n        break;\n\n      case 1:\n        // Set last character to padding char\n        encodedCharIndexes[3] = 64;\n        break;\n\n      default:\n        break;\n      // No padding - proceed\n    } // Now we will grab each appropriate character out of our keystring\n    // based on our index array and append it to the output string\n\n\n    for (var _jnx = 0; _jnx < encodedCharIndexes.length; ++_jnx) {\n      output += _keyStr.charAt(encodedCharIndexes[_jnx]);\n    }\n  }\n\n  return output;\n} // Backwards compat\n\n\nif (typeof module !== 'undefined') {\n  module.exports.default = encodeBinary; // eslint-disable-line no-undef\n}","map":{"version":3,"sources":["../src/b64.js"],"names":["_keyStr","encodeBinary","output","inx","input","bytebuffer","encodedCharIndexes","jnx","paddingBytes","module"],"mappings":";;;QAQgBC,Y,GAAAA,Y;AARhB,IAAMD,OAAAA,GAAN,mEAAA;AAEA;;;;;;;AAMO,SAAA,YAAA,CAAA,KAAA,EAA6B;AAChC,MAAIE,MAAAA,GAAJ,EAAA;AACA,MAAIC,GAAAA,GAAJ,CAAA;;AAEA,SAAOA,GAAAA,GAAMC,KAAAA,CAAb,MAAA,EAA2B;AACvB;AACA,QAAMC,UAAAA,GAAa,CAAA,CAAA,EAAA,CAAA,EAAnB,CAAmB,CAAnB;AACA,QAAMC,kBAAAA,GAAqB,CAAA,CAAA,EAAA,CAAA,EAAA,CAAA,EAA3B,CAA2B,CAA3B;;AAEA,SAAK,IAAIC,GAAAA,GAAT,CAAA,EAAkBA,GAAAA,GAAMF,UAAAA,CAAxB,MAAA,EAA2C,EAA3C,GAAA,EAAkD;AAC9C,UAAIF,GAAAA,GAAMC,KAAAA,CAAV,MAAA,EAAwB;AACpB;AACA;AACAC,QAAAA,UAAAA,CAAAA,GAAAA,CAAAA,GAAkBD,KAAAA,CAAAA,UAAAA,CAAiBD,GAAjBC,EAAAA,IAAlBC,IAAAA;AAHJ,OAAA,MAKK;AACDA,QAAAA,UAAAA,CAAAA,GAAAA,CAAAA,GAAAA,CAAAA;AACH;AACJ,KAdsB,CAgBvB;AACA;;;AACAC,IAAAA,kBAAAA,CAAAA,CAAAA,CAAAA,GAAwBD,UAAAA,CAAAA,CAAAA,CAAAA,IAAxBC,CAAAA,CAlBuB,CAoBvB;;AACAA,IAAAA,kBAAAA,CAAAA,CAAAA,CAAAA,GAAyB,CAACD,UAAAA,CAAAA,CAAAA,CAAAA,GAAD,GAAA,KAAD,CAAC,GAA+BA,UAAAA,CAAAA,CAAAA,CAAAA,IAAxDC,CAAAA,CArBuB,CAuBvB;;AACAA,IAAAA,kBAAAA,CAAAA,CAAAA,CAAAA,GAAyB,CAACD,UAAAA,CAAAA,CAAAA,CAAAA,GAAD,IAAA,KAAD,CAAC,GAAgCA,UAAAA,CAAAA,CAAAA,CAAAA,IAAzDC,CAAAA,CAxBuB,CA0BvB;;AACAA,IAAAA,kBAAAA,CAAAA,CAAAA,CAAAA,GAAwBD,UAAAA,CAAAA,CAAAA,CAAAA,GAAxBC,IAAAA,CA3BuB,CA6BvB;;AACA,QAAME,YAAAA,GAAeL,GAAAA,IAAOC,KAAAA,CAAAA,MAAAA,GAA5B,CAAqBD,CAArB;;AAEA,YAAA,YAAA;AACI,WAAA,CAAA;AACI;AACAG,QAAAA,kBAAAA,CAAAA,CAAAA,CAAAA,GAAAA,EAAAA;AACAA,QAAAA,kBAAAA,CAAAA,CAAAA,CAAAA,GAAAA,EAAAA;AACA;;AAEJ,WAAA,CAAA;AACI;AACAA,QAAAA,kBAAAA,CAAAA,CAAAA,CAAAA,GAAAA,EAAAA;AACA;;AAEJ;AAZJ;AAae;AAbf,KAhCuB,CAgDvB;AACA;;;AACA,SAAK,IAAIC,IAAAA,GAAT,CAAA,EAAkBA,IAAAA,GAAMD,kBAAAA,CAAxB,MAAA,EAAmD,EAAnD,IAAA,EAA0D;AACtDJ,MAAAA,MAAAA,IAAUF,OAAAA,CAAAA,MAAAA,CAAeM,kBAAAA,CAAzBJ,IAAyBI,CAAfN,CAAVE;AACH;AACJ;;AAED,SAAA,MAAA;AACH,C,CAED;;;AACA,IAAI,OAAA,MAAA,KAAJ,WAAA,EAAmC;AAC/BO,EAAAA,MAAAA,CAAAA,OAAAA,CAAAA,OAAAA,GAD+B,YAC/BA,CAD+B,CACQ;AAC1C","sourcesContent":["const _keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n/**\n * Encodes binary into base64.\n *\n * @param {string} input The input data to encode.\n * @returns {string} The encoded base64 string\n */\nexport function encodeBinary(input) {\n    let output = '';\n    let inx = 0;\n\n    while (inx < input.length) {\n        // Fill byte buffer array\n        const bytebuffer = [0, 0, 0];\n        const encodedCharIndexes = [0, 0, 0, 0];\n\n        for (let jnx = 0; jnx < bytebuffer.length; ++jnx) {\n            if (inx < input.length) {\n                // throw away high-order byte, as documented at:\n                // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n                bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n            }\n            else {\n                bytebuffer[jnx] = 0;\n            }\n        }\n\n        // Get each encoded character, 6 bits at a time\n        // index 1: first 6 bits\n        encodedCharIndexes[0] = bytebuffer[0] >> 2;\n\n        // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n        encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);\n\n        // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n        encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);\n\n        // index 3: forth 6 bits (6 least significant bits from input byte 3)\n        encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n\n        // Determine whether padding happened, and adjust accordingly\n        const paddingBytes = inx - (input.length - 1);\n\n        switch (paddingBytes) {\n            case 2:\n                // Set last 2 characters to padding char\n                encodedCharIndexes[3] = 64;\n                encodedCharIndexes[2] = 64;\n                break;\n\n            case 1:\n                // Set last character to padding char\n                encodedCharIndexes[3] = 64;\n                break;\n\n            default:\n                break; // No padding - proceed\n        }\n\n        // Now we will grab each appropriate character out of our keystring\n        // based on our index array and append it to the output string\n        for (let jnx = 0; jnx < encodedCharIndexes.length; ++jnx) {\n            output += _keyStr.charAt(encodedCharIndexes[jnx]);\n        }\n    }\n\n    return output;\n}\n\n// Backwards compat\nif (typeof module !== 'undefined') {\n    module.exports.default = encodeBinary; // eslint-disable-line no-undef\n}\n"]},"metadata":{},"sourceType":"script"}