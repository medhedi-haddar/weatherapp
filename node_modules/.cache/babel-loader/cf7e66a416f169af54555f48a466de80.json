{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _Matrix = require('../math/Matrix');\n\nvar _Matrix2 = _interopRequireDefault(_Matrix);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar tempMat = new _Matrix2.default();\n/**\n * Class controls uv transform and frame clamp for texture\n * Can be used in Texture \"transform\" field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * @see PIXI.Texture\n * @see PIXI.mesh.Mesh\n * @see PIXI.extras.TilingSprite\n * @class\n * @memberof PIXI\n */\n\nvar TextureMatrix = function () {\n  /**\n   *\n   * @param {PIXI.Texture} texture observed texture\n   * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n   * @constructor\n   */\n  function TextureMatrix(texture, clampMargin) {\n    _classCallCheck(this, TextureMatrix);\n\n    this._texture = texture;\n    this.mapCoord = new _Matrix2.default();\n    this.uClampFrame = new Float32Array(4);\n    this.uClampOffset = new Float32Array(2);\n    this._lastTextureID = -1;\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n     *\n     * @default 0\n     * @member {number}\n     */\n\n    this.clampOffset = 0;\n    /**\n     * Changes frame clamping\n     * Works with TilingSprite and Mesh\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     *\n     * @default 0.5\n     * @member {number}\n     */\n\n    this.clampMargin = typeof clampMargin === 'undefined' ? 0.5 : clampMargin;\n  }\n  /**\n   * texture property\n   * @member {PIXI.Texture}\n   */\n\n  /**\n   * Multiplies uvs array to transform\n   * @param {Float32Array} uvs mesh uvs\n   * @param {Float32Array} [out=uvs] output\n   * @returns {Float32Array} output\n   */\n\n\n  TextureMatrix.prototype.multiplyUvs = function multiplyUvs(uvs, out) {\n    if (out === undefined) {\n      out = uvs;\n    }\n\n    var mat = this.mapCoord;\n\n    for (var i = 0; i < uvs.length; i += 2) {\n      var x = uvs[i];\n      var y = uvs[i + 1];\n      out[i] = x * mat.a + y * mat.c + mat.tx;\n      out[i + 1] = x * mat.b + y * mat.d + mat.ty;\n    }\n\n    return out;\n  };\n  /**\n   * updates matrices if texture was changed\n   * @param {boolean} forceUpdate if true, matrices will be updated any case\n   * @returns {boolean} whether or not it was updated\n   */\n\n\n  TextureMatrix.prototype.update = function update(forceUpdate) {\n    var tex = this._texture;\n\n    if (!tex || !tex.valid) {\n      return false;\n    }\n\n    if (!forceUpdate && this._lastTextureID === tex._updateID) {\n      return false;\n    }\n\n    this._lastTextureID = tex._updateID;\n    var uvs = tex._uvs;\n    this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n    var orig = tex.orig;\n    var trim = tex.trim;\n\n    if (trim) {\n      tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height, -trim.x / trim.width, -trim.y / trim.height);\n      this.mapCoord.append(tempMat);\n    }\n\n    var texBase = tex.baseTexture;\n    var frame = this.uClampFrame;\n    var margin = this.clampMargin / texBase.resolution;\n    var offset = this.clampOffset;\n    frame[0] = (tex._frame.x + margin + offset) / texBase.width;\n    frame[1] = (tex._frame.y + margin + offset) / texBase.height;\n    frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;\n    frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;\n    this.uClampOffset[0] = offset / texBase.realWidth;\n    this.uClampOffset[1] = offset / texBase.realHeight;\n    return true;\n  };\n\n  _createClass(TextureMatrix, [{\n    key: 'texture',\n    get: function get() {\n      return this._texture;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this._texture = value;\n      this._lastTextureID = -1;\n    }\n  }]);\n\n  return TextureMatrix;\n}();\n\nexports.default = TextureMatrix;","map":{"version":3,"sources":["../../../src/core/textures/TextureMatrix.js"],"names":["tempMat","TextureMatrix","value","multiplyUvs","uvs","out","mat","i","x","y","update","forceUpdate","tex","orig","trim","texBase","frame","margin","offset"],"mappings":"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","sourcesContent":["import { default as Matrix } from '../math/Matrix';\n\nconst tempMat = new Matrix();\n\n/**\n * Class controls uv transform and frame clamp for texture\n * Can be used in Texture \"transform\" field, or separately, you can use different clamp settings on the same texture.\n * If you want to add support for texture region of certain feature or filter, that's what you're looking for.\n *\n * @see PIXI.Texture\n * @see PIXI.mesh.Mesh\n * @see PIXI.extras.TilingSprite\n * @class\n * @memberof PIXI\n */\nexport default class TextureMatrix\n{\n    /**\n     *\n     * @param {PIXI.Texture} texture observed texture\n     * @param {number} [clampMargin] Changes frame clamping, 0.5 by default. Use -0.5 for extra border.\n     * @constructor\n     */\n    constructor(texture, clampMargin)\n    {\n        this._texture = texture;\n\n        this.mapCoord = new Matrix();\n\n        this.uClampFrame = new Float32Array(4);\n\n        this.uClampOffset = new Float32Array(2);\n\n        this._lastTextureID = -1;\n\n        /**\n         * Changes frame clamping\n         * Works with TilingSprite and Mesh\n         * Change to 1.5 if you texture has repeated right and bottom lines, that leads to smoother borders\n         *\n         * @default 0\n         * @member {number}\n         */\n        this.clampOffset = 0;\n\n        /**\n         * Changes frame clamping\n         * Works with TilingSprite and Mesh\n         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n         *\n         * @default 0.5\n         * @member {number}\n         */\n        this.clampMargin = (typeof clampMargin === 'undefined') ? 0.5 : clampMargin;\n    }\n\n    /**\n     * texture property\n     * @member {PIXI.Texture}\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    set texture(value) // eslint-disable-line require-jsdoc\n    {\n        this._texture = value;\n        this._lastTextureID = -1;\n    }\n\n    /**\n     * Multiplies uvs array to transform\n     * @param {Float32Array} uvs mesh uvs\n     * @param {Float32Array} [out=uvs] output\n     * @returns {Float32Array} output\n     */\n    multiplyUvs(uvs, out)\n    {\n        if (out === undefined)\n        {\n            out = uvs;\n        }\n\n        const mat = this.mapCoord;\n\n        for (let i = 0; i < uvs.length; i += 2)\n        {\n            const x = uvs[i];\n            const y = uvs[i + 1];\n\n            out[i] = (x * mat.a) + (y * mat.c) + mat.tx;\n            out[i + 1] = (x * mat.b) + (y * mat.d) + mat.ty;\n        }\n\n        return out;\n    }\n\n    /**\n     * updates matrices if texture was changed\n     * @param {boolean} forceUpdate if true, matrices will be updated any case\n     * @returns {boolean} whether or not it was updated\n     */\n    update(forceUpdate)\n    {\n        const tex = this._texture;\n\n        if (!tex || !tex.valid)\n        {\n            return false;\n        }\n\n        if (!forceUpdate\n            && this._lastTextureID === tex._updateID)\n        {\n            return false;\n        }\n\n        this._lastTextureID = tex._updateID;\n\n        const uvs = tex._uvs;\n\n        this.mapCoord.set(uvs.x1 - uvs.x0, uvs.y1 - uvs.y0, uvs.x3 - uvs.x0, uvs.y3 - uvs.y0, uvs.x0, uvs.y0);\n\n        const orig = tex.orig;\n        const trim = tex.trim;\n\n        if (trim)\n        {\n            tempMat.set(orig.width / trim.width, 0, 0, orig.height / trim.height,\n                -trim.x / trim.width, -trim.y / trim.height);\n            this.mapCoord.append(tempMat);\n        }\n\n        const texBase = tex.baseTexture;\n        const frame = this.uClampFrame;\n        const margin = this.clampMargin / texBase.resolution;\n        const offset = this.clampOffset;\n\n        frame[0] = (tex._frame.x + margin + offset) / texBase.width;\n        frame[1] = (tex._frame.y + margin + offset) / texBase.height;\n        frame[2] = (tex._frame.x + tex._frame.width - margin + offset) / texBase.width;\n        frame[3] = (tex._frame.y + tex._frame.height - margin + offset) / texBase.height;\n        this.uClampOffset[0] = offset / texBase.realWidth;\n        this.uClampOffset[1] = offset / texBase.realHeight;\n\n        return true;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}