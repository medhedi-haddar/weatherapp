{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _extractUniformsFromSrc = require('./extractUniformsFromSrc');\n\nvar _extractUniformsFromSrc2 = _interopRequireDefault(_extractUniformsFromSrc);\n\nvar _utils = require('../../../utils');\n\nvar _const = require('../../../const');\n\nvar _settings = require('../../../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar SOURCE_KEY_MAP = {}; // let math = require('../../../math');\n\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.Shader\n */\n\nvar Filter = function () {\n  /**\n   * @param {string} [vertexSrc] - The source of the vertex shader.\n   * @param {string} [fragmentSrc] - The source of the fragment shader.\n   * @param {object} [uniformData] - Custom uniforms to use to augment the built-in ones.\n   */\n  function Filter(vertexSrc, fragmentSrc, uniformData) {\n    _classCallCheck(this, Filter);\n    /**\n     * The vertex shader.\n     *\n     * @member {string}\n     */\n\n\n    this.vertexSrc = vertexSrc || Filter.defaultVertexSrc;\n    /**\n     * The fragment shader.\n     *\n     * @member {string}\n     */\n\n    this.fragmentSrc = fragmentSrc || Filter.defaultFragmentSrc;\n    this._blendMode = _const.BLEND_MODES.NORMAL;\n    this.uniformData = uniformData || (0, _extractUniformsFromSrc2.default)(this.vertexSrc, this.fragmentSrc, 'projectionMatrix|uSampler');\n    /**\n     * An object containing the current values of custom uniforms.\n     * @example <caption>Updating the value of a custom uniform</caption>\n     * filter.uniforms.time = performance.now();\n     *\n     * @member {object}\n     */\n\n    this.uniforms = {};\n\n    for (var i in this.uniformData) {\n      this.uniforms[i] = this.uniformData[i].value;\n\n      if (this.uniformData[i].type) {\n        this.uniformData[i].type = this.uniformData[i].type.toLowerCase();\n      }\n    } // this is where we store shader references..\n    // TODO we could cache this!\n\n\n    this.glShaders = {}; // used for caching.. sure there is a better way!\n\n    if (!SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc]) {\n      SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc] = (0, _utils.uid)();\n    }\n\n    this.glShaderKey = SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc];\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     *\n     * @member {number}\n     */\n\n    this.padding = 4;\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     *\n     * @member {number}\n     */\n\n    this.resolution = _settings2.default.FILTER_RESOLUTION;\n    /**\n     * If enabled is true the filter is applied, if false it will not.\n     *\n     * @member {boolean}\n     */\n\n    this.enabled = true;\n    /**\n     * If enabled, PixiJS will fit the filter area into boundaries for better performance.\n     * Switch it off if it does not work for specific shader.\n     *\n     * @member {boolean}\n     */\n\n    this.autoFit = true;\n  }\n  /**\n   * Applies the filter\n   *\n   * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from\n   * @param {PIXI.RenderTarget} input - The input render target.\n   * @param {PIXI.RenderTarget} output - The target to output to.\n   * @param {boolean} clear - Should the output be cleared before rendering to it\n   * @param {object} [currentState] - It's current state of filter.\n   *        There are some useful properties in the currentState :\n   *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution\n   */\n\n\n  Filter.prototype.apply = function apply(filterManager, input, output, clear, currentState) // eslint-disable-line no-unused-vars\n  {\n    // --- //\n    //  this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(tempMatrix, window.panda );\n    // do as you please!\n    filterManager.applyFilter(this, input, output, clear); // or just do a regular render..\n  };\n  /**\n   * Sets the blendmode of the filter\n   *\n   * @member {number}\n   * @default PIXI.BLEND_MODES.NORMAL\n   */\n\n\n  _createClass(Filter, [{\n    key: 'blendMode',\n    get: function get() {\n      return this._blendMode;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this._blendMode = value;\n    }\n    /**\n     * The default vertex shader source\n     *\n     * @static\n     * @constant\n     */\n\n  }], [{\n    key: 'defaultVertexSrc',\n    get: function get() {\n      return ['attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'uniform mat3 projectionMatrix;', 'uniform mat3 filterMatrix;', 'varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;', '   vTextureCoord = aTextureCoord ;', '}'].join('\\n');\n    }\n    /**\n     * The default fragment shader source\n     *\n     * @static\n     * @constant\n     */\n\n  }, {\n    key: 'defaultFragmentSrc',\n    get: function get() {\n      return ['varying vec2 vTextureCoord;', 'varying vec2 vFilterCoord;', 'uniform sampler2D uSampler;', 'uniform sampler2D filterSampler;', 'void main(void){', '   vec4 masky = texture2D(filterSampler, vFilterCoord);', '   vec4 sample = texture2D(uSampler, vTextureCoord);', '   vec4 color;', '   if(mod(vFilterCoord.x, 1.0) > 0.5)', '   {', '     color = vec4(1.0, 0.0, 0.0, 1.0);', '   }', '   else', '   {', '     color = vec4(0.0, 1.0, 0.0, 1.0);', '   }', // '   gl_FragColor = vec4(mod(vFilterCoord.x, 1.5), vFilterCoord.y,0.0,1.0);',\n      '   gl_FragColor = mix(sample, masky, 0.5);', '   gl_FragColor *= sample.a;', '}'].join('\\n');\n    }\n  }]);\n\n  return Filter;\n}();\n\nexports.default = Filter;","map":{"version":3,"sources":["../../../../../src/core/renderers/webgl/filters/Filter.js"],"names":["SOURCE_KEY_MAP","Filter","vertexSrc","fragmentSrc","uniformData","apply","filterManager","input","output","clear","currentState","value"],"mappings":"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","sourcesContent":["import extractUniformsFromSrc from './extractUniformsFromSrc';\nimport { uid } from '../../../utils';\nimport { BLEND_MODES } from '../../../const';\nimport settings from '../../../settings';\n\nconst SOURCE_KEY_MAP = {};\n\n// let math = require('../../../math');\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.Shader\n */\nexport default class Filter\n{\n    /**\n     * @param {string} [vertexSrc] - The source of the vertex shader.\n     * @param {string} [fragmentSrc] - The source of the fragment shader.\n     * @param {object} [uniformData] - Custom uniforms to use to augment the built-in ones.\n     */\n    constructor(vertexSrc, fragmentSrc, uniformData)\n    {\n        /**\n         * The vertex shader.\n         *\n         * @member {string}\n         */\n        this.vertexSrc = vertexSrc || Filter.defaultVertexSrc;\n\n        /**\n         * The fragment shader.\n         *\n         * @member {string}\n         */\n        this.fragmentSrc = fragmentSrc || Filter.defaultFragmentSrc;\n\n        this._blendMode = BLEND_MODES.NORMAL;\n\n        this.uniformData = uniformData || extractUniformsFromSrc(\n            this.vertexSrc,\n            this.fragmentSrc,\n            'projectionMatrix|uSampler'\n        );\n\n        /**\n         * An object containing the current values of custom uniforms.\n         * @example <caption>Updating the value of a custom uniform</caption>\n         * filter.uniforms.time = performance.now();\n         *\n         * @member {object}\n         */\n        this.uniforms = {};\n\n        for (const i in this.uniformData)\n        {\n            this.uniforms[i] = this.uniformData[i].value;\n            if (this.uniformData[i].type)\n            {\n                this.uniformData[i].type = this.uniformData[i].type.toLowerCase();\n            }\n        }\n\n        // this is where we store shader references..\n        // TODO we could cache this!\n        this.glShaders = {};\n\n        // used for caching.. sure there is a better way!\n        if (!SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc])\n        {\n            SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc] = uid();\n        }\n\n        this.glShaderKey = SOURCE_KEY_MAP[this.vertexSrc + this.fragmentSrc];\n\n        /**\n         * The padding of the filter. Some filters require extra space to breath such as a blur.\n         * Increasing this will add extra width and height to the bounds of the object that the\n         * filter is applied to.\n         *\n         * @member {number}\n         */\n        this.padding = 4;\n\n        /**\n         * The resolution of the filter. Setting this to be lower will lower the quality but\n         * increase the performance of the filter.\n         *\n         * @member {number}\n         */\n        this.resolution = settings.FILTER_RESOLUTION;\n\n        /**\n         * If enabled is true the filter is applied, if false it will not.\n         *\n         * @member {boolean}\n         */\n        this.enabled = true;\n\n        /**\n         * If enabled, PixiJS will fit the filter area into boundaries for better performance.\n         * Switch it off if it does not work for specific shader.\n         *\n         * @member {boolean}\n         */\n        this.autoFit = true;\n    }\n\n    /**\n     * Applies the filter\n     *\n     * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from\n     * @param {PIXI.RenderTarget} input - The input render target.\n     * @param {PIXI.RenderTarget} output - The target to output to.\n     * @param {boolean} clear - Should the output be cleared before rendering to it\n     * @param {object} [currentState] - It's current state of filter.\n     *        There are some useful properties in the currentState :\n     *        target, filters, sourceFrame, destinationFrame, renderTarget, resolution\n     */\n    apply(filterManager, input, output, clear, currentState) // eslint-disable-line no-unused-vars\n    {\n        // --- //\n        //  this.uniforms.filterMatrix = filterManager.calculateSpriteMatrix(tempMatrix, window.panda );\n\n        // do as you please!\n\n        filterManager.applyFilter(this, input, output, clear);\n\n        // or just do a regular render..\n    }\n\n    /**\n     * Sets the blendmode of the filter\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL\n     */\n    get blendMode()\n    {\n        return this._blendMode;\n    }\n\n    set blendMode(value) // eslint-disable-line require-jsdoc\n    {\n        this._blendMode = value;\n    }\n\n    /**\n     * The default vertex shader source\n     *\n     * @static\n     * @constant\n     */\n    static get defaultVertexSrc()\n    {\n        return [\n            'attribute vec2 aVertexPosition;',\n            'attribute vec2 aTextureCoord;',\n\n            'uniform mat3 projectionMatrix;',\n            'uniform mat3 filterMatrix;',\n\n            'varying vec2 vTextureCoord;',\n            'varying vec2 vFilterCoord;',\n\n            'void main(void){',\n            '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n            '   vFilterCoord = ( filterMatrix * vec3( aTextureCoord, 1.0)  ).xy;',\n            '   vTextureCoord = aTextureCoord ;',\n            '}',\n        ].join('\\n');\n    }\n\n    /**\n     * The default fragment shader source\n     *\n     * @static\n     * @constant\n     */\n    static get defaultFragmentSrc()\n    {\n        return [\n            'varying vec2 vTextureCoord;',\n            'varying vec2 vFilterCoord;',\n\n            'uniform sampler2D uSampler;',\n            'uniform sampler2D filterSampler;',\n\n            'void main(void){',\n            '   vec4 masky = texture2D(filterSampler, vFilterCoord);',\n            '   vec4 sample = texture2D(uSampler, vTextureCoord);',\n            '   vec4 color;',\n            '   if(mod(vFilterCoord.x, 1.0) > 0.5)',\n            '   {',\n            '     color = vec4(1.0, 0.0, 0.0, 1.0);',\n            '   }',\n            '   else',\n            '   {',\n            '     color = vec4(0.0, 1.0, 0.0, 1.0);',\n            '   }',\n            // '   gl_FragColor = vec4(mod(vFilterCoord.x, 1.5), vFilterCoord.y,0.0,1.0);',\n            '   gl_FragColor = mix(sample, masky, 0.5);',\n            '   gl_FragColor *= sample.a;',\n            '}',\n        ].join('\\n');\n    }\n}\n"]},"metadata":{},"sourceType":"script"}