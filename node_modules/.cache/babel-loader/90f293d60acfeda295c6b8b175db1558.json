{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _ObjectRenderer2 = require('../../renderers/webgl/utils/ObjectRenderer');\n\nvar _ObjectRenderer3 = _interopRequireDefault(_ObjectRenderer2);\n\nvar _WebGLRenderer = require('../../renderers/webgl/WebGLRenderer');\n\nvar _WebGLRenderer2 = _interopRequireDefault(_WebGLRenderer);\n\nvar _createIndicesForQuads = require('../../utils/createIndicesForQuads');\n\nvar _createIndicesForQuads2 = _interopRequireDefault(_createIndicesForQuads);\n\nvar _generateMultiTextureShader = require('./generateMultiTextureShader');\n\nvar _generateMultiTextureShader2 = _interopRequireDefault(_generateMultiTextureShader);\n\nvar _checkMaxIfStatmentsInShader = require('../../renderers/webgl/utils/checkMaxIfStatmentsInShader');\n\nvar _checkMaxIfStatmentsInShader2 = _interopRequireDefault(_checkMaxIfStatmentsInShader);\n\nvar _BatchBuffer = require('./BatchBuffer');\n\nvar _BatchBuffer2 = _interopRequireDefault(_BatchBuffer);\n\nvar _settings = require('../../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nvar _utils = require('../../utils');\n\nvar _pixiGlCore = require('pixi-gl-core');\n\nvar _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);\n\nvar _bitTwiddle = require('bit-twiddle');\n\nvar _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar TICK = 0;\nvar TEXTURE_TICK = 0;\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @private\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\n\nvar SpriteRenderer = function (_ObjectRenderer) {\n  _inherits(SpriteRenderer, _ObjectRenderer);\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n   */\n\n\n  function SpriteRenderer(renderer) {\n    _classCallCheck(this, SpriteRenderer);\n    /**\n     * Number of values sent in the vertex buffer.\n     * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5\n     *\n     * @member {number}\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _ObjectRenderer.call(this, renderer));\n\n    _this.vertSize = 5;\n    /**\n     * The size of the vertex information in bytes.\n     *\n     * @member {number}\n     */\n\n    _this.vertByteSize = _this.vertSize * 4;\n    /**\n     * The number of images in the SpriteRenderer before it flushes.\n     *\n     * @member {number}\n     */\n\n    _this.size = _settings2.default.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop\n    // the total number of bytes in our batch\n    // let numVerts = this.size * 4 * this.vertByteSize;\n\n    _this.buffers = [];\n\n    for (var i = 1; i <= _bitTwiddle2.default.nextPow2(_this.size); i *= 2) {\n      _this.buffers.push(new _BatchBuffer2.default(i * 4 * _this.vertByteSize));\n    }\n    /**\n     * Holds the indices of the geometry (quads) to draw\n     *\n     * @member {Uint16Array}\n     */\n\n\n    _this.indices = (0, _createIndicesForQuads2.default)(_this.size);\n    /**\n     * The default shaders that is used if a sprite doesn't have a more specific one.\n     * there is a shader for each number of textures that can be rendererd.\n     * These shaders will also be generated on the fly as required.\n     * @member {PIXI.Shader[]}\n     */\n\n    _this.shader = null;\n    _this.currentIndex = 0;\n    _this.groups = [];\n\n    for (var k = 0; k < _this.size; k++) {\n      _this.groups[k] = {\n        textures: [],\n        textureCount: 0,\n        ids: [],\n        size: 0,\n        start: 0,\n        blend: 0\n      };\n    }\n\n    _this.sprites = [];\n    _this.vertexBuffers = [];\n    _this.vaos = [];\n    _this.vaoMax = 2;\n    _this.vertexCount = 0;\n\n    _this.renderer.on('prerender', _this.onPrerender, _this);\n\n    return _this;\n  }\n  /**\n   * Sets up the renderer context and necessary buffers.\n   *\n   * @private\n   */\n\n\n  SpriteRenderer.prototype.onContextChange = function onContextChange() {\n    var gl = this.renderer.gl;\n\n    if (this.renderer.legacy) {\n      this.MAX_TEXTURES = 1;\n    } else {\n      // step 1: first check max textures the GPU can handle.\n      this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), _settings2.default.SPRITE_MAX_TEXTURES); // step 2: check the maximum number of if statements the shader can have too..\n\n      this.MAX_TEXTURES = (0, _checkMaxIfStatmentsInShader2.default)(this.MAX_TEXTURES, gl);\n    }\n\n    this.shader = (0, _generateMultiTextureShader2.default)(gl, this.MAX_TEXTURES); // create a couple of buffers\n\n    this.indexBuffer = _pixiGlCore2.default.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW); // we use the second shader as the first one depending on your browser may omit aTextureId\n    // as it is not used by the shader so is optimized out.\n\n    this.renderer.bindVao(null);\n    var attrs = this.shader.attributes;\n\n    for (var i = 0; i < this.vaoMax; i++) {\n      /* eslint-disable max-len */\n      var vertexBuffer = this.vertexBuffers[i] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n      /* eslint-enable max-len */\n      // build the vao object that will render..\n\n\n      var vao = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);\n\n      if (attrs.aTextureId) {\n        vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);\n      }\n\n      this.vaos[i] = vao;\n    }\n\n    this.vao = this.vaos[0];\n    this.currentBlendMode = 99999;\n    this.boundTextures = new Array(this.MAX_TEXTURES);\n  };\n  /**\n   * Called before the renderer starts rendering.\n   *\n   */\n\n\n  SpriteRenderer.prototype.onPrerender = function onPrerender() {\n    this.vertexCount = 0;\n  };\n  /**\n   * Renders the sprite object.\n   *\n   * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n   */\n\n\n  SpriteRenderer.prototype.render = function render(sprite) {\n    // TODO set blend modes..\n    // check texture..\n    if (this.currentIndex >= this.size) {\n      this.flush();\n    } // get the uvs for the texture\n    // if the uvs have not updated then no point rendering just yet!\n\n\n    if (!sprite._texture._uvs) {\n      return;\n    } // push a texture.\n    // increment the batchsize\n\n\n    this.sprites[this.currentIndex++] = sprite;\n  };\n  /**\n   * Renders the content and empties the current batch.\n   *\n   */\n\n\n  SpriteRenderer.prototype.flush = function flush() {\n    if (this.currentIndex === 0) {\n      return;\n    }\n\n    var gl = this.renderer.gl;\n    var MAX_TEXTURES = this.MAX_TEXTURES;\n\n    var np2 = _bitTwiddle2.default.nextPow2(this.currentIndex);\n\n    var log2 = _bitTwiddle2.default.log2(np2);\n\n    var buffer = this.buffers[log2];\n    var sprites = this.sprites;\n    var groups = this.groups;\n    var float32View = buffer.float32View;\n    var uint32View = buffer.uint32View;\n    var boundTextures = this.boundTextures;\n    var rendererBoundTextures = this.renderer.boundTextures;\n    var touch = this.renderer.textureGC.count;\n    var index = 0;\n    var nextTexture = void 0;\n    var currentTexture = void 0;\n    var groupCount = 1;\n    var textureCount = 0;\n    var currentGroup = groups[0];\n    var vertexData = void 0;\n    var uvs = void 0;\n    var blendMode = _utils.premultiplyBlendMode[sprites[0]._texture.baseTexture.premultipliedAlpha ? 1 : 0][sprites[0].blendMode];\n    currentGroup.textureCount = 0;\n    currentGroup.start = 0;\n    currentGroup.blend = blendMode;\n    TICK++;\n    var i = void 0; // copy textures..\n\n    for (i = 0; i < MAX_TEXTURES; ++i) {\n      var bt = rendererBoundTextures[i];\n\n      if (bt._enabled === TICK) {\n        boundTextures[i] = this.renderer.emptyTextures[i];\n        continue;\n      }\n\n      boundTextures[i] = bt;\n      bt._virtalBoundId = i;\n      bt._enabled = TICK;\n    }\n\n    TICK++;\n\n    for (i = 0; i < this.currentIndex; ++i) {\n      // upload the sprite elemetns...\n      // they have all ready been calculated so we just need to push them into the buffer.\n      var sprite = sprites[i];\n      sprites[i] = null;\n      nextTexture = sprite._texture.baseTexture;\n\n      var spriteBlendMode = _utils.premultiplyBlendMode[Number(nextTexture.premultipliedAlpha)][sprite.blendMode];\n\n      if (blendMode !== spriteBlendMode) {\n        // finish a group..\n        blendMode = spriteBlendMode; // force the batch to break!\n\n        currentTexture = null;\n        textureCount = MAX_TEXTURES;\n        TICK++;\n      }\n\n      if (currentTexture !== nextTexture) {\n        currentTexture = nextTexture;\n\n        if (nextTexture._enabled !== TICK) {\n          if (textureCount === MAX_TEXTURES) {\n            TICK++;\n            currentGroup.size = i - currentGroup.start;\n            textureCount = 0;\n            currentGroup = groups[groupCount++];\n            currentGroup.blend = blendMode;\n            currentGroup.textureCount = 0;\n            currentGroup.start = i;\n          }\n\n          nextTexture.touched = touch;\n\n          if (nextTexture._virtalBoundId === -1) {\n            for (var j = 0; j < MAX_TEXTURES; ++j) {\n              var tIndex = (j + TEXTURE_TICK) % MAX_TEXTURES;\n              var t = boundTextures[tIndex];\n\n              if (t._enabled !== TICK) {\n                TEXTURE_TICK++;\n                t._virtalBoundId = -1;\n                nextTexture._virtalBoundId = tIndex;\n                boundTextures[tIndex] = nextTexture;\n                break;\n              }\n            }\n          }\n\n          nextTexture._enabled = TICK;\n          currentGroup.textureCount++;\n          currentGroup.ids[textureCount] = nextTexture._virtalBoundId;\n          currentGroup.textures[textureCount++] = nextTexture;\n        }\n      }\n\n      vertexData = sprite.vertexData; // TODO this sum does not need to be set each frame..\n\n      uvs = sprite._texture._uvs.uvsUint32;\n\n      if (this.renderer.roundPixels) {\n        var resolution = this.renderer.resolution; // xy\n\n        float32View[index] = (vertexData[0] * resolution | 0) / resolution;\n        float32View[index + 1] = (vertexData[1] * resolution | 0) / resolution; // xy\n\n        float32View[index + 5] = (vertexData[2] * resolution | 0) / resolution;\n        float32View[index + 6] = (vertexData[3] * resolution | 0) / resolution; // xy\n\n        float32View[index + 10] = (vertexData[4] * resolution | 0) / resolution;\n        float32View[index + 11] = (vertexData[5] * resolution | 0) / resolution; // xy\n\n        float32View[index + 15] = (vertexData[6] * resolution | 0) / resolution;\n        float32View[index + 16] = (vertexData[7] * resolution | 0) / resolution;\n      } else {\n        // xy\n        float32View[index] = vertexData[0];\n        float32View[index + 1] = vertexData[1]; // xy\n\n        float32View[index + 5] = vertexData[2];\n        float32View[index + 6] = vertexData[3]; // xy\n\n        float32View[index + 10] = vertexData[4];\n        float32View[index + 11] = vertexData[5]; // xy\n\n        float32View[index + 15] = vertexData[6];\n        float32View[index + 16] = vertexData[7];\n      }\n\n      uint32View[index + 2] = uvs[0];\n      uint32View[index + 7] = uvs[1];\n      uint32View[index + 12] = uvs[2];\n      uint32View[index + 17] = uvs[3];\n      /* eslint-disable max-len */\n\n      var alpha = Math.min(sprite.worldAlpha, 1.0); // we dont call extra function if alpha is 1.0, that's faster\n\n      var argb = alpha < 1.0 && nextTexture.premultipliedAlpha ? (0, _utils.premultiplyTint)(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);\n      uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = argb;\n      float32View[index + 4] = float32View[index + 9] = float32View[index + 14] = float32View[index + 19] = nextTexture._virtalBoundId;\n      /* eslint-enable max-len */\n\n      index += 20;\n    }\n\n    currentGroup.size = i - currentGroup.start;\n\n    if (!_settings2.default.CAN_UPLOAD_SAME_BUFFER) {\n      // this is still needed for IOS performance..\n      // it really does not like uploading to the same buffer in a single frame!\n      if (this.vaoMax <= this.vertexCount) {\n        this.vaoMax++;\n        var attrs = this.shader.attributes;\n        /* eslint-disable max-len */\n\n        var vertexBuffer = this.vertexBuffers[this.vertexCount] = _pixiGlCore2.default.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n        /* eslint-enable max-len */\n        // build the vao object that will render..\n\n\n        var vao = this.renderer.createVao().addIndex(this.indexBuffer).addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0).addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4).addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);\n\n        if (attrs.aTextureId) {\n          vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);\n        }\n\n        this.vaos[this.vertexCount] = vao;\n      }\n\n      this.renderer.bindVao(this.vaos[this.vertexCount]);\n      this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, false);\n      this.vertexCount++;\n    } else {\n      // lets use the faster option, always use buffer number 0\n      this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, true);\n    }\n\n    for (i = 0; i < MAX_TEXTURES; ++i) {\n      rendererBoundTextures[i]._virtalBoundId = -1;\n    } // render the groups..\n\n\n    for (i = 0; i < groupCount; ++i) {\n      var group = groups[i];\n      var groupTextureCount = group.textureCount;\n\n      for (var _j = 0; _j < groupTextureCount; _j++) {\n        currentTexture = group.textures[_j]; // reset virtual ids..\n        // lets do a quick check..\n\n        if (rendererBoundTextures[group.ids[_j]] !== currentTexture) {\n          this.renderer.bindTexture(currentTexture, group.ids[_j], true);\n        } // reset the virtualId..\n\n\n        currentTexture._virtalBoundId = -1;\n      } // set the blend mode..\n\n\n      this.renderer.state.setBlendMode(group.blend);\n      gl.drawElements(gl.TRIANGLES, group.size * 6, gl.UNSIGNED_SHORT, group.start * 6 * 2);\n    } // reset elements for the next flush\n\n\n    this.currentIndex = 0;\n  };\n  /**\n   * Starts a new sprite batch.\n   */\n\n\n  SpriteRenderer.prototype.start = function start() {\n    this.renderer.bindShader(this.shader);\n\n    if (_settings2.default.CAN_UPLOAD_SAME_BUFFER) {\n      // bind buffer #0, we don't need others\n      this.renderer.bindVao(this.vaos[this.vertexCount]);\n      this.vertexBuffers[this.vertexCount].bind();\n    }\n  };\n  /**\n   * Stops and flushes the current batch.\n   *\n   */\n\n\n  SpriteRenderer.prototype.stop = function stop() {\n    this.flush();\n  };\n  /**\n   * Destroys the SpriteRenderer.\n   *\n   */\n\n\n  SpriteRenderer.prototype.destroy = function destroy() {\n    for (var i = 0; i < this.vaoMax; i++) {\n      if (this.vertexBuffers[i]) {\n        this.vertexBuffers[i].destroy();\n      }\n\n      if (this.vaos[i]) {\n        this.vaos[i].destroy();\n      }\n    }\n\n    if (this.indexBuffer) {\n      this.indexBuffer.destroy();\n    }\n\n    this.renderer.off('prerender', this.onPrerender, this);\n\n    _ObjectRenderer.prototype.destroy.call(this);\n\n    if (this.shader) {\n      this.shader.destroy();\n      this.shader = null;\n    }\n\n    this.vertexBuffers = null;\n    this.vaos = null;\n    this.indexBuffer = null;\n    this.indices = null;\n    this.sprites = null;\n\n    for (var _i = 0; _i < this.buffers.length; ++_i) {\n      this.buffers[_i].destroy();\n    }\n  };\n\n  return SpriteRenderer;\n}(_ObjectRenderer3.default);\n\nexports.default = SpriteRenderer;\n\n_WebGLRenderer2.default.registerPlugin('sprite', SpriteRenderer);","map":{"version":3,"sources":["../../../../src/core/sprites/webgl/SpriteRenderer.js"],"names":["TICK","TEXTURE_TICK","SpriteRenderer","i","k","textures","textureCount","ids","size","start","blend","onContextChange","gl","Math","attrs","vertexBuffer","vao","onPrerender","render","sprite","flush","MAX_TEXTURES","np2","log2","buffer","sprites","groups","float32View","uint32View","boundTextures","rendererBoundTextures","touch","index","nextTexture","currentTexture","groupCount","currentGroup","vertexData","uvs","blendMode","bt","spriteBlendMode","Number","j","tIndex","t","resolution","alpha","argb","group","groupTextureCount","stop","destroy"],"mappings":"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","sourcesContent":["import ObjectRenderer from '../../renderers/webgl/utils/ObjectRenderer';\nimport WebGLRenderer from '../../renderers/webgl/WebGLRenderer';\nimport createIndicesForQuads from '../../utils/createIndicesForQuads';\nimport generateMultiTextureShader from './generateMultiTextureShader';\nimport checkMaxIfStatmentsInShader from '../../renderers/webgl/utils/checkMaxIfStatmentsInShader';\nimport Buffer from './BatchBuffer';\nimport settings from '../../settings';\nimport { premultiplyBlendMode, premultiplyTint } from '../../utils';\nimport glCore from 'pixi-gl-core';\nimport bitTwiddle from 'bit-twiddle';\n\nlet TICK = 0;\nlet TEXTURE_TICK = 0;\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @private\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nexport default class SpriteRenderer extends ObjectRenderer\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        /**\n         * Number of values sent in the vertex buffer.\n         * aVertexPosition(2), aTextureCoord(1), aColor(1), aTextureId(1) = 5\n         *\n         * @member {number}\n         */\n        this.vertSize = 5;\n\n        /**\n         * The size of the vertex information in bytes.\n         *\n         * @member {number}\n         */\n        this.vertByteSize = this.vertSize * 4;\n\n        /**\n         * The number of images in the SpriteRenderer before it flushes.\n         *\n         * @member {number}\n         */\n        this.size = settings.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop\n\n        // the total number of bytes in our batch\n        // let numVerts = this.size * 4 * this.vertByteSize;\n\n        this.buffers = [];\n        for (let i = 1; i <= bitTwiddle.nextPow2(this.size); i *= 2)\n        {\n            this.buffers.push(new Buffer(i * 4 * this.vertByteSize));\n        }\n\n        /**\n         * Holds the indices of the geometry (quads) to draw\n         *\n         * @member {Uint16Array}\n         */\n        this.indices = createIndicesForQuads(this.size);\n\n        /**\n         * The default shaders that is used if a sprite doesn't have a more specific one.\n         * there is a shader for each number of textures that can be rendererd.\n         * These shaders will also be generated on the fly as required.\n         * @member {PIXI.Shader[]}\n         */\n        this.shader = null;\n\n        this.currentIndex = 0;\n        this.groups = [];\n\n        for (let k = 0; k < this.size; k++)\n        {\n            this.groups[k] = { textures: [], textureCount: 0, ids: [], size: 0, start: 0, blend: 0 };\n        }\n\n        this.sprites = [];\n\n        this.vertexBuffers = [];\n        this.vaos = [];\n\n        this.vaoMax = 2;\n        this.vertexCount = 0;\n\n        this.renderer.on('prerender', this.onPrerender, this);\n    }\n\n    /**\n     * Sets up the renderer context and necessary buffers.\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        if (this.renderer.legacy)\n        {\n            this.MAX_TEXTURES = 1;\n        }\n        else\n        {\n            // step 1: first check max textures the GPU can handle.\n            this.MAX_TEXTURES = Math.min(gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS), settings.SPRITE_MAX_TEXTURES);\n\n            // step 2: check the maximum number of if statements the shader can have too..\n            this.MAX_TEXTURES = checkMaxIfStatmentsInShader(this.MAX_TEXTURES, gl);\n        }\n\n        this.shader = generateMultiTextureShader(gl, this.MAX_TEXTURES);\n\n        // create a couple of buffers\n        this.indexBuffer = glCore.GLBuffer.createIndexBuffer(gl, this.indices, gl.STATIC_DRAW);\n\n        // we use the second shader as the first one depending on your browser may omit aTextureId\n        // as it is not used by the shader so is optimized out.\n\n        this.renderer.bindVao(null);\n\n        const attrs = this.shader.attributes;\n\n        for (let i = 0; i < this.vaoMax; i++)\n        {\n            /* eslint-disable max-len */\n            const vertexBuffer = this.vertexBuffers[i] = glCore.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n            /* eslint-enable max-len */\n\n            // build the vao object that will render..\n            const vao = this.renderer.createVao()\n                .addIndex(this.indexBuffer)\n                .addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0)\n                .addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4)\n                .addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);\n\n            if (attrs.aTextureId)\n            {\n                vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);\n            }\n\n            this.vaos[i] = vao;\n        }\n\n        this.vao = this.vaos[0];\n        this.currentBlendMode = 99999;\n\n        this.boundTextures = new Array(this.MAX_TEXTURES);\n    }\n\n    /**\n     * Called before the renderer starts rendering.\n     *\n     */\n    onPrerender()\n    {\n        this.vertexCount = 0;\n    }\n\n    /**\n     * Renders the sprite object.\n     *\n     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n     */\n    render(sprite)\n    {\n        // TODO set blend modes..\n        // check texture..\n        if (this.currentIndex >= this.size)\n        {\n            this.flush();\n        }\n\n        // get the uvs for the texture\n\n        // if the uvs have not updated then no point rendering just yet!\n        if (!sprite._texture._uvs)\n        {\n            return;\n        }\n\n        // push a texture.\n        // increment the batchsize\n        this.sprites[this.currentIndex++] = sprite;\n    }\n\n    /**\n     * Renders the content and empties the current batch.\n     *\n     */\n    flush()\n    {\n        if (this.currentIndex === 0)\n        {\n            return;\n        }\n\n        const gl = this.renderer.gl;\n        const MAX_TEXTURES = this.MAX_TEXTURES;\n\n        const np2 = bitTwiddle.nextPow2(this.currentIndex);\n        const log2 = bitTwiddle.log2(np2);\n        const buffer = this.buffers[log2];\n\n        const sprites = this.sprites;\n        const groups = this.groups;\n\n        const float32View = buffer.float32View;\n        const uint32View = buffer.uint32View;\n\n        const boundTextures = this.boundTextures;\n        const rendererBoundTextures = this.renderer.boundTextures;\n        const touch = this.renderer.textureGC.count;\n\n        let index = 0;\n        let nextTexture;\n        let currentTexture;\n        let groupCount = 1;\n        let textureCount = 0;\n        let currentGroup = groups[0];\n        let vertexData;\n        let uvs;\n        let blendMode = premultiplyBlendMode[\n            sprites[0]._texture.baseTexture.premultipliedAlpha ? 1 : 0][sprites[0].blendMode];\n\n        currentGroup.textureCount = 0;\n        currentGroup.start = 0;\n        currentGroup.blend = blendMode;\n\n        TICK++;\n\n        let i;\n\n        // copy textures..\n        for (i = 0; i < MAX_TEXTURES; ++i)\n        {\n            const bt = rendererBoundTextures[i];\n\n            if (bt._enabled === TICK)\n            {\n                boundTextures[i] = this.renderer.emptyTextures[i];\n                continue;\n            }\n\n            boundTextures[i] = bt;\n            bt._virtalBoundId = i;\n            bt._enabled = TICK;\n        }\n        TICK++;\n\n        for (i = 0; i < this.currentIndex; ++i)\n        {\n            // upload the sprite elemetns...\n            // they have all ready been calculated so we just need to push them into the buffer.\n            const sprite = sprites[i];\n\n            sprites[i] = null;\n\n            nextTexture = sprite._texture.baseTexture;\n\n            const spriteBlendMode = premultiplyBlendMode[Number(nextTexture.premultipliedAlpha)][sprite.blendMode];\n\n            if (blendMode !== spriteBlendMode)\n            {\n                // finish a group..\n                blendMode = spriteBlendMode;\n\n                // force the batch to break!\n                currentTexture = null;\n                textureCount = MAX_TEXTURES;\n                TICK++;\n            }\n\n            if (currentTexture !== nextTexture)\n            {\n                currentTexture = nextTexture;\n\n                if (nextTexture._enabled !== TICK)\n                {\n                    if (textureCount === MAX_TEXTURES)\n                    {\n                        TICK++;\n\n                        currentGroup.size = i - currentGroup.start;\n\n                        textureCount = 0;\n\n                        currentGroup = groups[groupCount++];\n                        currentGroup.blend = blendMode;\n                        currentGroup.textureCount = 0;\n                        currentGroup.start = i;\n                    }\n\n                    nextTexture.touched = touch;\n\n                    if (nextTexture._virtalBoundId === -1)\n                    {\n                        for (let j = 0; j < MAX_TEXTURES; ++j)\n                        {\n                            const tIndex = (j + TEXTURE_TICK) % MAX_TEXTURES;\n\n                            const t = boundTextures[tIndex];\n\n                            if (t._enabled !== TICK)\n                            {\n                                TEXTURE_TICK++;\n\n                                t._virtalBoundId = -1;\n\n                                nextTexture._virtalBoundId = tIndex;\n\n                                boundTextures[tIndex] = nextTexture;\n                                break;\n                            }\n                        }\n                    }\n\n                    nextTexture._enabled = TICK;\n\n                    currentGroup.textureCount++;\n                    currentGroup.ids[textureCount] = nextTexture._virtalBoundId;\n                    currentGroup.textures[textureCount++] = nextTexture;\n                }\n            }\n\n            vertexData = sprite.vertexData;\n\n            // TODO this sum does not need to be set each frame..\n            uvs = sprite._texture._uvs.uvsUint32;\n\n            if (this.renderer.roundPixels)\n            {\n                const resolution = this.renderer.resolution;\n\n                // xy\n                float32View[index] = ((vertexData[0] * resolution) | 0) / resolution;\n                float32View[index + 1] = ((vertexData[1] * resolution) | 0) / resolution;\n\n                // xy\n                float32View[index + 5] = ((vertexData[2] * resolution) | 0) / resolution;\n                float32View[index + 6] = ((vertexData[3] * resolution) | 0) / resolution;\n\n                // xy\n                float32View[index + 10] = ((vertexData[4] * resolution) | 0) / resolution;\n                float32View[index + 11] = ((vertexData[5] * resolution) | 0) / resolution;\n\n                // xy\n                float32View[index + 15] = ((vertexData[6] * resolution) | 0) / resolution;\n                float32View[index + 16] = ((vertexData[7] * resolution) | 0) / resolution;\n            }\n            else\n            {\n                // xy\n                float32View[index] = vertexData[0];\n                float32View[index + 1] = vertexData[1];\n\n                // xy\n                float32View[index + 5] = vertexData[2];\n                float32View[index + 6] = vertexData[3];\n\n                // xy\n                float32View[index + 10] = vertexData[4];\n                float32View[index + 11] = vertexData[5];\n\n                // xy\n                float32View[index + 15] = vertexData[6];\n                float32View[index + 16] = vertexData[7];\n            }\n\n            uint32View[index + 2] = uvs[0];\n            uint32View[index + 7] = uvs[1];\n            uint32View[index + 12] = uvs[2];\n            uint32View[index + 17] = uvs[3];\n            /* eslint-disable max-len */\n            const alpha = Math.min(sprite.worldAlpha, 1.0);\n            // we dont call extra function if alpha is 1.0, that's faster\n            const argb = alpha < 1.0 && nextTexture.premultipliedAlpha ? premultiplyTint(sprite._tintRGB, alpha)\n                : sprite._tintRGB + (alpha * 255 << 24);\n\n            uint32View[index + 3] = uint32View[index + 8] = uint32View[index + 13] = uint32View[index + 18] = argb;\n            float32View[index + 4] = float32View[index + 9] = float32View[index + 14] = float32View[index + 19] = nextTexture._virtalBoundId;\n            /* eslint-enable max-len */\n\n            index += 20;\n        }\n\n        currentGroup.size = i - currentGroup.start;\n\n        if (!settings.CAN_UPLOAD_SAME_BUFFER)\n        {\n            // this is still needed for IOS performance..\n            // it really does not like uploading to the same buffer in a single frame!\n            if (this.vaoMax <= this.vertexCount)\n            {\n                this.vaoMax++;\n\n                const attrs = this.shader.attributes;\n\n                /* eslint-disable max-len */\n                const vertexBuffer = this.vertexBuffers[this.vertexCount] = glCore.GLBuffer.createVertexBuffer(gl, null, gl.STREAM_DRAW);\n                /* eslint-enable max-len */\n\n                // build the vao object that will render..\n                const vao = this.renderer.createVao()\n                    .addIndex(this.indexBuffer)\n                    .addAttribute(vertexBuffer, attrs.aVertexPosition, gl.FLOAT, false, this.vertByteSize, 0)\n                    .addAttribute(vertexBuffer, attrs.aTextureCoord, gl.UNSIGNED_SHORT, true, this.vertByteSize, 2 * 4)\n                    .addAttribute(vertexBuffer, attrs.aColor, gl.UNSIGNED_BYTE, true, this.vertByteSize, 3 * 4);\n\n                if (attrs.aTextureId)\n                {\n                    vao.addAttribute(vertexBuffer, attrs.aTextureId, gl.FLOAT, false, this.vertByteSize, 4 * 4);\n                }\n\n                this.vaos[this.vertexCount] = vao;\n            }\n\n            this.renderer.bindVao(this.vaos[this.vertexCount]);\n\n            this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, false);\n\n            this.vertexCount++;\n        }\n        else\n        {\n            // lets use the faster option, always use buffer number 0\n            this.vertexBuffers[this.vertexCount].upload(buffer.vertices, 0, true);\n        }\n\n        for (i = 0; i < MAX_TEXTURES; ++i)\n        {\n            rendererBoundTextures[i]._virtalBoundId = -1;\n        }\n\n        // render the groups..\n        for (i = 0; i < groupCount; ++i)\n        {\n            const group = groups[i];\n            const groupTextureCount = group.textureCount;\n\n            for (let j = 0; j < groupTextureCount; j++)\n            {\n                currentTexture = group.textures[j];\n\n                // reset virtual ids..\n                // lets do a quick check..\n                if (rendererBoundTextures[group.ids[j]] !== currentTexture)\n                {\n                    this.renderer.bindTexture(currentTexture, group.ids[j], true);\n                }\n\n                // reset the virtualId..\n                currentTexture._virtalBoundId = -1;\n            }\n\n            // set the blend mode..\n            this.renderer.state.setBlendMode(group.blend);\n\n            gl.drawElements(gl.TRIANGLES, group.size * 6, gl.UNSIGNED_SHORT, group.start * 6 * 2);\n        }\n\n        // reset elements for the next flush\n        this.currentIndex = 0;\n    }\n\n    /**\n     * Starts a new sprite batch.\n     */\n    start()\n    {\n        this.renderer.bindShader(this.shader);\n\n        if (settings.CAN_UPLOAD_SAME_BUFFER)\n        {\n            // bind buffer #0, we don't need others\n            this.renderer.bindVao(this.vaos[this.vertexCount]);\n\n            this.vertexBuffers[this.vertexCount].bind();\n        }\n    }\n\n    /**\n     * Stops and flushes the current batch.\n     *\n     */\n    stop()\n    {\n        this.flush();\n    }\n\n    /**\n     * Destroys the SpriteRenderer.\n     *\n     */\n    destroy()\n    {\n        for (let i = 0; i < this.vaoMax; i++)\n        {\n            if (this.vertexBuffers[i])\n            {\n                this.vertexBuffers[i].destroy();\n            }\n            if (this.vaos[i])\n            {\n                this.vaos[i].destroy();\n            }\n        }\n\n        if (this.indexBuffer)\n        {\n            this.indexBuffer.destroy();\n        }\n\n        this.renderer.off('prerender', this.onPrerender, this);\n\n        super.destroy();\n\n        if (this.shader)\n        {\n            this.shader.destroy();\n            this.shader = null;\n        }\n\n        this.vertexBuffers = null;\n        this.vaos = null;\n        this.indexBuffer = null;\n        this.indices = null;\n\n        this.sprites = null;\n\n        for (let i = 0; i < this.buffers.length; ++i)\n        {\n            this.buffers[i].destroy();\n        }\n    }\n}\n\nWebGLRenderer.registerPlugin('sprite', SpriteRenderer);\n"]},"metadata":{},"sourceType":"script"}