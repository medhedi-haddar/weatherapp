{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _math = require('../math');\n\nvar _TransformBase2 = require('./TransformBase');\n\nvar _TransformBase3 = _interopRequireDefault(_TransformBase2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * Generic class to deal with traditional 2D matrix transforms\n * local transformation is calculated from position,scale,skew and rotation\n *\n * @class\n * @extends PIXI.TransformBase\n * @memberof PIXI\n */\n\n\nvar Transform = function (_TransformBase) {\n  _inherits(Transform, _TransformBase);\n  /**\n   *\n   */\n\n\n  function Transform() {\n    _classCallCheck(this, Transform);\n    /**\n    * The coordinate of the object relative to the local coordinates of the parent.\n    *\n    * @member {PIXI.Point}\n    */\n\n\n    var _this = _possibleConstructorReturn(this, _TransformBase.call(this));\n\n    _this.position = new _math.Point(0, 0);\n    /**\n     * The scale factor of the object.\n     *\n     * @member {PIXI.Point}\n     */\n\n    _this.scale = new _math.Point(1, 1);\n    /**\n     * The skew amount, on the x and y axis.\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n\n    _this.skew = new _math.ObservablePoint(_this.updateSkew, _this, 0, 0);\n    /**\n     * The pivot point of the displayObject that it rotates around.\n     *\n     * @member {PIXI.Point}\n     */\n\n    _this.pivot = new _math.Point(0, 0);\n    /**\n     * The rotation value of the object, in radians\n     *\n     * @member {Number}\n     * @private\n     */\n\n    _this._rotation = 0;\n    _this._cx = 1; // cos rotation + skewY;\n\n    _this._sx = 0; // sin rotation + skewY;\n\n    _this._cy = 0; // cos rotation + Math.PI/2 - skewX;\n\n    _this._sy = 1; // sin rotation + Math.PI/2 - skewX;\n\n    return _this;\n  }\n  /**\n   * Updates the skew values when the skew or rotation changes.\n   *\n   * @private\n   */\n\n\n  Transform.prototype.updateSkew = function updateSkew() {\n    this._cx = Math.cos(this._rotation + this.skew._y);\n    this._sx = Math.sin(this._rotation + this.skew._y);\n    this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2\n\n    this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2\n  };\n  /**\n   * Updates only local matrix\n   */\n\n\n  Transform.prototype.updateLocalTransform = function updateLocalTransform() {\n    var lt = this.localTransform;\n    lt.a = this._cx * this.scale.x;\n    lt.b = this._sx * this.scale.x;\n    lt.c = this._cy * this.scale.y;\n    lt.d = this._sy * this.scale.y;\n    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);\n    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d);\n  };\n  /**\n   * Updates the values of the object and applies the parent's transform.\n   *\n   * @param {PIXI.Transform} parentTransform - The transform of the parent of this object\n   */\n\n\n  Transform.prototype.updateTransform = function updateTransform(parentTransform) {\n    var lt = this.localTransform;\n    lt.a = this._cx * this.scale.x;\n    lt.b = this._sx * this.scale.x;\n    lt.c = this._cy * this.scale.y;\n    lt.d = this._sy * this.scale.y;\n    lt.tx = this.position.x - (this.pivot.x * lt.a + this.pivot.y * lt.c);\n    lt.ty = this.position.y - (this.pivot.x * lt.b + this.pivot.y * lt.d); // concat the parent matrix with the objects transform.\n\n    var pt = parentTransform.worldTransform;\n    var wt = this.worldTransform;\n    wt.a = lt.a * pt.a + lt.b * pt.c;\n    wt.b = lt.a * pt.b + lt.b * pt.d;\n    wt.c = lt.c * pt.a + lt.d * pt.c;\n    wt.d = lt.c * pt.b + lt.d * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this._worldID++;\n  };\n  /**\n   * Decomposes a matrix and sets the transforms properties based on it.\n   *\n   * @param {PIXI.Matrix} matrix - The matrix to decompose\n   */\n\n\n  Transform.prototype.setFromMatrix = function setFromMatrix(matrix) {\n    matrix.decompose(this);\n  };\n  /**\n   * The rotation of the object in radians.\n   *\n   * @member {number}\n   */\n\n\n  _createClass(Transform, [{\n    key: 'rotation',\n    get: function get() {\n      return this._rotation;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this._rotation = value;\n      this.updateSkew();\n    }\n  }]);\n\n  return Transform;\n}(_TransformBase3.default);\n\nexports.default = Transform;","map":{"version":3,"sources":["../../../src/core/display/Transform.js"],"names":["Transform","updateSkew","Math","updateLocalTransform","lt","updateTransform","parentTransform","pt","wt","setFromMatrix","matrix","value"],"mappings":"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","sourcesContent":["import { Point, ObservablePoint } from '../math';\nimport TransformBase from './TransformBase';\n\n/**\n * Generic class to deal with traditional 2D matrix transforms\n * local transformation is calculated from position,scale,skew and rotation\n *\n * @class\n * @extends PIXI.TransformBase\n * @memberof PIXI\n */\nexport default class Transform extends TransformBase\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        super();\n\n         /**\n         * The coordinate of the object relative to the local coordinates of the parent.\n         *\n         * @member {PIXI.Point}\n         */\n        this.position = new Point(0, 0);\n\n        /**\n         * The scale factor of the object.\n         *\n         * @member {PIXI.Point}\n         */\n        this.scale = new Point(1, 1);\n\n        /**\n         * The skew amount, on the x and y axis.\n         *\n         * @member {PIXI.ObservablePoint}\n         */\n        this.skew = new ObservablePoint(this.updateSkew, this, 0, 0);\n\n        /**\n         * The pivot point of the displayObject that it rotates around.\n         *\n         * @member {PIXI.Point}\n         */\n        this.pivot = new Point(0, 0);\n\n        /**\n         * The rotation value of the object, in radians\n         *\n         * @member {Number}\n         * @private\n         */\n        this._rotation = 0;\n\n        this._cx = 1; // cos rotation + skewY;\n        this._sx = 0; // sin rotation + skewY;\n        this._cy = 0; // cos rotation + Math.PI/2 - skewX;\n        this._sy = 1; // sin rotation + Math.PI/2 - skewX;\n    }\n\n    /**\n     * Updates the skew values when the skew or rotation changes.\n     *\n     * @private\n     */\n    updateSkew()\n    {\n        this._cx = Math.cos(this._rotation + this.skew._y);\n        this._sx = Math.sin(this._rotation + this.skew._y);\n        this._cy = -Math.sin(this._rotation - this.skew._x); // cos, added PI/2\n        this._sy = Math.cos(this._rotation - this.skew._x); // sin, added PI/2\n    }\n\n    /**\n     * Updates only local matrix\n     */\n    updateLocalTransform()\n    {\n        const lt = this.localTransform;\n\n        lt.a = this._cx * this.scale.x;\n        lt.b = this._sx * this.scale.x;\n        lt.c = this._cy * this.scale.y;\n        lt.d = this._sy * this.scale.y;\n\n        lt.tx = this.position.x - ((this.pivot.x * lt.a) + (this.pivot.y * lt.c));\n        lt.ty = this.position.y - ((this.pivot.x * lt.b) + (this.pivot.y * lt.d));\n    }\n\n    /**\n     * Updates the values of the object and applies the parent's transform.\n     *\n     * @param {PIXI.Transform} parentTransform - The transform of the parent of this object\n     */\n    updateTransform(parentTransform)\n    {\n        const lt = this.localTransform;\n\n        lt.a = this._cx * this.scale.x;\n        lt.b = this._sx * this.scale.x;\n        lt.c = this._cy * this.scale.y;\n        lt.d = this._sy * this.scale.y;\n\n        lt.tx = this.position.x - ((this.pivot.x * lt.a) + (this.pivot.y * lt.c));\n        lt.ty = this.position.y - ((this.pivot.x * lt.b) + (this.pivot.y * lt.d));\n\n        // concat the parent matrix with the objects transform.\n        const pt = parentTransform.worldTransform;\n        const wt = this.worldTransform;\n\n        wt.a = (lt.a * pt.a) + (lt.b * pt.c);\n        wt.b = (lt.a * pt.b) + (lt.b * pt.d);\n        wt.c = (lt.c * pt.a) + (lt.d * pt.c);\n        wt.d = (lt.c * pt.b) + (lt.d * pt.d);\n        wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx;\n        wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty;\n\n        this._worldID ++;\n    }\n\n    /**\n     * Decomposes a matrix and sets the transforms properties based on it.\n     *\n     * @param {PIXI.Matrix} matrix - The matrix to decompose\n     */\n    setFromMatrix(matrix)\n    {\n        matrix.decompose(this);\n    }\n\n    /**\n     * The rotation of the object in radians.\n     *\n     * @member {number}\n     */\n    get rotation()\n    {\n        return this._rotation;\n    }\n\n    set rotation(value) // eslint-disable-line require-jsdoc\n    {\n        this._rotation = value;\n        this.updateSkew();\n    }\n}\n"]},"metadata":{},"sourceType":"script"}