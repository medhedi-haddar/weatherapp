{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.Loader = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _miniSignals = require('mini-signals');\n\nvar _miniSignals2 = _interopRequireDefault(_miniSignals);\n\nvar _parseUri = require('parse-uri');\n\nvar _parseUri2 = _interopRequireDefault(_parseUri);\n\nvar _async = require('./async');\n\nvar async = _interopRequireWildcard(_async);\n\nvar _Resource = require('./Resource');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // some constants\n\n\nvar MAX_PROGRESS = 100;\nvar rgxExtractUrlHash = /(#[\\w-]+)?$/;\n/**\n * Manages the state and loading of multiple resources to load.\n *\n * @class\n */\n\nvar Loader = exports.Loader = function () {\n  /**\n   * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.\n   * @param {number} [concurrency=10] - The number of resources to load concurrently.\n   */\n  function Loader() {\n    var _this = this;\n\n    var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var concurrency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n\n    _classCallCheck(this, Loader);\n    /**\n     * The base url for all resources loaded by this loader.\n     *\n     * @member {string}\n     */\n\n\n    this.baseUrl = baseUrl;\n    /**\n     * The progress percent of the loader going through the queue.\n     *\n     * @member {number}\n     */\n\n    this.progress = 0;\n    /**\n     * Loading state of the loader, true if it is currently loading resources.\n     *\n     * @member {boolean}\n     */\n\n    this.loading = false;\n    /**\n     * A querystring to append to every URL added to the loader.\n     *\n     * This should be a valid query string *without* the question-mark (`?`). The loader will\n     * also *not* escape values for you. Make sure to escape your parameters with\n     * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.\n     *\n     * @example\n     * const loader = new Loader();\n     *\n     * loader.defaultQueryString = 'user=me&password=secret';\n     *\n     * // This will request 'image.png?user=me&password=secret'\n     * loader.add('image.png').load();\n     *\n     * loader.reset();\n     *\n     * // This will request 'image.png?v=1&user=me&password=secret'\n     * loader.add('iamge.png?v=1').load();\n     *\n     * @member {string}\n     */\n\n    this.defaultQueryString = '';\n    /**\n     * The middleware to run before loading each resource.\n     *\n     * @private\n     * @member {function[]}\n     */\n\n    this._beforeMiddleware = [];\n    /**\n     * The middleware to run after loading each resource.\n     *\n     * @private\n     * @member {function[]}\n     */\n\n    this._afterMiddleware = [];\n    /**\n     * The tracks the resources we are currently completing parsing for.\n     *\n     * @private\n     * @member {Resource[]}\n     */\n\n    this._resourcesParsing = [];\n    /**\n     * The `_loadResource` function bound with this object context.\n     *\n     * @private\n     * @member {function}\n     * @param {Resource} r - The resource to load\n     * @param {Function} d - The dequeue function\n     * @return {undefined}\n     */\n\n    this._boundLoadResource = function (r, d) {\n      return _this._loadResource(r, d);\n    };\n    /**\n     * The resources waiting to be loaded.\n     *\n     * @private\n     * @member {Resource[]}\n     */\n\n\n    this._queue = async.queue(this._boundLoadResource, concurrency);\n\n    this._queue.pause();\n    /**\n     * All the resources for this loader keyed by name.\n     *\n     * @member {object<string, Resource>}\n     */\n\n\n    this.resources = {};\n    /**\n     * Dispatched once per loaded or errored resource.\n     *\n     * The callback looks like {@link Loader.OnProgressSignal}.\n     *\n     * @member {Signal<Loader.OnProgressSignal>}\n     */\n\n    this.onProgress = new _miniSignals2.default();\n    /**\n     * Dispatched once per errored resource.\n     *\n     * The callback looks like {@link Loader.OnErrorSignal}.\n     *\n     * @member {Signal<Loader.OnErrorSignal>}\n     */\n\n    this.onError = new _miniSignals2.default();\n    /**\n     * Dispatched once per loaded resource.\n     *\n     * The callback looks like {@link Loader.OnLoadSignal}.\n     *\n     * @member {Signal<Loader.OnLoadSignal>}\n     */\n\n    this.onLoad = new _miniSignals2.default();\n    /**\n     * Dispatched when the loader begins to process the queue.\n     *\n     * The callback looks like {@link Loader.OnStartSignal}.\n     *\n     * @member {Signal<Loader.OnStartSignal>}\n     */\n\n    this.onStart = new _miniSignals2.default();\n    /**\n     * Dispatched when the queued resources all load.\n     *\n     * The callback looks like {@link Loader.OnCompleteSignal}.\n     *\n     * @member {Signal<Loader.OnCompleteSignal>}\n     */\n\n    this.onComplete = new _miniSignals2.default(); // Add default before middleware\n\n    for (var i = 0; i < Loader._defaultBeforeMiddleware.length; ++i) {\n      this.pre(Loader._defaultBeforeMiddleware[i]);\n    } // Add default after middleware\n\n\n    for (var _i = 0; _i < Loader._defaultAfterMiddleware.length; ++_i) {\n      this.use(Loader._defaultAfterMiddleware[_i]);\n    }\n  }\n  /**\n   * When the progress changes the loader and resource are disaptched.\n   *\n   * @memberof Loader\n   * @callback OnProgressSignal\n   * @param {Loader} loader - The loader the progress is advancing on.\n   * @param {Resource} resource - The resource that has completed or failed to cause the progress to advance.\n   */\n\n  /**\n   * When an error occurrs the loader and resource are disaptched.\n   *\n   * @memberof Loader\n   * @callback OnErrorSignal\n   * @param {Loader} loader - The loader the error happened in.\n   * @param {Resource} resource - The resource that caused the error.\n   */\n\n  /**\n   * When a load completes the loader and resource are disaptched.\n   *\n   * @memberof Loader\n   * @callback OnLoadSignal\n   * @param {Loader} loader - The loader that laoded the resource.\n   * @param {Resource} resource - The resource that has completed loading.\n   */\n\n  /**\n   * When the loader starts loading resources it dispatches this callback.\n   *\n   * @memberof Loader\n   * @callback OnStartSignal\n   * @param {Loader} loader - The loader that has started loading resources.\n   */\n\n  /**\n   * When the loader completes loading resources it dispatches this callback.\n   *\n   * @memberof Loader\n   * @callback OnCompleteSignal\n   * @param {Loader} loader - The loader that has finished loading resources.\n   */\n\n  /**\n   * Options for a call to `.add()`.\n   *\n   * @see Loader#add\n   *\n   * @typedef {object} IAddOptions\n   * @property {string} [name] - The name of the resource to load, if not passed the url is used.\n   * @property {string} [key] - Alias for `name`.\n   * @property {string} [url] - The url for this resource, relative to the baseUrl of this loader.\n   * @property {string|boolean} [crossOrigin] - Is this request cross-origin? Default is to\n   *      determine automatically.\n   * @property {number} [timeout=0] - A timeout in milliseconds for the load. If the load takes\n   *      longer than this time it is cancelled and the load is considered a failure. If this value is\n   *      set to `0` then there is no explicit timeout.\n   * @property {Resource.LOAD_TYPE} [loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n   *      be loaded?\n   * @property {Resource.XHR_RESPONSE_TYPE} [xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n   *      should the data being loaded be interpreted when using XHR?\n   * @property {Resource.OnCompleteSignal} [onComplete] - Callback to add an an onComplete signal istener.\n   * @property {Resource.OnCompleteSignal} [callback] - Alias for `onComplete`.\n   * @property {Resource.IMetadata} [metadata] - Extra configuration for middleware and the Resource object.\n   */\n\n  /* eslint-disable require-jsdoc,valid-jsdoc */\n\n  /**\n   * Adds a resource (or multiple resources) to the loader queue.\n   *\n   * This function can take a wide variety of different parameters. The only thing that is always\n   * required the url to load. All the following will work:\n   *\n   * ```js\n   * loader\n   *     // normal param syntax\n   *     .add('key', 'http://...', function () {})\n   *     .add('http://...', function () {})\n   *     .add('http://...')\n   *\n   *     // object syntax\n   *     .add({\n   *         name: 'key2',\n   *         url: 'http://...'\n   *     }, function () {})\n   *     .add({\n   *         url: 'http://...'\n   *     }, function () {})\n   *     .add({\n   *         name: 'key3',\n   *         url: 'http://...'\n   *         onComplete: function () {}\n   *     })\n   *     .add({\n   *         url: 'https://...',\n   *         onComplete: function () {},\n   *         crossOrigin: true\n   *     })\n   *\n   *     // you can also pass an array of objects or urls or both\n   *     .add([\n   *         { name: 'key4', url: 'http://...', onComplete: function () {} },\n   *         { url: 'http://...', onComplete: function () {} },\n   *         'http://...'\n   *     ])\n   *\n   *     // and you can use both params and options\n   *     .add('key', 'http://...', { crossOrigin: true }, function () {})\n   *     .add('http://...', { crossOrigin: true }, function () {});\n   * ```\n   *\n   * @function\n   * @variation 1\n   * @param {string} name - The name of the resource to load.\n   * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n   * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n   * @return {this} Returns itself.\n   */\n\n  /**\n  * @function\n  * @variation 2\n  * @param {string} name - The name of the resource to load.\n  * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n  * @param {IAddOptions} [options] - The options for the load.\n  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n  * @return {this} Returns itself.\n  */\n\n  /**\n  * @function\n  * @variation 3\n  * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n  * @return {this} Returns itself.\n  */\n\n  /**\n  * @function\n  * @variation 4\n  * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n  * @param {IAddOptions} [options] - The options for the load.\n  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n  * @return {this} Returns itself.\n  */\n\n  /**\n  * @function\n  * @variation 5\n  * @param {IAddOptions} options - The options for the load. This object must contain a `url` property.\n  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n  * @return {this} Returns itself.\n  */\n\n  /**\n  * @function\n  * @variation 6\n  * @param {Array<IAddOptions|string>} resources - An array of resources to load, where each is\n  *      either an object with the options or a string url. If you pass an object, it must contain a `url` property.\n  * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n  * @return {this} Returns itself.\n  */\n\n\n  Loader.prototype.add = function add(name, url, options, cb) {\n    // special case of an array of objects or urls\n    if (Array.isArray(name)) {\n      for (var i = 0; i < name.length; ++i) {\n        this.add(name[i]);\n      }\n\n      return this;\n    } // if an object is passed instead of params\n\n\n    if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {\n      cb = url || name.callback || name.onComplete;\n      options = name;\n      url = name.url;\n      name = name.name || name.key || name.url;\n    } // case where no name is passed shift all args over by one.\n\n\n    if (typeof url !== 'string') {\n      cb = options;\n      options = url;\n      url = name;\n    } // now that we shifted make sure we have a proper url.\n\n\n    if (typeof url !== 'string') {\n      throw new Error('No url passed to add resource to loader.');\n    } // options are optional so people might pass a function and no options\n\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = null;\n    } // if loading already you can only add resources that have a parent.\n\n\n    if (this.loading && (!options || !options.parentResource)) {\n      throw new Error('Cannot add resources while the loader is running.');\n    } // check if resource already exists.\n\n\n    if (this.resources[name]) {\n      throw new Error('Resource named \"' + name + '\" already exists.');\n    } // add base url if this isn't an absolute url\n\n\n    url = this._prepareUrl(url); // create the store the resource\n\n    this.resources[name] = new _Resource.Resource(name, url, options);\n\n    if (typeof cb === 'function') {\n      this.resources[name].onAfterMiddleware.once(cb);\n    } // if actively loading, make sure to adjust progress chunks for that parent and its children\n\n\n    if (this.loading) {\n      var parent = options.parentResource;\n      var incompleteChildren = [];\n\n      for (var _i2 = 0; _i2 < parent.children.length; ++_i2) {\n        if (!parent.children[_i2].isComplete) {\n          incompleteChildren.push(parent.children[_i2]);\n        }\n      }\n\n      var fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent\n\n      var eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child\n\n      parent.children.push(this.resources[name]);\n      parent.progressChunk = eachChunk;\n\n      for (var _i3 = 0; _i3 < incompleteChildren.length; ++_i3) {\n        incompleteChildren[_i3].progressChunk = eachChunk;\n      }\n\n      this.resources[name].progressChunk = eachChunk;\n    } // add the resource to the queue\n\n\n    this._queue.push(this.resources[name]);\n\n    return this;\n  };\n  /* eslint-enable require-jsdoc,valid-jsdoc */\n\n  /**\n   * Sets up a middleware function that will run *before* the\n   * resource is loaded.\n   *\n   * @param {function} fn - The middleware function to register.\n   * @return {this} Returns itself.\n   */\n\n\n  Loader.prototype.pre = function pre(fn) {\n    this._beforeMiddleware.push(fn);\n\n    return this;\n  };\n  /**\n   * Sets up a middleware function that will run *after* the\n   * resource is loaded.\n   *\n   * @param {function} fn - The middleware function to register.\n   * @return {this} Returns itself.\n   */\n\n\n  Loader.prototype.use = function use(fn) {\n    this._afterMiddleware.push(fn);\n\n    return this;\n  };\n  /**\n   * Resets the queue of the loader to prepare for a new load.\n   *\n   * @return {this} Returns itself.\n   */\n\n\n  Loader.prototype.reset = function reset() {\n    this.progress = 0;\n    this.loading = false;\n\n    this._queue.kill();\n\n    this._queue.pause(); // abort all resource loads\n\n\n    for (var k in this.resources) {\n      var res = this.resources[k];\n\n      if (res._onLoadBinding) {\n        res._onLoadBinding.detach();\n      }\n\n      if (res.isLoading) {\n        res.abort();\n      }\n    }\n\n    this.resources = {};\n    return this;\n  };\n  /**\n   * Starts loading the queued resources.\n   *\n   * @param {function} [cb] - Optional callback that will be bound to the `complete` event.\n   * @return {this} Returns itself.\n   */\n\n\n  Loader.prototype.load = function load(cb) {\n    // register complete callback if they pass one\n    if (typeof cb === 'function') {\n      this.onComplete.once(cb);\n    } // if the queue has already started we are done here\n\n\n    if (this.loading) {\n      return this;\n    }\n\n    if (this._queue.idle()) {\n      this._onStart();\n\n      this._onComplete();\n    } else {\n      // distribute progress chunks\n      var numTasks = this._queue._tasks.length;\n      var chunk = MAX_PROGRESS / numTasks;\n\n      for (var i = 0; i < this._queue._tasks.length; ++i) {\n        this._queue._tasks[i].data.progressChunk = chunk;\n      } // notify we are starting\n\n\n      this._onStart(); // start loading\n\n\n      this._queue.resume();\n    }\n\n    return this;\n  };\n  /**\n   * The number of resources to load concurrently.\n   *\n   * @member {number}\n   * @default 10\n   */\n\n  /**\n   * Prepares a url for usage based on the configuration of this object\n   *\n   * @private\n   * @param {string} url - The url to prepare.\n   * @return {string} The prepared url.\n   */\n\n\n  Loader.prototype._prepareUrl = function _prepareUrl(url) {\n    var parsedUrl = (0, _parseUri2.default)(url, {\n      strictMode: true\n    });\n    var result = void 0; // absolute url, just use it as is.\n\n    if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) {\n      result = url;\n    } // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n    else if (this.baseUrl.length && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 && url.charAt(0) !== '/') {\n      result = this.baseUrl + '/' + url;\n    } else {\n      result = this.baseUrl + url;\n    } // if we need to add a default querystring, there is a bit more work\n\n\n    if (this.defaultQueryString) {\n      var hash = rgxExtractUrlHash.exec(result)[0];\n      result = result.substr(0, result.length - hash.length);\n\n      if (result.indexOf('?') !== -1) {\n        result += '&' + this.defaultQueryString;\n      } else {\n        result += '?' + this.defaultQueryString;\n      }\n\n      result += hash;\n    }\n\n    return result;\n  };\n  /**\n   * Loads a single resource.\n   *\n   * @private\n   * @param {Resource} resource - The resource to load.\n   * @param {function} dequeue - The function to call when we need to dequeue this item.\n   */\n\n\n  Loader.prototype._loadResource = function _loadResource(resource, dequeue) {\n    var _this2 = this;\n\n    resource._dequeue = dequeue; // run before middleware\n\n    async.eachSeries(this._beforeMiddleware, function (fn, next) {\n      fn.call(_this2, resource, function () {\n        // if the before middleware marks the resource as complete,\n        // break and don't process any more before middleware\n        next(resource.isComplete ? {} : null);\n      });\n    }, function () {\n      if (resource.isComplete) {\n        _this2._onLoad(resource);\n      } else {\n        resource._onLoadBinding = resource.onComplete.once(_this2._onLoad, _this2);\n        resource.load();\n      }\n    }, true);\n  };\n  /**\n   * Called once loading has started.\n   *\n   * @private\n   */\n\n\n  Loader.prototype._onStart = function _onStart() {\n    this.progress = 0;\n    this.loading = true;\n    this.onStart.dispatch(this);\n  };\n  /**\n   * Called once each resource has loaded.\n   *\n   * @private\n   */\n\n\n  Loader.prototype._onComplete = function _onComplete() {\n    this.progress = MAX_PROGRESS;\n    this.loading = false;\n    this.onComplete.dispatch(this, this.resources);\n  };\n  /**\n   * Called each time a resources is loaded.\n   *\n   * @private\n   * @param {Resource} resource - The resource that was loaded\n   */\n\n\n  Loader.prototype._onLoad = function _onLoad(resource) {\n    var _this3 = this;\n\n    resource._onLoadBinding = null; // remove this resource from the async queue, and add it to our list of resources that are being parsed\n\n    this._resourcesParsing.push(resource);\n\n    resource._dequeue(); // run all the after middleware for this resource\n\n\n    async.eachSeries(this._afterMiddleware, function (fn, next) {\n      fn.call(_this3, resource, next);\n    }, function () {\n      resource.onAfterMiddleware.dispatch(resource);\n      _this3.progress = Math.min(MAX_PROGRESS, _this3.progress + resource.progressChunk);\n\n      _this3.onProgress.dispatch(_this3, resource);\n\n      if (resource.error) {\n        _this3.onError.dispatch(resource.error, _this3, resource);\n      } else {\n        _this3.onLoad.dispatch(_this3, resource);\n      }\n\n      _this3._resourcesParsing.splice(_this3._resourcesParsing.indexOf(resource), 1); // do completion check\n\n\n      if (_this3._queue.idle() && _this3._resourcesParsing.length === 0) {\n        _this3._onComplete();\n      }\n    }, true);\n  };\n\n  _createClass(Loader, [{\n    key: 'concurrency',\n    get: function get() {\n      return this._queue.concurrency;\n    } // eslint-disable-next-line require-jsdoc\n    ,\n    set: function set(concurrency) {\n      this._queue.concurrency = concurrency;\n    }\n  }]);\n\n  return Loader;\n}();\n/**\n * A default array of middleware to run before loading each resource.\n * Each of these middlewares are added to any new Loader instances when they are created.\n *\n * @private\n * @member {function[]}\n */\n\n\nLoader._defaultBeforeMiddleware = [];\n/**\n * A default array of middleware to run after loading each resource.\n * Each of these middlewares are added to any new Loader instances when they are created.\n *\n * @private\n * @member {function[]}\n */\n\nLoader._defaultAfterMiddleware = [];\n/**\n * Sets up a middleware function that will run *before* the\n * resource is loaded.\n *\n * @static\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\n\nLoader.pre = function LoaderPreStatic(fn) {\n  Loader._defaultBeforeMiddleware.push(fn);\n\n  return Loader;\n};\n/**\n * Sets up a middleware function that will run *after* the\n * resource is loaded.\n *\n * @static\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\n\n\nLoader.use = function LoaderUseStatic(fn) {\n  Loader._defaultAfterMiddleware.push(fn);\n\n  return Loader;\n};","map":{"version":3,"sources":["../src/Loader.js"],"names":["async","MAX_PROGRESS","rgxExtractUrlHash","Loader","baseUrl","concurrency","Signal","i","add","name","url","options","cb","Array","Resource","parent","incompleteChildren","fullChunk","eachChunk","pre","fn","use","reset","res","load","numTasks","chunk","_prepareUrl","parsedUrl","strictMode","result","hash","_loadResource","resource","dequeue","next","_onStart","_onComplete","_onLoad","Math"],"mappings":"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","sourcesContent":["import Signal from 'mini-signals';\nimport parseUri from 'parse-uri';\nimport * as async from './async';\nimport { Resource } from './Resource';\n\n// some constants\nconst MAX_PROGRESS = 100;\nconst rgxExtractUrlHash = /(#[\\w-]+)?$/;\n\n/**\n * Manages the state and loading of multiple resources to load.\n *\n * @class\n */\nexport class Loader {\n    /**\n     * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.\n     * @param {number} [concurrency=10] - The number of resources to load concurrently.\n     */\n    constructor(baseUrl = '', concurrency = 10) {\n        /**\n         * The base url for all resources loaded by this loader.\n         *\n         * @member {string}\n         */\n        this.baseUrl = baseUrl;\n\n        /**\n         * The progress percent of the loader going through the queue.\n         *\n         * @member {number}\n         */\n        this.progress = 0;\n\n        /**\n         * Loading state of the loader, true if it is currently loading resources.\n         *\n         * @member {boolean}\n         */\n        this.loading = false;\n\n        /**\n         * A querystring to append to every URL added to the loader.\n         *\n         * This should be a valid query string *without* the question-mark (`?`). The loader will\n         * also *not* escape values for you. Make sure to escape your parameters with\n         * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.\n         *\n         * @example\n         * const loader = new Loader();\n         *\n         * loader.defaultQueryString = 'user=me&password=secret';\n         *\n         * // This will request 'image.png?user=me&password=secret'\n         * loader.add('image.png').load();\n         *\n         * loader.reset();\n         *\n         * // This will request 'image.png?v=1&user=me&password=secret'\n         * loader.add('iamge.png?v=1').load();\n         *\n         * @member {string}\n         */\n        this.defaultQueryString = '';\n\n        /**\n         * The middleware to run before loading each resource.\n         *\n         * @private\n         * @member {function[]}\n         */\n        this._beforeMiddleware = [];\n\n        /**\n         * The middleware to run after loading each resource.\n         *\n         * @private\n         * @member {function[]}\n         */\n        this._afterMiddleware = [];\n\n        /**\n         * The tracks the resources we are currently completing parsing for.\n         *\n         * @private\n         * @member {Resource[]}\n         */\n        this._resourcesParsing = [];\n\n        /**\n         * The `_loadResource` function bound with this object context.\n         *\n         * @private\n         * @member {function}\n         * @param {Resource} r - The resource to load\n         * @param {Function} d - The dequeue function\n         * @return {undefined}\n         */\n        this._boundLoadResource = (r, d) => this._loadResource(r, d);\n\n        /**\n         * The resources waiting to be loaded.\n         *\n         * @private\n         * @member {Resource[]}\n         */\n        this._queue = async.queue(this._boundLoadResource, concurrency);\n\n        this._queue.pause();\n\n        /**\n         * All the resources for this loader keyed by name.\n         *\n         * @member {object<string, Resource>}\n         */\n        this.resources = {};\n\n        /**\n         * Dispatched once per loaded or errored resource.\n         *\n         * The callback looks like {@link Loader.OnProgressSignal}.\n         *\n         * @member {Signal<Loader.OnProgressSignal>}\n         */\n        this.onProgress = new Signal();\n\n        /**\n         * Dispatched once per errored resource.\n         *\n         * The callback looks like {@link Loader.OnErrorSignal}.\n         *\n         * @member {Signal<Loader.OnErrorSignal>}\n         */\n        this.onError = new Signal();\n\n        /**\n         * Dispatched once per loaded resource.\n         *\n         * The callback looks like {@link Loader.OnLoadSignal}.\n         *\n         * @member {Signal<Loader.OnLoadSignal>}\n         */\n        this.onLoad = new Signal();\n\n        /**\n         * Dispatched when the loader begins to process the queue.\n         *\n         * The callback looks like {@link Loader.OnStartSignal}.\n         *\n         * @member {Signal<Loader.OnStartSignal>}\n         */\n        this.onStart = new Signal();\n\n        /**\n         * Dispatched when the queued resources all load.\n         *\n         * The callback looks like {@link Loader.OnCompleteSignal}.\n         *\n         * @member {Signal<Loader.OnCompleteSignal>}\n         */\n        this.onComplete = new Signal();\n\n        // Add default before middleware\n        for (let i = 0; i < Loader._defaultBeforeMiddleware.length; ++i) {\n            this.pre(Loader._defaultBeforeMiddleware[i]);\n        }\n\n        // Add default after middleware\n        for (let i = 0; i < Loader._defaultAfterMiddleware.length; ++i) {\n            this.use(Loader._defaultAfterMiddleware[i]);\n        }\n    }\n\n    /**\n     * When the progress changes the loader and resource are disaptched.\n     *\n     * @memberof Loader\n     * @callback OnProgressSignal\n     * @param {Loader} loader - The loader the progress is advancing on.\n     * @param {Resource} resource - The resource that has completed or failed to cause the progress to advance.\n     */\n\n    /**\n     * When an error occurrs the loader and resource are disaptched.\n     *\n     * @memberof Loader\n     * @callback OnErrorSignal\n     * @param {Loader} loader - The loader the error happened in.\n     * @param {Resource} resource - The resource that caused the error.\n     */\n\n    /**\n     * When a load completes the loader and resource are disaptched.\n     *\n     * @memberof Loader\n     * @callback OnLoadSignal\n     * @param {Loader} loader - The loader that laoded the resource.\n     * @param {Resource} resource - The resource that has completed loading.\n     */\n\n    /**\n     * When the loader starts loading resources it dispatches this callback.\n     *\n     * @memberof Loader\n     * @callback OnStartSignal\n     * @param {Loader} loader - The loader that has started loading resources.\n     */\n\n    /**\n     * When the loader completes loading resources it dispatches this callback.\n     *\n     * @memberof Loader\n     * @callback OnCompleteSignal\n     * @param {Loader} loader - The loader that has finished loading resources.\n     */\n\n    /**\n     * Options for a call to `.add()`.\n     *\n     * @see Loader#add\n     *\n     * @typedef {object} IAddOptions\n     * @property {string} [name] - The name of the resource to load, if not passed the url is used.\n     * @property {string} [key] - Alias for `name`.\n     * @property {string} [url] - The url for this resource, relative to the baseUrl of this loader.\n     * @property {string|boolean} [crossOrigin] - Is this request cross-origin? Default is to\n     *      determine automatically.\n     * @property {number} [timeout=0] - A timeout in milliseconds for the load. If the load takes\n     *      longer than this time it is cancelled and the load is considered a failure. If this value is\n     *      set to `0` then there is no explicit timeout.\n     * @property {Resource.LOAD_TYPE} [loadType=Resource.LOAD_TYPE.XHR] - How should this resource\n     *      be loaded?\n     * @property {Resource.XHR_RESPONSE_TYPE} [xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How\n     *      should the data being loaded be interpreted when using XHR?\n     * @property {Resource.OnCompleteSignal} [onComplete] - Callback to add an an onComplete signal istener.\n     * @property {Resource.OnCompleteSignal} [callback] - Alias for `onComplete`.\n     * @property {Resource.IMetadata} [metadata] - Extra configuration for middleware and the Resource object.\n     */\n\n    /* eslint-disable require-jsdoc,valid-jsdoc */\n    /**\n     * Adds a resource (or multiple resources) to the loader queue.\n     *\n     * This function can take a wide variety of different parameters. The only thing that is always\n     * required the url to load. All the following will work:\n     *\n     * ```js\n     * loader\n     *     // normal param syntax\n     *     .add('key', 'http://...', function () {})\n     *     .add('http://...', function () {})\n     *     .add('http://...')\n     *\n     *     // object syntax\n     *     .add({\n     *         name: 'key2',\n     *         url: 'http://...'\n     *     }, function () {})\n     *     .add({\n     *         url: 'http://...'\n     *     }, function () {})\n     *     .add({\n     *         name: 'key3',\n     *         url: 'http://...'\n     *         onComplete: function () {}\n     *     })\n     *     .add({\n     *         url: 'https://...',\n     *         onComplete: function () {},\n     *         crossOrigin: true\n     *     })\n     *\n     *     // you can also pass an array of objects or urls or both\n     *     .add([\n     *         { name: 'key4', url: 'http://...', onComplete: function () {} },\n     *         { url: 'http://...', onComplete: function () {} },\n     *         'http://...'\n     *     ])\n     *\n     *     // and you can use both params and options\n     *     .add('key', 'http://...', { crossOrigin: true }, function () {})\n     *     .add('http://...', { crossOrigin: true }, function () {});\n     * ```\n     *\n     * @function\n     * @variation 1\n     * @param {string} name - The name of the resource to load.\n     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 2\n     * @param {string} name - The name of the resource to load.\n     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n     * @param {IAddOptions} [options] - The options for the load.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 3\n     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 4\n     * @param {string} url - The url for this resource, relative to the baseUrl of this loader.\n     * @param {IAddOptions} [options] - The options for the load.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 5\n     * @param {IAddOptions} options - The options for the load. This object must contain a `url` property.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     *//**\n     * @function\n     * @variation 6\n     * @param {Array<IAddOptions|string>} resources - An array of resources to load, where each is\n     *      either an object with the options or a string url. If you pass an object, it must contain a `url` property.\n     * @param {Resource.OnCompleteSignal} [callback] - Function to call when this specific resource completes loading.\n     * @return {this} Returns itself.\n     */\n    add(name, url, options, cb) {\n        // special case of an array of objects or urls\n        if (Array.isArray(name)) {\n            for (let i = 0; i < name.length; ++i) {\n                this.add(name[i]);\n            }\n\n            return this;\n        }\n\n        // if an object is passed instead of params\n        if (typeof name === 'object') {\n            cb = url || name.callback || name.onComplete;\n            options = name;\n            url = name.url;\n            name = name.name || name.key || name.url;\n        }\n\n        // case where no name is passed shift all args over by one.\n        if (typeof url !== 'string') {\n            cb = options;\n            options = url;\n            url = name;\n        }\n\n        // now that we shifted make sure we have a proper url.\n        if (typeof url !== 'string') {\n            throw new Error('No url passed to add resource to loader.');\n        }\n\n        // options are optional so people might pass a function and no options\n        if (typeof options === 'function') {\n            cb = options;\n            options = null;\n        }\n\n        // if loading already you can only add resources that have a parent.\n        if (this.loading && (!options || !options.parentResource)) {\n            throw new Error('Cannot add resources while the loader is running.');\n        }\n\n        // check if resource already exists.\n        if (this.resources[name]) {\n            throw new Error(`Resource named \"${name}\" already exists.`);\n        }\n\n        // add base url if this isn't an absolute url\n        url = this._prepareUrl(url);\n\n        // create the store the resource\n        this.resources[name] = new Resource(name, url, options);\n\n        if (typeof cb === 'function') {\n            this.resources[name].onAfterMiddleware.once(cb);\n        }\n\n        // if actively loading, make sure to adjust progress chunks for that parent and its children\n        if (this.loading) {\n            const parent = options.parentResource;\n            const incompleteChildren = [];\n\n            for (let i = 0; i < parent.children.length; ++i) {\n                if (!parent.children[i].isComplete) {\n                    incompleteChildren.push(parent.children[i]);\n                }\n            }\n\n            const fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent\n            const eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child\n\n            parent.children.push(this.resources[name]);\n            parent.progressChunk = eachChunk;\n\n            for (let i = 0; i < incompleteChildren.length; ++i) {\n                incompleteChildren[i].progressChunk = eachChunk;\n            }\n\n            this.resources[name].progressChunk = eachChunk;\n        }\n\n        // add the resource to the queue\n        this._queue.push(this.resources[name]);\n\n        return this;\n    }\n    /* eslint-enable require-jsdoc,valid-jsdoc */\n\n    /**\n     * Sets up a middleware function that will run *before* the\n     * resource is loaded.\n     *\n     * @param {function} fn - The middleware function to register.\n     * @return {this} Returns itself.\n     */\n    pre(fn) {\n        this._beforeMiddleware.push(fn);\n\n        return this;\n    }\n\n    /**\n     * Sets up a middleware function that will run *after* the\n     * resource is loaded.\n     *\n     * @param {function} fn - The middleware function to register.\n     * @return {this} Returns itself.\n     */\n    use(fn) {\n        this._afterMiddleware.push(fn);\n\n        return this;\n    }\n\n    /**\n     * Resets the queue of the loader to prepare for a new load.\n     *\n     * @return {this} Returns itself.\n     */\n    reset() {\n        this.progress = 0;\n        this.loading = false;\n\n        this._queue.kill();\n        this._queue.pause();\n\n        // abort all resource loads\n        for (const k in this.resources) {\n            const res = this.resources[k];\n\n            if (res._onLoadBinding) {\n                res._onLoadBinding.detach();\n            }\n\n            if (res.isLoading) {\n                res.abort();\n            }\n        }\n\n        this.resources = {};\n\n        return this;\n    }\n\n    /**\n     * Starts loading the queued resources.\n     *\n     * @param {function} [cb] - Optional callback that will be bound to the `complete` event.\n     * @return {this} Returns itself.\n     */\n    load(cb) {\n        // register complete callback if they pass one\n        if (typeof cb === 'function') {\n            this.onComplete.once(cb);\n        }\n\n        // if the queue has already started we are done here\n        if (this.loading) {\n            return this;\n        }\n\n        if (this._queue.idle()) {\n            this._onStart();\n            this._onComplete();\n        }\n        else {\n            // distribute progress chunks\n            const numTasks = this._queue._tasks.length;\n            const chunk = MAX_PROGRESS / numTasks;\n\n            for (let i = 0; i < this._queue._tasks.length; ++i) {\n                this._queue._tasks[i].data.progressChunk = chunk;\n            }\n\n            // notify we are starting\n            this._onStart();\n\n            // start loading\n            this._queue.resume();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of resources to load concurrently.\n     *\n     * @member {number}\n     * @default 10\n     */\n    get concurrency() {\n        return this._queue.concurrency;\n    }\n    // eslint-disable-next-line require-jsdoc\n    set concurrency(concurrency) {\n        this._queue.concurrency = concurrency;\n    }\n\n    /**\n     * Prepares a url for usage based on the configuration of this object\n     *\n     * @private\n     * @param {string} url - The url to prepare.\n     * @return {string} The prepared url.\n     */\n    _prepareUrl(url) {\n        const parsedUrl = parseUri(url, { strictMode: true });\n        let result;\n\n        // absolute url, just use it as is.\n        if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) {\n            result = url;\n        }\n        // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n        else if (this.baseUrl.length\n            && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1\n            && url.charAt(0) !== '/'\n        ) {\n            result = `${this.baseUrl}/${url}`;\n        }\n        else {\n            result = this.baseUrl + url;\n        }\n\n        // if we need to add a default querystring, there is a bit more work\n        if (this.defaultQueryString) {\n            const hash = rgxExtractUrlHash.exec(result)[0];\n\n            result = result.substr(0, result.length - hash.length);\n\n            if (result.indexOf('?') !== -1) {\n                result += `&${this.defaultQueryString}`;\n            }\n            else {\n                result += `?${this.defaultQueryString}`;\n            }\n\n            result += hash;\n        }\n\n        return result;\n    }\n\n    /**\n     * Loads a single resource.\n     *\n     * @private\n     * @param {Resource} resource - The resource to load.\n     * @param {function} dequeue - The function to call when we need to dequeue this item.\n     */\n    _loadResource(resource, dequeue) {\n        resource._dequeue = dequeue;\n\n        // run before middleware\n        async.eachSeries(\n            this._beforeMiddleware,\n            (fn, next) => {\n                fn.call(this, resource, () => {\n                    // if the before middleware marks the resource as complete,\n                    // break and don't process any more before middleware\n                    next(resource.isComplete ? {} : null);\n                });\n            },\n            () => {\n                if (resource.isComplete) {\n                    this._onLoad(resource);\n                }\n                else {\n                    resource._onLoadBinding = resource.onComplete.once(this._onLoad, this);\n                    resource.load();\n                }\n            },\n            true\n        );\n    }\n\n    /**\n     * Called once loading has started.\n     *\n     * @private\n     */\n    _onStart() {\n        this.progress = 0;\n        this.loading = true;\n        this.onStart.dispatch(this);\n    }\n\n    /**\n     * Called once each resource has loaded.\n     *\n     * @private\n     */\n    _onComplete() {\n        this.progress = MAX_PROGRESS;\n        this.loading = false;\n        this.onComplete.dispatch(this, this.resources);\n    }\n\n    /**\n     * Called each time a resources is loaded.\n     *\n     * @private\n     * @param {Resource} resource - The resource that was loaded\n     */\n    _onLoad(resource) {\n        resource._onLoadBinding = null;\n\n        // remove this resource from the async queue, and add it to our list of resources that are being parsed\n        this._resourcesParsing.push(resource);\n        resource._dequeue();\n\n        // run all the after middleware for this resource\n        async.eachSeries(\n            this._afterMiddleware,\n            (fn, next) => {\n                fn.call(this, resource, next);\n            },\n            () => {\n                resource.onAfterMiddleware.dispatch(resource);\n\n                this.progress = Math.min(MAX_PROGRESS, this.progress + resource.progressChunk);\n                this.onProgress.dispatch(this, resource);\n\n                if (resource.error) {\n                    this.onError.dispatch(resource.error, this, resource);\n                }\n                else {\n                    this.onLoad.dispatch(this, resource);\n                }\n\n                this._resourcesParsing.splice(this._resourcesParsing.indexOf(resource), 1);\n\n                // do completion check\n                if (this._queue.idle() && this._resourcesParsing.length === 0) {\n                    this._onComplete();\n                }\n            },\n            true\n        );\n    }\n}\n\n/**\n * A default array of middleware to run before loading each resource.\n * Each of these middlewares are added to any new Loader instances when they are created.\n *\n * @private\n * @member {function[]}\n */\nLoader._defaultBeforeMiddleware = [];\n\n/**\n * A default array of middleware to run after loading each resource.\n * Each of these middlewares are added to any new Loader instances when they are created.\n *\n * @private\n * @member {function[]}\n */\nLoader._defaultAfterMiddleware = [];\n\n/**\n * Sets up a middleware function that will run *before* the\n * resource is loaded.\n *\n * @static\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\nLoader.pre = function LoaderPreStatic(fn) {\n    Loader._defaultBeforeMiddleware.push(fn);\n\n    return Loader;\n};\n\n/**\n * Sets up a middleware function that will run *after* the\n * resource is loaded.\n *\n * @static\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\nLoader.use = function LoaderUseStatic(fn) {\n    Loader._defaultAfterMiddleware.push(fn);\n\n    return Loader;\n};\n"]},"metadata":{},"sourceType":"script"}