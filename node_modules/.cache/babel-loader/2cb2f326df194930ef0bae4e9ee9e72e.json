{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _WebGLManager2 = require('./WebGLManager');\n\nvar _WebGLManager3 = _interopRequireDefault(_WebGLManager2);\n\nvar _RenderTarget = require('../utils/RenderTarget');\n\nvar _RenderTarget2 = _interopRequireDefault(_RenderTarget);\n\nvar _Quad = require('../utils/Quad');\n\nvar _Quad2 = _interopRequireDefault(_Quad);\n\nvar _math = require('../../../math');\n\nvar _Shader = require('../../../Shader');\n\nvar _Shader2 = _interopRequireDefault(_Shader);\n\nvar _filterTransforms = require('../filters/filterTransforms');\n\nvar filterTransforms = _interopRequireWildcard(_filterTransforms);\n\nvar _bitTwiddle = require('bit-twiddle');\n\nvar _bitTwiddle2 = _interopRequireDefault(_bitTwiddle);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * @ignore\n * @class\n */\n\n\nvar FilterState = function () {\n  /**\n   *\n   */\n  function FilterState() {\n    _classCallCheck(this, FilterState);\n\n    this.renderTarget = null;\n    this.target = null;\n    this.resolution = 1; // those three objects are used only for root\n    // re-assigned for everything else\n\n    this.sourceFrame = new _math.Rectangle();\n    this.destinationFrame = new _math.Rectangle();\n    this.filters = [];\n  }\n  /**\n   * clears the state\n   */\n\n\n  FilterState.prototype.clear = function clear() {\n    this.filters = null;\n    this.target = null;\n    this.renderTarget = null;\n  };\n\n  return FilterState;\n}();\n\nvar screenKey = 'screen';\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.WebGLManager\n */\n\nvar FilterManager = function (_WebGLManager) {\n  _inherits(FilterManager, _WebGLManager);\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.\n   */\n\n\n  function FilterManager(renderer) {\n    _classCallCheck(this, FilterManager);\n\n    var _this = _possibleConstructorReturn(this, _WebGLManager.call(this, renderer));\n\n    _this.gl = _this.renderer.gl; // know about sprites!\n\n    _this.quad = new _Quad2.default(_this.gl, renderer.state.attribState);\n    _this.shaderCache = {}; // todo add default!\n\n    _this.pool = {};\n    _this.filterData = null;\n    _this.managedFilters = [];\n\n    _this.renderer.on('prerender', _this.onPrerender, _this);\n\n    _this._screenWidth = renderer.view.width;\n    _this._screenHeight = renderer.view.height;\n    return _this;\n  }\n  /**\n   * Adds a new filter to the manager.\n   *\n   * @param {PIXI.DisplayObject} target - The target of the filter to render.\n   * @param {PIXI.Filter[]} filters - The filters to apply.\n   */\n\n\n  FilterManager.prototype.pushFilter = function pushFilter(target, filters) {\n    var renderer = this.renderer;\n    var filterData = this.filterData;\n\n    if (!filterData) {\n      filterData = this.renderer._activeRenderTarget.filterStack; // add new stack\n\n      var filterState = new FilterState();\n      filterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;\n      filterState.renderTarget = renderer._activeRenderTarget;\n      this.renderer._activeRenderTarget.filterData = filterData = {\n        index: 0,\n        stack: [filterState]\n      };\n      this.filterData = filterData;\n    } // get the current filter state..\n\n\n    var currentState = filterData.stack[++filterData.index];\n    var renderTargetFrame = filterData.stack[0].destinationFrame;\n\n    if (!currentState) {\n      currentState = filterData.stack[filterData.index] = new FilterState();\n    }\n\n    var fullScreen = target.filterArea && target.filterArea.x === 0 && target.filterArea.y === 0 && target.filterArea.width === renderer.screen.width && target.filterArea.height === renderer.screen.height; // for now we go off the filter of the first resolution..\n\n    var resolution = filters[0].resolution;\n    var padding = filters[0].padding | 0;\n    var targetBounds = fullScreen ? renderer.screen : target.filterArea || target.getBounds(true);\n    var sourceFrame = currentState.sourceFrame;\n    var destinationFrame = currentState.destinationFrame;\n    sourceFrame.x = (targetBounds.x * resolution | 0) / resolution;\n    sourceFrame.y = (targetBounds.y * resolution | 0) / resolution;\n    sourceFrame.width = (targetBounds.width * resolution | 0) / resolution;\n    sourceFrame.height = (targetBounds.height * resolution | 0) / resolution;\n\n    if (!fullScreen) {\n      if (filterData.stack[0].renderTarget.transform) {//\n        // TODO we should fit the rect around the transform..\n      } else if (filters[0].autoFit) {\n        sourceFrame.fit(renderTargetFrame);\n      } // lets apply the padding After we fit the element to the screen.\n      // this should stop the strange side effects that can occur when cropping to the edges\n\n\n      sourceFrame.pad(padding);\n    }\n\n    destinationFrame.width = sourceFrame.width;\n    destinationFrame.height = sourceFrame.height; // lets play the padding after we fit the element to the screen.\n    // this should stop the strange side effects that can occur when cropping to the edges\n\n    var renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);\n    currentState.target = target;\n    currentState.filters = filters;\n    currentState.resolution = resolution;\n    currentState.renderTarget = renderTarget; // bind the render target to draw the shape in the top corner..\n\n    renderTarget.setFrame(destinationFrame, sourceFrame); // bind the render target\n\n    renderer.bindRenderTarget(renderTarget);\n    renderTarget.clear();\n  };\n  /**\n   * Pops off the filter and applies it.\n   *\n   */\n\n\n  FilterManager.prototype.popFilter = function popFilter() {\n    var filterData = this.filterData;\n    var lastState = filterData.stack[filterData.index - 1];\n    var currentState = filterData.stack[filterData.index];\n    this.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();\n    var filters = currentState.filters;\n\n    if (filters.length === 1) {\n      filters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false, currentState);\n      this.freePotRenderTarget(currentState.renderTarget);\n    } else {\n      var flip = currentState.renderTarget;\n      var flop = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, currentState.resolution);\n      flop.setFrame(currentState.destinationFrame, currentState.sourceFrame); // finally lets clear the render target before drawing to it..\n\n      flop.clear();\n      var i = 0;\n\n      for (i = 0; i < filters.length - 1; ++i) {\n        filters[i].apply(this, flip, flop, true, currentState);\n        var t = flip;\n        flip = flop;\n        flop = t;\n      }\n\n      filters[i].apply(this, flip, lastState.renderTarget, false, currentState);\n      this.freePotRenderTarget(flip);\n      this.freePotRenderTarget(flop);\n    }\n\n    currentState.clear();\n    filterData.index--;\n\n    if (filterData.index === 0) {\n      this.filterData = null;\n    }\n  };\n  /**\n   * Draws a filter.\n   *\n   * @param {PIXI.Filter} filter - The filter to draw.\n   * @param {PIXI.RenderTarget} input - The input render target.\n   * @param {PIXI.RenderTarget} output - The target to output to.\n   * @param {boolean} clear - Should the output be cleared before rendering to it\n   */\n\n\n  FilterManager.prototype.applyFilter = function applyFilter(filter, input, output, clear) {\n    var renderer = this.renderer;\n    var gl = renderer.gl;\n    var shader = filter.glShaders[renderer.CONTEXT_UID]; // caching..\n\n    if (!shader) {\n      if (filter.glShaderKey) {\n        shader = this.shaderCache[filter.glShaderKey];\n\n        if (!shader) {\n          shader = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);\n          filter.glShaders[renderer.CONTEXT_UID] = this.shaderCache[filter.glShaderKey] = shader;\n          this.managedFilters.push(filter);\n        }\n      } else {\n        shader = filter.glShaders[renderer.CONTEXT_UID] = new _Shader2.default(this.gl, filter.vertexSrc, filter.fragmentSrc);\n        this.managedFilters.push(filter);\n      } // TODO - this only needs to be done once?\n\n\n      renderer.bindVao(null);\n      this.quad.initVao(shader);\n    }\n\n    renderer.bindVao(this.quad.vao);\n    renderer.bindRenderTarget(output);\n\n    if (clear) {\n      gl.disable(gl.SCISSOR_TEST);\n      renderer.clear(); // [1, 1, 1, 1]);\n\n      gl.enable(gl.SCISSOR_TEST);\n    } // in case the render target is being masked using a scissor rect\n\n\n    if (output === renderer.maskManager.scissorRenderTarget) {\n      renderer.maskManager.pushScissorMask(null, renderer.maskManager.scissorData);\n    }\n\n    renderer.bindShader(shader); // free unit 0 for us, doesn't matter what was there\n    // don't try to restore it, because syncUniforms can upload it to another slot\n    // and it'll be a problem\n\n    var tex = this.renderer.emptyTextures[0];\n    this.renderer.boundTextures[0] = tex; // this syncs the PixiJS filters  uniforms with glsl uniforms\n\n    this.syncUniforms(shader, filter);\n    renderer.state.setBlendMode(filter.blendMode);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, input.texture.texture);\n    this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);\n  };\n  /**\n   * Uploads the uniforms of the filter.\n   *\n   * @param {GLShader} shader - The underlying gl shader.\n   * @param {PIXI.Filter} filter - The filter we are synchronizing.\n   */\n\n\n  FilterManager.prototype.syncUniforms = function syncUniforms(shader, filter) {\n    var uniformData = filter.uniformData;\n    var uniforms = filter.uniforms; // 0 is reserved for the PixiJS texture so we start at 1!\n\n    var textureCount = 1;\n    var currentState = void 0; // filterArea and filterClamp that are handled by FilterManager directly\n    // they must not appear in uniformData\n\n    if (shader.uniforms.filterArea) {\n      currentState = this.filterData.stack[this.filterData.index];\n      var filterArea = shader.uniforms.filterArea;\n      filterArea[0] = currentState.renderTarget.size.width;\n      filterArea[1] = currentState.renderTarget.size.height;\n      filterArea[2] = currentState.sourceFrame.x;\n      filterArea[3] = currentState.sourceFrame.y;\n      shader.uniforms.filterArea = filterArea;\n    } // use this to clamp displaced texture coords so they belong to filterArea\n    // see displacementFilter fragment shader for an example\n\n\n    if (shader.uniforms.filterClamp) {\n      currentState = currentState || this.filterData.stack[this.filterData.index];\n      var filterClamp = shader.uniforms.filterClamp;\n      filterClamp[0] = 0;\n      filterClamp[1] = 0;\n      filterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;\n      filterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;\n      shader.uniforms.filterClamp = filterClamp;\n    } // TODO Caching layer..\n\n\n    for (var i in uniformData) {\n      if (!shader.uniforms.data[i]) {\n        continue;\n      }\n\n      var type = uniformData[i].type;\n\n      if (type === 'sampler2d' && uniforms[i] !== 0) {\n        if (uniforms[i].baseTexture) {\n          shader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount);\n        } else {\n          shader.uniforms[i] = textureCount; // TODO\n          // this is helpful as renderTargets can also be set.\n          // Although thinking about it, we could probably\n          // make the filter texture cache return a RenderTexture\n          // rather than a renderTarget\n\n          var gl = this.renderer.gl;\n          this.renderer.boundTextures[textureCount] = this.renderer.emptyTextures[textureCount];\n          gl.activeTexture(gl.TEXTURE0 + textureCount);\n          uniforms[i].texture.bind();\n        }\n\n        textureCount++;\n      } else if (type === 'mat3') {\n        // check if its PixiJS matrix..\n        if (uniforms[i].a !== undefined) {\n          shader.uniforms[i] = uniforms[i].toArray(true);\n        } else {\n          shader.uniforms[i] = uniforms[i];\n        }\n      } else if (type === 'vec2') {\n        // check if its a point..\n        if (uniforms[i].x !== undefined) {\n          var val = shader.uniforms[i] || new Float32Array(2);\n          val[0] = uniforms[i].x;\n          val[1] = uniforms[i].y;\n          shader.uniforms[i] = val;\n        } else {\n          shader.uniforms[i] = uniforms[i];\n        }\n      } else if (type === 'float') {\n        if (shader.uniforms.data[i].value !== uniformData[i]) {\n          shader.uniforms[i] = uniforms[i];\n        }\n      } else {\n        shader.uniforms[i] = uniforms[i];\n      }\n    }\n  };\n  /**\n   * Gets a render target from the pool, or creates a new one.\n   *\n   * @param {boolean} clear - Should we clear the render texture when we get it?\n   * @param {number} resolution - The resolution of the target.\n   * @return {PIXI.RenderTarget} The new render target\n   */\n\n\n  FilterManager.prototype.getRenderTarget = function getRenderTarget(clear, resolution) {\n    var currentState = this.filterData.stack[this.filterData.index];\n    var renderTarget = this.getPotRenderTarget(this.renderer.gl, currentState.sourceFrame.width, currentState.sourceFrame.height, resolution || currentState.resolution);\n    renderTarget.setFrame(currentState.destinationFrame, currentState.sourceFrame);\n    return renderTarget;\n  };\n  /**\n   * Returns a render target to the pool.\n   *\n   * @param {PIXI.RenderTarget} renderTarget - The render target to return.\n   */\n\n\n  FilterManager.prototype.returnRenderTarget = function returnRenderTarget(renderTarget) {\n    this.freePotRenderTarget(renderTarget);\n  };\n  /**\n   * Calculates the mapped matrix.\n   *\n   * TODO playing around here.. this is temporary - (will end up in the shader)\n   * this returns a matrix that will normalise map filter cords in the filter to screen space\n   *\n   * @param {PIXI.Matrix} outputMatrix - the matrix to output to.\n   * @return {PIXI.Matrix} The mapped matrix.\n   */\n\n\n  FilterManager.prototype.calculateScreenSpaceMatrix = function calculateScreenSpaceMatrix(outputMatrix) {\n    var currentState = this.filterData.stack[this.filterData.index];\n    return filterTransforms.calculateScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size);\n  };\n  /**\n   * Multiply vTextureCoord to this matrix to achieve (0,0,1,1) for filterArea\n   *\n   * @param {PIXI.Matrix} outputMatrix - The matrix to output to.\n   * @return {PIXI.Matrix} The mapped matrix.\n   */\n\n\n  FilterManager.prototype.calculateNormalizedScreenSpaceMatrix = function calculateNormalizedScreenSpaceMatrix(outputMatrix) {\n    var currentState = this.filterData.stack[this.filterData.index];\n    return filterTransforms.calculateNormalizedScreenSpaceMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, currentState.destinationFrame);\n  };\n  /**\n   * This will map the filter coord so that a texture can be used based on the transform of a sprite\n   *\n   * @param {PIXI.Matrix} outputMatrix - The matrix to output to.\n   * @param {PIXI.Sprite} sprite - The sprite to map to.\n   * @return {PIXI.Matrix} The mapped matrix.\n   */\n\n\n  FilterManager.prototype.calculateSpriteMatrix = function calculateSpriteMatrix(outputMatrix, sprite) {\n    var currentState = this.filterData.stack[this.filterData.index];\n    return filterTransforms.calculateSpriteMatrix(outputMatrix, currentState.sourceFrame, currentState.renderTarget.size, sprite);\n  };\n  /**\n   * Destroys this Filter Manager.\n   *\n   * @param {boolean} [contextLost=false] context was lost, do not free shaders\n   *\n   */\n\n\n  FilterManager.prototype.destroy = function destroy() {\n    var contextLost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var renderer = this.renderer;\n    var filters = this.managedFilters;\n    renderer.off('prerender', this.onPrerender, this);\n\n    for (var i = 0; i < filters.length; i++) {\n      if (!contextLost) {\n        filters[i].glShaders[renderer.CONTEXT_UID].destroy();\n      }\n\n      delete filters[i].glShaders[renderer.CONTEXT_UID];\n    }\n\n    this.shaderCache = {};\n\n    if (!contextLost) {\n      this.emptyPool();\n    } else {\n      this.pool = {};\n    }\n  };\n  /**\n   * Gets a Power-of-Two render texture.\n   *\n   * TODO move to a separate class could be on renderer?\n   * also - could cause issue with multiple contexts?\n   *\n   * @private\n   * @param {WebGLRenderingContext} gl - The webgl rendering context\n   * @param {number} minWidth - The minimum width of the render target.\n   * @param {number} minHeight - The minimum height of the render target.\n   * @param {number} resolution - The resolution of the render target.\n   * @return {PIXI.RenderTarget} The new render target.\n   */\n\n\n  FilterManager.prototype.getPotRenderTarget = function getPotRenderTarget(gl, minWidth, minHeight, resolution) {\n    var key = screenKey;\n    minWidth *= resolution;\n    minHeight *= resolution;\n\n    if (minWidth !== this._screenWidth || minHeight !== this._screenHeight) {\n      // TODO you could return a bigger texture if there is not one in the pool?\n      minWidth = _bitTwiddle2.default.nextPow2(minWidth);\n      minHeight = _bitTwiddle2.default.nextPow2(minHeight);\n      key = (minWidth & 0xFFFF) << 16 | minHeight & 0xFFFF;\n    }\n\n    if (!this.pool[key]) {\n      this.pool[key] = [];\n    }\n\n    var renderTarget = this.pool[key].pop(); // creating render target will cause texture to be bound!\n\n    if (!renderTarget) {\n      // temporary bypass cache..\n      var tex = this.renderer.boundTextures[0];\n      gl.activeTexture(gl.TEXTURE0); // internally - this will cause a texture to be bound..\n\n      renderTarget = new _RenderTarget2.default(gl, minWidth, minHeight, null, 1); // set the current one back\n\n      gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);\n    } // manually tweak the resolution...\n    // this will not modify the size of the frame buffer, just its resolution.\n\n\n    renderTarget.resolution = resolution;\n    renderTarget.defaultFrame.width = renderTarget.size.width = minWidth / resolution;\n    renderTarget.defaultFrame.height = renderTarget.size.height = minHeight / resolution;\n    renderTarget.filterPoolKey = key;\n    return renderTarget;\n  };\n  /**\n   * Empties the texture pool.\n   *\n   */\n\n\n  FilterManager.prototype.emptyPool = function emptyPool() {\n    for (var i in this.pool) {\n      var textures = this.pool[i];\n\n      if (textures) {\n        for (var j = 0; j < textures.length; j++) {\n          textures[j].destroy(true);\n        }\n      }\n    }\n\n    this.pool = {};\n  };\n  /**\n   * Frees a render target back into the pool.\n   *\n   * @param {PIXI.RenderTarget} renderTarget - The renderTarget to free\n   */\n\n\n  FilterManager.prototype.freePotRenderTarget = function freePotRenderTarget(renderTarget) {\n    this.pool[renderTarget.filterPoolKey].push(renderTarget);\n  };\n  /**\n   * Called before the renderer starts rendering.\n   *\n   */\n\n\n  FilterManager.prototype.onPrerender = function onPrerender() {\n    if (this._screenWidth !== this.renderer.view.width || this._screenHeight !== this.renderer.view.height) {\n      this._screenWidth = this.renderer.view.width;\n      this._screenHeight = this.renderer.view.height;\n      var textures = this.pool[screenKey];\n\n      if (textures) {\n        for (var j = 0; j < textures.length; j++) {\n          textures[j].destroy(true);\n        }\n      }\n\n      this.pool[screenKey] = [];\n    }\n  };\n\n  return FilterManager;\n}(_WebGLManager3.default);\n\nexports.default = FilterManager;","map":{"version":3,"sources":["../../../../../src/core/renderers/webgl/managers/FilterManager.js"],"names":["filterTransforms","FilterState","clear","screenKey","FilterManager","renderer","pushFilter","target","filters","filterData","filterState","index","stack","currentState","renderTargetFrame","fullScreen","resolution","padding","targetBounds","sourceFrame","destinationFrame","renderTarget","popFilter","lastState","flip","flop","i","t","applyFilter","filter","input","output","gl","shader","tex","syncUniforms","uniformData","uniforms","textureCount","filterArea","filterClamp","type","val","getRenderTarget","returnRenderTarget","calculateScreenSpaceMatrix","outputMatrix","calculateNormalizedScreenSpaceMatrix","calculateSpriteMatrix","sprite","destroy","contextLost","getPotRenderTarget","minWidth","minHeight","key","emptyPool","textures","j","freePotRenderTarget","onPrerender"],"mappings":"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","sourcesContent":["import WebGLManager from './WebGLManager';\nimport RenderTarget from '../utils/RenderTarget';\nimport Quad from '../utils/Quad';\nimport { Rectangle } from '../../../math';\nimport Shader from '../../../Shader';\nimport * as filterTransforms from '../filters/filterTransforms';\nimport bitTwiddle from 'bit-twiddle';\n\n/**\n * @ignore\n * @class\n */\nclass FilterState\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        this.renderTarget = null;\n        this.target = null;\n        this.resolution = 1;\n\n        // those three objects are used only for root\n        // re-assigned for everything else\n        this.sourceFrame = new Rectangle();\n        this.destinationFrame = new Rectangle();\n        this.filters = [];\n    }\n\n    /**\n     * clears the state\n     */\n    clear()\n    {\n        this.filters = null;\n        this.target = null;\n        this.renderTarget = null;\n    }\n}\n\nconst screenKey = 'screen';\n\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.WebGLManager\n */\nexport default class FilterManager extends WebGLManager\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.gl = this.renderer.gl;\n        // know about sprites!\n        this.quad = new Quad(this.gl, renderer.state.attribState);\n\n        this.shaderCache = {};\n        // todo add default!\n        this.pool = {};\n\n        this.filterData = null;\n\n        this.managedFilters = [];\n\n        this.renderer.on('prerender', this.onPrerender, this);\n\n        this._screenWidth = renderer.view.width;\n        this._screenHeight = renderer.view.height;\n    }\n\n    /**\n     * Adds a new filter to the manager.\n     *\n     * @param {PIXI.DisplayObject} target - The target of the filter to render.\n     * @param {PIXI.Filter[]} filters - The filters to apply.\n     */\n    pushFilter(target, filters)\n    {\n        const renderer = this.renderer;\n\n        let filterData = this.filterData;\n\n        if (!filterData)\n        {\n            filterData = this.renderer._activeRenderTarget.filterStack;\n\n            // add new stack\n            const filterState = new FilterState();\n\n            filterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;\n            filterState.renderTarget = renderer._activeRenderTarget;\n\n            this.renderer._activeRenderTarget.filterData = filterData = {\n                index: 0,\n                stack: [filterState],\n            };\n\n            this.filterData = filterData;\n        }\n\n        // get the current filter state..\n        let currentState = filterData.stack[++filterData.index];\n        const renderTargetFrame = filterData.stack[0].destinationFrame;\n\n        if (!currentState)\n        {\n            currentState = filterData.stack[filterData.index] = new FilterState();\n        }\n\n        const fullScreen = target.filterArea\n            && target.filterArea.x === 0\n            && target.filterArea.y === 0\n            && target.filterArea.width === renderer.screen.width\n            && target.filterArea.height === renderer.screen.height;\n\n        // for now we go off the filter of the first resolution..\n        const resolution = filters[0].resolution;\n        const padding = filters[0].padding | 0;\n        const targetBounds = fullScreen ? renderer.screen : (target.filterArea || target.getBounds(true));\n        const sourceFrame = currentState.sourceFrame;\n        const destinationFrame = currentState.destinationFrame;\n\n        sourceFrame.x = ((targetBounds.x * resolution) | 0) / resolution;\n        sourceFrame.y = ((targetBounds.y * resolution) | 0) / resolution;\n        sourceFrame.width = ((targetBounds.width * resolution) | 0) / resolution;\n        sourceFrame.height = ((targetBounds.height * resolution) | 0) / resolution;\n\n        if (!fullScreen)\n        {\n            if (filterData.stack[0].renderTarget.transform)\n            { //\n\n                // TODO we should fit the rect around the transform..\n            }\n            else if (filters[0].autoFit)\n            {\n                sourceFrame.fit(renderTargetFrame);\n            }\n\n            // lets apply the padding After we fit the element to the screen.\n            // this should stop the strange side effects that can occur when cropping to the edges\n            sourceFrame.pad(padding);\n        }\n\n        destinationFrame.width = sourceFrame.width;\n        destinationFrame.height = sourceFrame.height;\n\n        // lets play the padding after we fit the element to the screen.\n        // this should stop the strange side effects that can occur when cropping to the edges\n\n        const renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);\n\n        currentState.target = target;\n        currentState.filters = filters;\n        currentState.resolution = resolution;\n        currentState.renderTarget = renderTarget;\n\n        // bind the render target to draw the shape in the top corner..\n\n        renderTarget.setFrame(destinationFrame, sourceFrame);\n\n        // bind the render target\n        renderer.bindRenderTarget(renderTarget);\n        renderTarget.clear();\n    }\n\n    /**\n     * Pops off the filter and applies it.\n     *\n     */\n    popFilter()\n    {\n        const filterData = this.filterData;\n\n        const lastState = filterData.stack[filterData.index - 1];\n        const currentState = filterData.stack[filterData.index];\n\n        this.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();\n\n        const filters = currentState.filters;\n\n        if (filters.length === 1)\n        {\n            filters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false, currentState);\n            this.freePotRenderTarget(currentState.renderTarget);\n        }\n        else\n        {\n            let flip = currentState.renderTarget;\n            let flop = this.getPotRenderTarget(\n                this.renderer.gl,\n                currentState.sourceFrame.width,\n                currentState.sourceFrame.height,\n                currentState.resolution\n            );\n\n            flop.setFrame(currentState.destinationFrame, currentState.sourceFrame);\n\n            // finally lets clear the render target before drawing to it..\n            flop.clear();\n\n            let i = 0;\n\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                filters[i].apply(this, flip, flop, true, currentState);\n\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, lastState.renderTarget, false, currentState);\n\n            this.freePotRenderTarget(flip);\n            this.freePotRenderTarget(flop);\n        }\n\n        currentState.clear();\n        filterData.index--;\n\n        if (filterData.index === 0)\n        {\n            this.filterData = null;\n        }\n    }\n\n    /**\n     * Draws a filter.\n     *\n     * @param {PIXI.Filter} filter - The filter to draw.\n     * @param {PIXI.RenderTarget} input - The input render target.\n     * @param {PIXI.RenderTarget} output - The target to output to.\n     * @param {boolean} clear - Should the output be cleared before rendering to it\n     */\n    applyFilter(filter, input, output, clear)\n    {\n        const renderer = this.renderer;\n        const gl = renderer.gl;\n\n        let shader = filter.glShaders[renderer.CONTEXT_UID];\n\n        // caching..\n        if (!shader)\n        {\n            if (filter.glShaderKey)\n            {\n                shader = this.shaderCache[filter.glShaderKey];\n\n                if (!shader)\n                {\n                    shader = new Shader(this.gl, filter.vertexSrc, filter.fragmentSrc);\n\n                    filter.glShaders[renderer.CONTEXT_UID] = this.shaderCache[filter.glShaderKey] = shader;\n                    this.managedFilters.push(filter);\n                }\n            }\n            else\n            {\n                shader = filter.glShaders[renderer.CONTEXT_UID] = new Shader(this.gl, filter.vertexSrc, filter.fragmentSrc);\n                this.managedFilters.push(filter);\n            }\n\n            // TODO - this only needs to be done once?\n            renderer.bindVao(null);\n\n            this.quad.initVao(shader);\n        }\n\n        renderer.bindVao(this.quad.vao);\n\n        renderer.bindRenderTarget(output);\n\n        if (clear)\n        {\n            gl.disable(gl.SCISSOR_TEST);\n            renderer.clear();// [1, 1, 1, 1]);\n            gl.enable(gl.SCISSOR_TEST);\n        }\n\n        // in case the render target is being masked using a scissor rect\n        if (output === renderer.maskManager.scissorRenderTarget)\n        {\n            renderer.maskManager.pushScissorMask(null, renderer.maskManager.scissorData);\n        }\n\n        renderer.bindShader(shader);\n\n        // free unit 0 for us, doesn't matter what was there\n        // don't try to restore it, because syncUniforms can upload it to another slot\n        // and it'll be a problem\n        const tex = this.renderer.emptyTextures[0];\n\n        this.renderer.boundTextures[0] = tex;\n        // this syncs the PixiJS filters  uniforms with glsl uniforms\n        this.syncUniforms(shader, filter);\n\n        renderer.state.setBlendMode(filter.blendMode);\n\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, input.texture.texture);\n\n        this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n\n        gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);\n    }\n\n    /**\n     * Uploads the uniforms of the filter.\n     *\n     * @param {GLShader} shader - The underlying gl shader.\n     * @param {PIXI.Filter} filter - The filter we are synchronizing.\n     */\n    syncUniforms(shader, filter)\n    {\n        const uniformData = filter.uniformData;\n        const uniforms = filter.uniforms;\n\n        // 0 is reserved for the PixiJS texture so we start at 1!\n        let textureCount = 1;\n        let currentState;\n\n        // filterArea and filterClamp that are handled by FilterManager directly\n        // they must not appear in uniformData\n\n        if (shader.uniforms.filterArea)\n        {\n            currentState = this.filterData.stack[this.filterData.index];\n\n            const filterArea = shader.uniforms.filterArea;\n\n            filterArea[0] = currentState.renderTarget.size.width;\n            filterArea[1] = currentState.renderTarget.size.height;\n            filterArea[2] = currentState.sourceFrame.x;\n            filterArea[3] = currentState.sourceFrame.y;\n\n            shader.uniforms.filterArea = filterArea;\n        }\n\n        // use this to clamp displaced texture coords so they belong to filterArea\n        // see displacementFilter fragment shader for an example\n        if (shader.uniforms.filterClamp)\n        {\n            currentState = currentState || this.filterData.stack[this.filterData.index];\n\n            const filterClamp = shader.uniforms.filterClamp;\n\n            filterClamp[0] = 0;\n            filterClamp[1] = 0;\n            filterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;\n            filterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;\n\n            shader.uniforms.filterClamp = filterClamp;\n        }\n\n        // TODO Caching layer..\n        for (const i in uniformData)\n        {\n            if (!shader.uniforms.data[i])\n            {\n                continue;\n            }\n\n            const type = uniformData[i].type;\n\n            if (type === 'sampler2d' && uniforms[i] !== 0)\n            {\n                if (uniforms[i].baseTexture)\n                {\n                    shader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount);\n                }\n                else\n                {\n                    shader.uniforms[i] = textureCount;\n\n                    // TODO\n                    // this is helpful as renderTargets can also be set.\n                    // Although thinking about it, we could probably\n                    // make the filter texture cache return a RenderTexture\n                    // rather than a renderTarget\n                    const gl = this.renderer.gl;\n\n                    this.renderer.boundTextures[textureCount] = this.renderer.emptyTextures[textureCount];\n                    gl.activeTexture(gl.TEXTURE0 + textureCount);\n\n                    uniforms[i].texture.bind();\n                }\n\n                textureCount++;\n            }\n            else if (type === 'mat3')\n            {\n                // check if its PixiJS matrix..\n                if (uniforms[i].a !== undefined)\n                {\n                    shader.uniforms[i] = uniforms[i].toArray(true);\n                }\n                else\n                {\n                    shader.uniforms[i] = uniforms[i];\n                }\n            }\n            else if (type === 'vec2')\n            {\n                // check if its a point..\n                if (uniforms[i].x !== undefined)\n               {\n                    const val = shader.uniforms[i] || new Float32Array(2);\n\n                    val[0] = uniforms[i].x;\n                    val[1] = uniforms[i].y;\n                    shader.uniforms[i] = val;\n                }\n                else\n               {\n                    shader.uniforms[i] = uniforms[i];\n                }\n            }\n            else if (type === 'float')\n            {\n                if (shader.uniforms.data[i].value !== uniformData[i])\n                {\n                    shader.uniforms[i] = uniforms[i];\n                }\n            }\n            else\n            {\n                shader.uniforms[i] = uniforms[i];\n            }\n        }\n    }\n\n    /**\n     * Gets a render target from the pool, or creates a new one.\n     *\n     * @param {boolean} clear - Should we clear the render texture when we get it?\n     * @param {number} resolution - The resolution of the target.\n     * @return {PIXI.RenderTarget} The new render target\n     */\n    getRenderTarget(clear, resolution)\n    {\n        const currentState = this.filterData.stack[this.filterData.index];\n        const renderTarget = this.getPotRenderTarget(\n            this.renderer.gl,\n            currentState.sourceFrame.width,\n            currentState.sourceFrame.height,\n            resolution || currentState.resolution\n        );\n\n        renderTarget.setFrame(currentState.destinationFrame, currentState.sourceFrame);\n\n        return renderTarget;\n    }\n\n    /**\n     * Returns a render target to the pool.\n     *\n     * @param {PIXI.RenderTarget} renderTarget - The render target to return.\n     */\n    returnRenderTarget(renderTarget)\n    {\n        this.freePotRenderTarget(renderTarget);\n    }\n\n    /**\n     * Calculates the mapped matrix.\n     *\n     * TODO playing around here.. this is temporary - (will end up in the shader)\n     * this returns a matrix that will normalise map filter cords in the filter to screen space\n     *\n     * @param {PIXI.Matrix} outputMatrix - the matrix to output to.\n     * @return {PIXI.Matrix} The mapped matrix.\n     */\n    calculateScreenSpaceMatrix(outputMatrix)\n    {\n        const currentState = this.filterData.stack[this.filterData.index];\n\n        return filterTransforms.calculateScreenSpaceMatrix(\n            outputMatrix,\n            currentState.sourceFrame,\n            currentState.renderTarget.size\n        );\n    }\n\n    /**\n     * Multiply vTextureCoord to this matrix to achieve (0,0,1,1) for filterArea\n     *\n     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.\n     * @return {PIXI.Matrix} The mapped matrix.\n     */\n    calculateNormalizedScreenSpaceMatrix(outputMatrix)\n    {\n        const currentState = this.filterData.stack[this.filterData.index];\n\n        return filterTransforms.calculateNormalizedScreenSpaceMatrix(\n            outputMatrix,\n            currentState.sourceFrame,\n            currentState.renderTarget.size,\n            currentState.destinationFrame\n        );\n    }\n\n    /**\n     * This will map the filter coord so that a texture can be used based on the transform of a sprite\n     *\n     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.\n     * @param {PIXI.Sprite} sprite - The sprite to map to.\n     * @return {PIXI.Matrix} The mapped matrix.\n     */\n    calculateSpriteMatrix(outputMatrix, sprite)\n    {\n        const currentState = this.filterData.stack[this.filterData.index];\n\n        return filterTransforms.calculateSpriteMatrix(\n            outputMatrix,\n            currentState.sourceFrame,\n            currentState.renderTarget.size,\n            sprite\n        );\n    }\n\n    /**\n     * Destroys this Filter Manager.\n     *\n     * @param {boolean} [contextLost=false] context was lost, do not free shaders\n     *\n     */\n    destroy(contextLost = false)\n    {\n        const renderer = this.renderer;\n        const filters = this.managedFilters;\n\n        renderer.off('prerender', this.onPrerender, this);\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            if (!contextLost)\n            {\n                filters[i].glShaders[renderer.CONTEXT_UID].destroy();\n            }\n            delete filters[i].glShaders[renderer.CONTEXT_UID];\n        }\n\n        this.shaderCache = {};\n        if (!contextLost)\n        {\n            this.emptyPool();\n        }\n        else\n        {\n            this.pool = {};\n        }\n    }\n\n    /**\n     * Gets a Power-of-Two render texture.\n     *\n     * TODO move to a separate class could be on renderer?\n     * also - could cause issue with multiple contexts?\n     *\n     * @private\n     * @param {WebGLRenderingContext} gl - The webgl rendering context\n     * @param {number} minWidth - The minimum width of the render target.\n     * @param {number} minHeight - The minimum height of the render target.\n     * @param {number} resolution - The resolution of the render target.\n     * @return {PIXI.RenderTarget} The new render target.\n     */\n    getPotRenderTarget(gl, minWidth, minHeight, resolution)\n    {\n        let key = screenKey;\n\n        minWidth *= resolution;\n        minHeight *= resolution;\n\n        if (minWidth !== this._screenWidth\n            || minHeight !== this._screenHeight)\n        {\n            // TODO you could return a bigger texture if there is not one in the pool?\n            minWidth = bitTwiddle.nextPow2(minWidth);\n            minHeight = bitTwiddle.nextPow2(minHeight);\n            key = ((minWidth & 0xFFFF) << 16) | (minHeight & 0xFFFF);\n        }\n\n        if (!this.pool[key])\n        {\n            this.pool[key] = [];\n        }\n\n        let renderTarget = this.pool[key].pop();\n\n        // creating render target will cause texture to be bound!\n        if (!renderTarget)\n        {\n            // temporary bypass cache..\n            const tex = this.renderer.boundTextures[0];\n\n            gl.activeTexture(gl.TEXTURE0);\n\n            // internally - this will cause a texture to be bound..\n            renderTarget = new RenderTarget(gl, minWidth, minHeight, null, 1);\n\n            // set the current one back\n            gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);\n        }\n\n        // manually tweak the resolution...\n        // this will not modify the size of the frame buffer, just its resolution.\n        renderTarget.resolution = resolution;\n        renderTarget.defaultFrame.width = renderTarget.size.width = minWidth / resolution;\n        renderTarget.defaultFrame.height = renderTarget.size.height = minHeight / resolution;\n        renderTarget.filterPoolKey = key;\n\n        return renderTarget;\n    }\n\n    /**\n     * Empties the texture pool.\n     *\n     */\n    emptyPool()\n    {\n        for (const i in this.pool)\n        {\n            const textures = this.pool[i];\n\n            if (textures)\n            {\n                for (let j = 0; j < textures.length; j++)\n                {\n                    textures[j].destroy(true);\n                }\n            }\n        }\n\n        this.pool = {};\n    }\n\n    /**\n     * Frees a render target back into the pool.\n     *\n     * @param {PIXI.RenderTarget} renderTarget - The renderTarget to free\n     */\n    freePotRenderTarget(renderTarget)\n    {\n        this.pool[renderTarget.filterPoolKey].push(renderTarget);\n    }\n\n    /**\n     * Called before the renderer starts rendering.\n     *\n     */\n    onPrerender()\n    {\n        if (this._screenWidth !== this.renderer.view.width\n            || this._screenHeight !== this.renderer.view.height)\n        {\n            this._screenWidth = this.renderer.view.width;\n            this._screenHeight = this.renderer.view.height;\n\n            const textures = this.pool[screenKey];\n\n            if (textures)\n            {\n                for (let j = 0; j < textures.length; j++)\n                {\n                    textures[j].destroy(true);\n                }\n            }\n            this.pool[screenKey] = [];\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"script"}