{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _Container2 = require('../display/Container');\n\nvar _Container3 = _interopRequireDefault(_Container2);\n\nvar _RenderTexture = require('../textures/RenderTexture');\n\nvar _RenderTexture2 = _interopRequireDefault(_RenderTexture);\n\nvar _Texture = require('../textures/Texture');\n\nvar _Texture2 = _interopRequireDefault(_Texture);\n\nvar _GraphicsData = require('./GraphicsData');\n\nvar _GraphicsData2 = _interopRequireDefault(_GraphicsData);\n\nvar _Sprite = require('../sprites/Sprite');\n\nvar _Sprite2 = _interopRequireDefault(_Sprite);\n\nvar _math = require('../math');\n\nvar _utils = require('../utils');\n\nvar _const = require('../const');\n\nvar _Bounds = require('../display/Bounds');\n\nvar _Bounds2 = _interopRequireDefault(_Bounds);\n\nvar _bezierCurveTo2 = require('./utils/bezierCurveTo');\n\nvar _bezierCurveTo3 = _interopRequireDefault(_bezierCurveTo2);\n\nvar _CanvasRenderer = require('../renderers/canvas/CanvasRenderer');\n\nvar _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar canvasRenderer = void 0;\nvar tempMatrix = new _math.Matrix();\nvar tempPoint = new _math.Point();\nvar tempColor1 = new Float32Array(4);\nvar tempColor2 = new Float32Array(4);\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\n\nvar Graphics = function (_Container) {\n  _inherits(Graphics, _Container);\n  /**\n   *\n   * @param {boolean} [nativeLines=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n   */\n\n\n  function Graphics() {\n    var nativeLines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    _classCallCheck(this, Graphics);\n    /**\n     * The alpha value used when filling the Graphics object.\n     *\n     * @member {number}\n     * @default 1\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _Container.call(this));\n\n    _this.fillAlpha = 1;\n    /**\n     * The width (thickness) of any lines drawn.\n     *\n     * @member {number}\n     * @default 0\n     */\n\n    _this.lineWidth = 0;\n    /**\n     * If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     *\n     * @member {boolean}\n     */\n\n    _this.nativeLines = nativeLines;\n    /**\n     * The color of any lines drawn.\n     *\n     * @member {string}\n     * @default 0\n     */\n\n    _this.lineColor = 0;\n    /**\n     * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).\n     *\n     * @member {number}\n     * @default 0.5\n     */\n\n    _this.lineAlignment = 0.5;\n    /**\n     * Graphics data\n     *\n     * @member {PIXI.GraphicsData[]}\n     * @private\n     */\n\n    _this.graphicsData = [];\n    /**\n     * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to\n     * reset the tint.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n\n    _this.tint = 0xFFFFFF;\n    /**\n     * The previous tint applied to the graphic shape. Used to compare to the current tint and\n     * check if theres change.\n     *\n     * @member {number}\n     * @private\n     * @default 0xFFFFFF\n     */\n\n    _this._prevTint = 0xFFFFFF;\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of\n     * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL;\n     * @see PIXI.BLEND_MODES\n     */\n\n    _this.blendMode = _const.BLEND_MODES.NORMAL;\n    /**\n     * Current path\n     *\n     * @member {PIXI.GraphicsData}\n     * @private\n     */\n\n    _this.currentPath = null;\n    /**\n     * Array containing some WebGL-related properties used by the WebGL renderer.\n     *\n     * @member {object<number, object>}\n     * @private\n     */\n    // TODO - _webgl should use a prototype object, not a random undocumented object...\n\n    _this._webGL = {};\n    /**\n     * Whether this shape is being used as a mask.\n     *\n     * @member {boolean}\n     */\n\n    _this.isMask = false;\n    /**\n     * The bounds' padding used for bounds calculation.\n     *\n     * @member {number}\n     */\n\n    _this.boundsPadding = 0;\n    /**\n     * A cache of the local bounds to prevent recalculation.\n     *\n     * @member {PIXI.Rectangle}\n     * @private\n     */\n\n    _this._localBounds = new _Bounds2.default();\n    /**\n     * Used to detect if the graphics object has changed. If this is set to true then the graphics\n     * object will be recalculated.\n     *\n     * @member {boolean}\n     * @private\n     */\n\n    _this.dirty = 0;\n    /**\n     * Used to detect if we need to do a fast rect check using the id compare method\n     * @type {Number}\n     */\n\n    _this.fastRectDirty = -1;\n    /**\n     * Used to detect if we clear the graphics webGL data\n     * @type {Number}\n     */\n\n    _this.clearDirty = 0;\n    /**\n     * Used to detect if we we need to recalculate local bounds\n     * @type {Number}\n     */\n\n    _this.boundsDirty = -1;\n    /**\n     * Used to detect if the cached sprite object needs to be updated.\n     *\n     * @member {boolean}\n     * @private\n     */\n\n    _this.cachedSpriteDirty = false;\n    _this._spriteRect = null;\n    _this._fastRect = false;\n    _this._prevRectTint = null;\n    _this._prevRectFillColor = null;\n    /**\n     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n     * This is useful if your graphics element does not change often, as it will speed up the rendering\n     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n     * you are constantly redrawing the graphics element.\n     *\n     * @name cacheAsBitmap\n     * @member {boolean}\n     * @memberof PIXI.Graphics#\n     * @default false\n     */\n\n    return _this;\n  }\n  /**\n   * Creates a new Graphics object with the same values as this one.\n   * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n   *\n   * @return {PIXI.Graphics} A clone of the graphics object\n   */\n\n\n  Graphics.prototype.clone = function clone() {\n    var clone = new Graphics();\n    clone.renderable = this.renderable;\n    clone.fillAlpha = this.fillAlpha;\n    clone.lineWidth = this.lineWidth;\n    clone.lineColor = this.lineColor;\n    clone.lineAlignment = this.lineAlignment;\n    clone.tint = this.tint;\n    clone.blendMode = this.blendMode;\n    clone.isMask = this.isMask;\n    clone.boundsPadding = this.boundsPadding;\n    clone.dirty = 0;\n    clone.cachedSpriteDirty = this.cachedSpriteDirty; // copy graphics data\n\n    for (var i = 0; i < this.graphicsData.length; ++i) {\n      clone.graphicsData.push(this.graphicsData[i].clone());\n    }\n\n    clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];\n    clone.updateLocalBounds();\n    return clone;\n  };\n  /**\n   * Calculate length of quadratic curve\n   * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n   * for the detailed explanation of math behind this.\n   *\n   * @private\n   * @param {number} fromX - x-coordinate of curve start point\n   * @param {number} fromY - y-coordinate of curve start point\n   * @param {number} cpX - x-coordinate of curve control point\n   * @param {number} cpY - y-coordinate of curve control point\n   * @param {number} toX - x-coordinate of curve end point\n   * @param {number} toY - y-coordinate of curve end point\n   * @return {number} Length of quadratic curve\n   */\n\n\n  Graphics.prototype._quadraticCurveLength = function _quadraticCurveLength(fromX, fromY, cpX, cpY, toX, toY) {\n    var ax = fromX - 2.0 * cpX + toX;\n    var ay = fromY - 2.0 * cpY + toY;\n    var bx = 2.0 * cpX - 2.0 * fromX;\n    var by = 2.0 * cpY - 2.0 * fromY;\n    var a = 4.0 * (ax * ax + ay * ay);\n    var b = 4.0 * (ax * bx + ay * by);\n    var c = bx * bx + by * by;\n    var s = 2.0 * Math.sqrt(a + b + c);\n    var a2 = Math.sqrt(a);\n    var a32 = 2.0 * a * a2;\n    var c2 = 2.0 * Math.sqrt(c);\n    var ba = b / a2;\n    return (a32 * s + a2 * b * (s - c2) + (4.0 * c * a - b * b) * Math.log((2.0 * a2 + ba + s) / (ba + c2))) / (4.0 * a32);\n  };\n  /**\n   * Calculate length of bezier curve.\n   * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n   * Therefore numerical solution is used.\n   *\n   * @private\n   * @param {number} fromX - Starting point x\n   * @param {number} fromY - Starting point y\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} cpX2 - Second Control point x\n   * @param {number} cpY2 - Second Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @return {number} Length of bezier curve\n   */\n\n\n  Graphics.prototype._bezierCurveLength = function _bezierCurveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY) {\n    var n = 10;\n    var result = 0.0;\n    var t = 0.0;\n    var t2 = 0.0;\n    var t3 = 0.0;\n    var nt = 0.0;\n    var nt2 = 0.0;\n    var nt3 = 0.0;\n    var x = 0.0;\n    var y = 0.0;\n    var dx = 0.0;\n    var dy = 0.0;\n    var prevX = fromX;\n    var prevY = fromY;\n\n    for (var i = 1; i <= n; ++i) {\n      t = i / n;\n      t2 = t * t;\n      t3 = t2 * t;\n      nt = 1.0 - t;\n      nt2 = nt * nt;\n      nt3 = nt2 * nt;\n      x = nt3 * fromX + 3.0 * nt2 * t * cpX + 3.0 * nt * t2 * cpX2 + t3 * toX;\n      y = nt3 * fromY + 3.0 * nt2 * t * cpY + 3 * nt * t2 * cpY2 + t3 * toY;\n      dx = prevX - x;\n      dy = prevY - y;\n      prevX = x;\n      prevY = y;\n      result += Math.sqrt(dx * dx + dy * dy);\n    }\n\n    return result;\n  };\n  /**\n   * Calculate number of segments for the curve based on its length to ensure its smoothness.\n   *\n   * @private\n   * @param {number} length - length of curve\n   * @return {number} Number of segments\n   */\n\n\n  Graphics.prototype._segmentsCount = function _segmentsCount(length) {\n    var result = Math.ceil(length / Graphics.CURVES.maxLength);\n\n    if (result < Graphics.CURVES.minSegments) {\n      result = Graphics.CURVES.minSegments;\n    } else if (result > Graphics.CURVES.maxSegments) {\n      result = Graphics.CURVES.maxSegments;\n    }\n\n    return result;\n  };\n  /**\n   * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n   * method or the drawCircle() method.\n   *\n   * @param {number} [lineWidth=0] - width of the line to draw, will update the objects stored style\n   * @param {number} [color=0] - color of the line to draw, will update the objects stored style\n   * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n   * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.lineStyle = function lineStyle() {\n    var lineWidth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var alpha = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    var alignment = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;\n    this.lineWidth = lineWidth;\n    this.lineColor = color;\n    this.lineAlpha = alpha;\n    this.lineAlignment = alignment;\n\n    if (this.currentPath) {\n      if (this.currentPath.shape.points.length) {\n        // halfway through a line? start a new one!\n        var shape = new _math.Polygon(this.currentPath.shape.points.slice(-2));\n        shape.closed = false;\n        this.drawShape(shape);\n      } else {\n        // otherwise its empty so lets just set the line properties\n        this.currentPath.lineWidth = this.lineWidth;\n        this.currentPath.lineColor = this.lineColor;\n        this.currentPath.lineAlpha = this.lineAlpha;\n        this.currentPath.lineAlignment = this.lineAlignment;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Moves the current drawing position to x, y.\n   *\n   * @param {number} x - the X coordinate to move to\n   * @param {number} y - the Y coordinate to move to\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.moveTo = function moveTo(x, y) {\n    var shape = new _math.Polygon([x, y]);\n    shape.closed = false;\n    this.drawShape(shape);\n    return this;\n  };\n  /**\n   * Draws a line using the current line style from the current drawing position to (x, y);\n   * The current drawing position is then set to (x, y).\n   *\n   * @param {number} x - the X coordinate to draw to\n   * @param {number} y - the Y coordinate to draw to\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.lineTo = function lineTo(x, y) {\n    var points = this.currentPath.shape.points;\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n\n    if (fromX !== x || fromY !== y) {\n      points.push(x, y);\n      this.dirty++;\n    }\n\n    return this;\n  };\n  /**\n   * Calculate the points for a quadratic bezier curve and then draws it.\n   * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n   *\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.quadraticCurveTo = function quadraticCurveTo(cpX, cpY, toX, toY) {\n    if (this.currentPath) {\n      if (this.currentPath.shape.points.length === 0) {\n        this.currentPath.shape.points = [0, 0];\n      }\n    } else {\n      this.moveTo(0, 0);\n    }\n\n    var points = this.currentPath.shape.points;\n    var xa = 0;\n    var ya = 0;\n\n    if (points.length === 0) {\n      this.moveTo(0, 0);\n    }\n\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var n = Graphics.CURVES.adaptive ? this._segmentsCount(this._quadraticCurveLength(fromX, fromY, cpX, cpY, toX, toY)) : 20;\n\n    for (var i = 1; i <= n; ++i) {\n      var j = i / n;\n      xa = fromX + (cpX - fromX) * j;\n      ya = fromY + (cpY - fromY) * j;\n      points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);\n    }\n\n    this.dirty++;\n    return this;\n  };\n  /**\n   * Calculate the points for a bezier curve and then draws it.\n   *\n   * @param {number} cpX - Control point x\n   * @param {number} cpY - Control point y\n   * @param {number} cpX2 - Second Control point x\n   * @param {number} cpY2 - Second Control point y\n   * @param {number} toX - Destination point x\n   * @param {number} toY - Destination point y\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.bezierCurveTo = function bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n    if (this.currentPath) {\n      if (this.currentPath.shape.points.length === 0) {\n        this.currentPath.shape.points = [0, 0];\n      }\n    } else {\n      this.moveTo(0, 0);\n    }\n\n    var points = this.currentPath.shape.points;\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    points.length -= 2;\n    var n = Graphics.CURVES.adaptive ? this._segmentsCount(this._bezierCurveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)) : 20;\n    (0, _bezierCurveTo3.default)(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n, points);\n    this.dirty++;\n    return this;\n  };\n  /**\n   * The arcTo() method creates an arc/curve between two tangents on the canvas.\n   *\n   * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n   *\n   * @param {number} x1 - The x-coordinate of the beginning of the arc\n   * @param {number} y1 - The y-coordinate of the beginning of the arc\n   * @param {number} x2 - The x-coordinate of the end of the arc\n   * @param {number} y2 - The y-coordinate of the end of the arc\n   * @param {number} radius - The radius of the arc\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.arcTo = function arcTo(x1, y1, x2, y2, radius) {\n    if (this.currentPath) {\n      if (this.currentPath.shape.points.length === 0) {\n        this.currentPath.shape.points.push(x1, y1);\n      }\n    } else {\n      this.moveTo(x1, y1);\n    }\n\n    var points = this.currentPath.shape.points;\n    var fromX = points[points.length - 2];\n    var fromY = points[points.length - 1];\n    var a1 = fromY - y1;\n    var b1 = fromX - x1;\n    var a2 = y2 - y1;\n    var b2 = x2 - x1;\n    var mm = Math.abs(a1 * b2 - b1 * a2);\n\n    if (mm < 1.0e-8 || radius === 0) {\n      if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n        points.push(x1, y1);\n      }\n    } else {\n      var dd = a1 * a1 + b1 * b1;\n      var cc = a2 * a2 + b2 * b2;\n      var tt = a1 * a2 + b1 * b2;\n      var k1 = radius * Math.sqrt(dd) / mm;\n      var k2 = radius * Math.sqrt(cc) / mm;\n      var j1 = k1 * tt / dd;\n      var j2 = k2 * tt / cc;\n      var cx = k1 * b2 + k2 * b1;\n      var cy = k1 * a2 + k2 * a1;\n      var px = b1 * (k2 + j1);\n      var py = a1 * (k2 + j1);\n      var qx = b2 * (k1 + j2);\n      var qy = a2 * (k1 + j2);\n      var startAngle = Math.atan2(py - cy, px - cx);\n      var endAngle = Math.atan2(qy - cy, qx - cx);\n      this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n    }\n\n    this.dirty++;\n    return this;\n  };\n  /**\n   * The arc method creates an arc/curve (used to create circles, or parts of circles).\n   *\n   * @param {number} cx - The x-coordinate of the center of the circle\n   * @param {number} cy - The y-coordinate of the center of the circle\n   * @param {number} radius - The radius of the circle\n   * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n   *  of the arc's circle)\n   * @param {number} endAngle - The ending angle, in radians\n   * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n   *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n   *  indicates counter-clockwise.\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.arc = function arc(cx, cy, radius, startAngle, endAngle) {\n    var anticlockwise = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    if (startAngle === endAngle) {\n      return this;\n    }\n\n    if (!anticlockwise && endAngle <= startAngle) {\n      endAngle += _const.PI_2;\n    } else if (anticlockwise && startAngle <= endAngle) {\n      startAngle += _const.PI_2;\n    }\n\n    var sweep = endAngle - startAngle;\n    var segs = Graphics.CURVES.adaptive ? this._segmentsCount(Math.abs(sweep) * radius) : Math.ceil(Math.abs(sweep) / _const.PI_2) * 40;\n\n    if (sweep === 0) {\n      return this;\n    }\n\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius; // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n\n    var points = this.currentPath ? this.currentPath.shape.points : null;\n\n    if (points) {\n      // We check how far our start is from the last existing point\n      var xDiff = Math.abs(points[points.length - 2] - startX);\n      var yDiff = Math.abs(points[points.length - 1] - startY);\n\n      if (xDiff < 0.001 && yDiff < 0.001) {// If the point is very close, we don't add it, since this would lead to artifacts\n        // during tesselation due to floating point imprecision.\n      } else {\n        points.push(startX, startY);\n      }\n    } else {\n      this.moveTo(startX, startY);\n      points = this.currentPath.shape.points;\n    }\n\n    var theta = sweep / (segs * 2);\n    var theta2 = theta * 2;\n    var cTheta = Math.cos(theta);\n    var sTheta = Math.sin(theta);\n    var segMinus = segs - 1;\n    var remainder = segMinus % 1 / segMinus;\n\n    for (var i = 0; i <= segMinus; ++i) {\n      var real = i + remainder * i;\n      var angle = theta + startAngle + theta2 * real;\n      var c = Math.cos(angle);\n      var s = -Math.sin(angle);\n      points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);\n    }\n\n    this.dirty++;\n    return this;\n  };\n  /**\n   * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n   * (such as lineTo() or drawCircle()) use when drawing.\n   *\n   * @param {number} [color=0] - the color of the fill\n   * @param {number} [alpha=1] - the alpha of the fill\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.beginFill = function beginFill() {\n    var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    this.filling = true;\n    this.fillColor = color;\n    this.fillAlpha = alpha;\n\n    if (this.currentPath) {\n      if (this.currentPath.shape.points.length <= 2) {\n        this.currentPath.fill = this.filling;\n        this.currentPath.fillColor = this.fillColor;\n        this.currentPath.fillAlpha = this.fillAlpha;\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n   *\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.endFill = function endFill() {\n    this.filling = false;\n    this.fillColor = null;\n    this.fillAlpha = 1;\n    return this;\n  };\n  /**\n   *\n   * @param {number} x - The X coord of the top-left of the rectangle\n   * @param {number} y - The Y coord of the top-left of the rectangle\n   * @param {number} width - The width of the rectangle\n   * @param {number} height - The height of the rectangle\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawRect = function drawRect(x, y, width, height) {\n    this.drawShape(new _math.Rectangle(x, y, width, height));\n    return this;\n  };\n  /**\n   *\n   * @param {number} x - The X coord of the top-left of the rectangle\n   * @param {number} y - The Y coord of the top-left of the rectangle\n   * @param {number} width - The width of the rectangle\n   * @param {number} height - The height of the rectangle\n   * @param {number} radius - Radius of the rectangle corners\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawRoundedRect = function drawRoundedRect(x, y, width, height, radius) {\n    this.drawShape(new _math.RoundedRectangle(x, y, width, height, radius));\n    return this;\n  };\n  /**\n   * Draws a circle.\n   *\n   * @param {number} x - The X coordinate of the center of the circle\n   * @param {number} y - The Y coordinate of the center of the circle\n   * @param {number} radius - The radius of the circle\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawCircle = function drawCircle(x, y, radius) {\n    this.drawShape(new _math.Circle(x, y, radius));\n    return this;\n  };\n  /**\n   * Draws an ellipse.\n   *\n   * @param {number} x - The X coordinate of the center of the ellipse\n   * @param {number} y - The Y coordinate of the center of the ellipse\n   * @param {number} width - The half width of the ellipse\n   * @param {number} height - The half height of the ellipse\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawEllipse = function drawEllipse(x, y, width, height) {\n    this.drawShape(new _math.Ellipse(x, y, width, height));\n    return this;\n  };\n  /**\n   * Draws a polygon using the given path.\n   *\n   * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawPolygon = function drawPolygon(path) {\n    // prevents an argument assignment deopt\n    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    var points = path;\n    var closed = true;\n\n    if (points instanceof _math.Polygon) {\n      closed = points.closed;\n      points = points.points;\n    }\n\n    if (!Array.isArray(points)) {\n      // prevents an argument leak deopt\n      // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n      points = new Array(arguments.length);\n\n      for (var i = 0; i < points.length; ++i) {\n        points[i] = arguments[i]; // eslint-disable-line prefer-rest-params\n      }\n    }\n\n    var shape = new _math.Polygon(points);\n    shape.closed = closed;\n    this.drawShape(shape);\n    return this;\n  };\n  /**\n   * Draw a star shape with an abitrary number of points.\n   *\n   * @param {number} x - Center X position of the star\n   * @param {number} y - Center Y position of the star\n   * @param {number} points - The number of points of the star, must be > 1\n   * @param {number} radius - The outer radius of the star\n   * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n   * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.drawStar = function drawStar(x, y, points, radius, innerRadius) {\n    var rotation = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    innerRadius = innerRadius || radius / 2;\n    var startAngle = -1 * Math.PI / 2 + rotation;\n    var len = points * 2;\n    var delta = _const.PI_2 / len;\n    var polygon = [];\n\n    for (var i = 0; i < len; i++) {\n      var r = i % 2 ? innerRadius : radius;\n      var angle = i * delta + startAngle;\n      polygon.push(x + r * Math.cos(angle), y + r * Math.sin(angle));\n    }\n\n    return this.drawPolygon(polygon);\n  };\n  /**\n   * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n   *\n   * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n   */\n\n\n  Graphics.prototype.clear = function clear() {\n    if (this.lineWidth || this.filling || this.graphicsData.length > 0) {\n      this.lineWidth = 0;\n      this.lineAlignment = 0.5;\n      this.filling = false;\n      this.boundsDirty = -1;\n      this.canvasTintDirty = -1;\n      this.dirty++;\n      this.clearDirty++;\n      this.graphicsData.length = 0;\n    }\n\n    this.currentPath = null;\n    this._spriteRect = null;\n    return this;\n  };\n  /**\n   * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n   * masked with gl.scissor.\n   *\n   * @returns {boolean} True if only 1 rect.\n   */\n\n\n  Graphics.prototype.isFastRect = function isFastRect() {\n    return this.graphicsData.length === 1 && this.graphicsData[0].shape.type === _const.SHAPES.RECT && !this.graphicsData[0].lineWidth;\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n\n  Graphics.prototype._renderWebGL = function _renderWebGL(renderer) {\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n    if (this.dirty !== this.fastRectDirty) {\n      this.fastRectDirty = this.dirty;\n      this._fastRect = this.isFastRect();\n    } // TODO this check can be moved to dirty?\n\n\n    if (this._fastRect) {\n      this._renderSpriteRect(renderer);\n    } else {\n      renderer.setObjectRenderer(renderer.plugins.graphics);\n      renderer.plugins.graphics.render(this);\n    }\n  };\n  /**\n   * Renders a sprite rectangle.\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n\n  Graphics.prototype._renderSpriteRect = function _renderSpriteRect(renderer) {\n    var rect = this.graphicsData[0].shape;\n\n    if (!this._spriteRect) {\n      this._spriteRect = new _Sprite2.default(new _Texture2.default(_Texture2.default.WHITE));\n    }\n\n    var sprite = this._spriteRect;\n    var fillColor = this.graphicsData[0].fillColor;\n\n    if (this.tint === 0xffffff) {\n      sprite.tint = fillColor;\n    } else if (this.tint !== this._prevRectTint || fillColor !== this._prevRectFillColor) {\n      var t1 = tempColor1;\n      var t2 = tempColor2;\n      (0, _utils.hex2rgb)(fillColor, t1);\n      (0, _utils.hex2rgb)(this.tint, t2);\n      t1[0] *= t2[0];\n      t1[1] *= t2[1];\n      t1[2] *= t2[2];\n      sprite.tint = (0, _utils.rgb2hex)(t1);\n      this._prevRectTint = this.tint;\n      this._prevRectFillColor = fillColor;\n    }\n\n    sprite.alpha = this.graphicsData[0].fillAlpha;\n    sprite.worldAlpha = this.worldAlpha * sprite.alpha;\n    sprite.blendMode = this.blendMode;\n    sprite._texture._frame.width = rect.width;\n    sprite._texture._frame.height = rect.height;\n    sprite.transform.worldTransform = this.transform.worldTransform;\n    sprite.anchor.set(-rect.x / rect.width, -rect.y / rect.height);\n\n    sprite._onAnchorUpdate();\n\n    sprite._renderWebGL(renderer);\n  };\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */\n\n\n  Graphics.prototype._renderCanvas = function _renderCanvas(renderer) {\n    if (this.isMask === true) {\n      return;\n    }\n\n    renderer.plugins.graphics.render(this);\n  };\n  /**\n   * Retrieves the bounds of the graphic shape as a rectangle object\n   *\n   * @private\n   */\n\n\n  Graphics.prototype._calculateBounds = function _calculateBounds() {\n    if (this.boundsDirty !== this.dirty) {\n      this.boundsDirty = this.dirty;\n      this.updateLocalBounds();\n      this.cachedSpriteDirty = true;\n    }\n\n    var lb = this._localBounds;\n\n    this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);\n  };\n  /**\n   * Tests if a point is inside this graphics object\n   *\n   * @param {PIXI.Point} point - the point to test\n   * @return {boolean} the result of the test\n   */\n\n\n  Graphics.prototype.containsPoint = function containsPoint(point) {\n    this.worldTransform.applyInverse(point, tempPoint);\n    var graphicsData = this.graphicsData;\n\n    for (var i = 0; i < graphicsData.length; ++i) {\n      var data = graphicsData[i];\n\n      if (!data.fill) {\n        continue;\n      } // only deal with fills..\n\n\n      if (data.shape) {\n        if (data.shape.contains(tempPoint.x, tempPoint.y)) {\n          var hitHole = false;\n\n          if (data.holes) {\n            for (var _i = 0; _i < data.holes.length; _i++) {\n              var hole = data.holes[_i];\n\n              if (hole.contains(tempPoint.x, tempPoint.y)) {\n                hitHole = true;\n                break;\n              }\n            }\n          }\n\n          if (!hitHole) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Update the bounds of the object\n   *\n   */\n\n\n  Graphics.prototype.updateLocalBounds = function updateLocalBounds() {\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n\n    if (this.graphicsData.length) {\n      var shape = 0;\n      var x = 0;\n      var y = 0;\n      var w = 0;\n      var h = 0;\n\n      for (var i = 0; i < this.graphicsData.length; i++) {\n        var data = this.graphicsData[i];\n        var type = data.type;\n        var lineWidth = data.lineWidth;\n        var lineAlignment = data.lineAlignment;\n        var lineOffset = lineWidth * lineAlignment;\n        shape = data.shape;\n\n        if (type === _const.SHAPES.RECT || type === _const.SHAPES.RREC) {\n          x = shape.x - lineOffset;\n          y = shape.y - lineOffset;\n          w = shape.width + lineOffset * 2;\n          h = shape.height + lineOffset * 2;\n          minX = x < minX ? x : minX;\n          maxX = x + w > maxX ? x + w : maxX;\n          minY = y < minY ? y : minY;\n          maxY = y + h > maxY ? y + h : maxY;\n        } else if (type === _const.SHAPES.CIRC) {\n          x = shape.x;\n          y = shape.y;\n          w = shape.radius + lineOffset;\n          h = shape.radius + lineOffset;\n          minX = x - w < minX ? x - w : minX;\n          maxX = x + w > maxX ? x + w : maxX;\n          minY = y - h < minY ? y - h : minY;\n          maxY = y + h > maxY ? y + h : maxY;\n        } else if (type === _const.SHAPES.ELIP) {\n          x = shape.x;\n          y = shape.y;\n          w = shape.width + lineOffset;\n          h = shape.height + lineOffset;\n          minX = x - w < minX ? x - w : minX;\n          maxX = x + w > maxX ? x + w : maxX;\n          minY = y - h < minY ? y - h : minY;\n          maxY = y + h > maxY ? y + h : maxY;\n        } else {\n          // POLY\n          var points = shape.points;\n          var x2 = 0;\n          var y2 = 0;\n          var dx = 0;\n          var dy = 0;\n          var rw = 0;\n          var rh = 0;\n          var cx = 0;\n          var cy = 0;\n\n          for (var j = 0; j + 2 < points.length; j += 2) {\n            x = points[j];\n            y = points[j + 1];\n            x2 = points[j + 2];\n            y2 = points[j + 3];\n            dx = Math.abs(x2 - x);\n            dy = Math.abs(y2 - y);\n            h = lineOffset * 2;\n            w = Math.sqrt(dx * dx + dy * dy);\n\n            if (w < 1e-9) {\n              continue;\n            }\n\n            rw = (h / w * dy + dx) / 2;\n            rh = (h / w * dx + dy) / 2;\n            cx = (x2 + x) / 2;\n            cy = (y2 + y) / 2;\n            minX = cx - rw < minX ? cx - rw : minX;\n            maxX = cx + rw > maxX ? cx + rw : maxX;\n            minY = cy - rh < minY ? cy - rh : minY;\n            maxY = cy + rh > maxY ? cy + rh : maxY;\n          }\n        }\n      }\n    } else {\n      minX = 0;\n      maxX = 0;\n      minY = 0;\n      maxY = 0;\n    }\n\n    var padding = this.boundsPadding;\n    this._localBounds.minX = minX - padding;\n    this._localBounds.maxX = maxX + padding;\n    this._localBounds.minY = minY - padding;\n    this._localBounds.maxY = maxY + padding;\n  };\n  /**\n   * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n   *\n   * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n   * @return {PIXI.GraphicsData} The generated GraphicsData object.\n   */\n\n\n  Graphics.prototype.drawShape = function drawShape(shape) {\n    if (this.currentPath) {\n      // check current path!\n      if (this.currentPath.shape.points.length <= 2) {\n        this.graphicsData.pop();\n      }\n    }\n\n    this.currentPath = null;\n    var data = new _GraphicsData2.default(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, this.nativeLines, shape, this.lineAlignment);\n    this.graphicsData.push(data);\n\n    if (data.type === _const.SHAPES.POLY) {\n      data.shape.closed = data.shape.closed;\n      this.currentPath = data;\n    }\n\n    this.dirty++;\n    return data;\n  };\n  /**\n   * Generates a canvas texture.\n   *\n   * @param {number} scaleMode - The scale mode of the texture.\n   * @param {number} resolution - The resolution of the texture.\n   * @return {PIXI.Texture} The new texture.\n   */\n\n\n  Graphics.prototype.generateCanvasTexture = function generateCanvasTexture(scaleMode) {\n    var resolution = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var bounds = this.getLocalBounds();\n\n    var canvasBuffer = _RenderTexture2.default.create(bounds.width, bounds.height, scaleMode, resolution);\n\n    if (!canvasRenderer) {\n      canvasRenderer = new _CanvasRenderer2.default();\n    }\n\n    this.transform.updateLocalTransform();\n    this.transform.localTransform.copy(tempMatrix);\n    tempMatrix.invert();\n    tempMatrix.tx -= bounds.x;\n    tempMatrix.ty -= bounds.y;\n    canvasRenderer.render(this, canvasBuffer, true, tempMatrix);\n\n    var texture = _Texture2.default.fromCanvas(canvasBuffer.baseTexture._canvasRenderTarget.canvas, scaleMode, 'graphics');\n\n    texture.baseTexture.resolution = resolution;\n    texture.baseTexture.update();\n    return texture;\n  };\n  /**\n   * Closes the current path.\n   *\n   * @return {PIXI.Graphics} Returns itself.\n   */\n\n\n  Graphics.prototype.closePath = function closePath() {\n    // ok so close path assumes next one is a hole!\n    var currentPath = this.currentPath;\n\n    if (currentPath && currentPath.shape) {\n      currentPath.shape.close();\n    }\n\n    return this;\n  };\n  /**\n   * Adds a hole in the current path.\n   *\n   * @return {PIXI.Graphics} Returns itself.\n   */\n\n\n  Graphics.prototype.addHole = function addHole() {\n    // this is a hole!\n    var hole = this.graphicsData.pop();\n    this.currentPath = this.graphicsData[this.graphicsData.length - 1];\n    this.currentPath.addHole(hole.shape);\n    this.currentPath = null;\n    return this;\n  };\n  /**\n   * Destroys the Graphics object.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n   *  options have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have\n   *  their destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n\n\n  Graphics.prototype.destroy = function destroy(options) {\n    _Container.prototype.destroy.call(this, options); // destroy each of the GraphicsData objects\n\n\n    for (var i = 0; i < this.graphicsData.length; ++i) {\n      this.graphicsData[i].destroy();\n    } // for each webgl data entry, destroy the WebGLGraphicsData\n\n\n    for (var id in this._webGL) {\n      for (var j = 0; j < this._webGL[id].data.length; ++j) {\n        this._webGL[id].data[j].destroy();\n      }\n    }\n\n    if (this._spriteRect) {\n      this._spriteRect.destroy();\n    }\n\n    this.graphicsData = null;\n    this.currentPath = null;\n    this._webGL = null;\n    this._localBounds = null;\n  };\n\n  return Graphics;\n}(_Container3.default);\n\nexports.default = Graphics;\nGraphics._SPRITE_TEXTURE = null;\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI.Graphics\n * @name CURVES\n * @type {object}\n * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\n\nGraphics.CURVES = {\n  adaptive: false,\n  maxLength: 10,\n  minSegments: 8,\n  maxSegments: 2048\n};","map":{"version":3,"sources":["../../../src/core/graphics/Graphics.js"],"names":["canvasRenderer","tempMatrix","tempPoint","tempColor1","tempColor2","Graphics","nativeLines","clone","i","_quadraticCurveLength","fromX","fromY","cpX","cpY","toX","toY","ax","ay","bx","by","a","b","c","s","Math","a2","a32","c2","ba","_bezierCurveLength","cpX2","cpY2","n","result","t","t2","t3","nt","nt2","nt3","x","y","dx","dy","prevX","prevY","_segmentsCount","length","lineStyle","lineWidth","color","alpha","alignment","shape","moveTo","lineTo","points","quadraticCurveTo","xa","ya","j","bezierCurveTo","arcTo","x1","y1","x2","y2","radius","a1","b1","b2","mm","dd","cc","tt","k1","k2","j1","j2","cx","cy","px","py","qx","qy","startAngle","endAngle","arc","anticlockwise","sweep","segs","startX","startY","xDiff","yDiff","theta","theta2","cTheta","sTheta","segMinus","remainder","real","angle","beginFill","endFill","drawRect","width","height","drawRoundedRect","drawCircle","drawEllipse","drawPolygon","path","closed","Array","arguments","drawStar","innerRadius","rotation","len","delta","polygon","r","clear","isFastRect","_renderWebGL","renderer","_renderSpriteRect","rect","sprite","fillColor","t1","_renderCanvas","_calculateBounds","lb","containsPoint","point","graphicsData","data","hitHole","hole","updateLocalBounds","minX","maxX","minY","maxY","w","h","type","lineAlignment","lineOffset","rw","rh","padding","drawShape","generateCanvasTexture","scaleMode","resolution","bounds","canvasBuffer","texture","closePath","currentPath","addHole","destroy","options","adaptive","maxLength","minSegments","maxSegments"],"mappings":";;;;AAAA,IAAA,WAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;;;AACA,IAAA,cAAA,GAAA,OAAA,CAAA,2BAAA,CAAA;;;;AACA,IAAA,QAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;;;AACA,IAAA,eAAA,GAAA,OAAA,CAAA,uBAAA,CAAA;;;;AACA,IAAA,eAAA,GAAA,OAAA,CAAA,oCAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,IAAIA,cAAAA,GAAAA,KAAJ,CAAA;AACA,IAAMC,UAAAA,GAAa,IAAA,KAAA,CAAnB,MAAmB,EAAnB;AACA,IAAMC,SAAAA,GAAY,IAAA,KAAA,CAAlB,KAAkB,EAAlB;AACA,IAAMC,UAAAA,GAAa,IAAA,YAAA,CAAnB,CAAmB,CAAnB;AACA,IAAMC,UAAAA,GAAa,IAAA,YAAA,CAAnB,CAAmB,CAAnB;AAEA;;;;;;;;;IAQqBC,Q;;AAEjB;;;;;;AAIA,WAAA,QAAA,GACA;AAAA,QADYC,WACZ,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAD0B,KAC1B;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,QAAA,CAAA;AAGI;;;;;;;;AAHJ,QAAA,KAAA,GAAA,0BAAA,CAAA,IAAA,EACI,UAAA,CAAA,IAAA,CADJ,IACI,CADJ,CAAA;;AASI,IAAA,KAAA,CAAA,SAAA,GAAA,CAAA;AAEA;;;;;;;AAMA,IAAA,KAAA,CAAA,SAAA,GAAA,CAAA;AAEA;;;;;;AAKA,IAAA,KAAA,CAAA,WAAA,GAAA,WAAA;AAEA;;;;;;;AAMA,IAAA,KAAA,CAAA,SAAA,GAAA,CAAA;AAEA;;;;;;;AAMA,IAAA,KAAA,CAAA,aAAA,GAAA,GAAA;AAEA;;;;;;;AAMA,IAAA,KAAA,CAAA,YAAA,GAAA,EAAA;AAEA;;;;;;;;AAOA,IAAA,KAAA,CAAA,IAAA,GAAA,QAAA;AAEA;;;;;;;;;AAQA,IAAA,KAAA,CAAA,SAAA,GAAA,QAAA;AAEA;;;;;;;;;AAQA,IAAA,KAAA,CAAA,SAAA,GAAiB,MAAA,CAAA,WAAA,CAAjB,MAAA;AAEA;;;;;;;AAMA,IAAA,KAAA,CAAA,WAAA,GAAA,IAAA;AAEA;;;;;;AAMA;;AACA,IAAA,KAAA,CAAA,MAAA,GAAA,EAAA;AAEA;;;;;;AAKA,IAAA,KAAA,CAAA,MAAA,GAAA,KAAA;AAEA;;;;;;AAKA,IAAA,KAAA,CAAA,aAAA,GAAA,CAAA;AAEA;;;;;;;AAMA,IAAA,KAAA,CAAA,YAAA,GAAoB,IAAA,QAAA,CAApB,OAAoB,EAApB;AAEA;;;;;;;;AAOA,IAAA,KAAA,CAAA,KAAA,GAAA,CAAA;AAEA;;;;;AAIA,IAAA,KAAA,CAAA,aAAA,GAAqB,CAArB,CAAA;AAEA;;;;;AAIA,IAAA,KAAA,CAAA,UAAA,GAAA,CAAA;AAEA;;;;;AAIA,IAAA,KAAA,CAAA,WAAA,GAAmB,CAAnB,CAAA;AAEA;;;;;;;AAMA,IAAA,KAAA,CAAA,iBAAA,GAAA,KAAA;AAEA,IAAA,KAAA,CAAA,WAAA,GAAA,IAAA;AACA,IAAA,KAAA,CAAA,SAAA,GAAA,KAAA;AAEA,IAAA,KAAA,CAAA,aAAA,GAAA,IAAA;AACA,IAAA,KAAA,CAAA,kBAAA,GAAA,IAAA;AAEA;;;;;;;;;;;;;AA/JJ,WAAA,KAAA;AA2KC;AAED;;;;;;;;qBAMAC,K,oBACA;AACI,QAAMA,KAAAA,GAAQ,IAAd,QAAc,EAAd;AAEAA,IAAAA,KAAAA,CAAAA,UAAAA,GAAmB,KAAnBA,UAAAA;AACAA,IAAAA,KAAAA,CAAAA,SAAAA,GAAkB,KAAlBA,SAAAA;AACAA,IAAAA,KAAAA,CAAAA,SAAAA,GAAkB,KAAlBA,SAAAA;AACAA,IAAAA,KAAAA,CAAAA,SAAAA,GAAkB,KAAlBA,SAAAA;AACAA,IAAAA,KAAAA,CAAAA,aAAAA,GAAsB,KAAtBA,aAAAA;AACAA,IAAAA,KAAAA,CAAAA,IAAAA,GAAa,KAAbA,IAAAA;AACAA,IAAAA,KAAAA,CAAAA,SAAAA,GAAkB,KAAlBA,SAAAA;AACAA,IAAAA,KAAAA,CAAAA,MAAAA,GAAe,KAAfA,MAAAA;AACAA,IAAAA,KAAAA,CAAAA,aAAAA,GAAsB,KAAtBA,aAAAA;AACAA,IAAAA,KAAAA,CAAAA,KAAAA,GAAAA,CAAAA;AACAA,IAAAA,KAAAA,CAAAA,iBAAAA,GAA0B,KAA1BA,iBAAAA,CAbJ,CAeI;;AACA,SAAK,IAAIC,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAI,KAAA,YAAA,CAApB,MAAA,EAA8C,EAA9C,CAAA,EACA;AACID,MAAAA,KAAAA,CAAAA,YAAAA,CAAAA,IAAAA,CAAwB,KAAA,YAAA,CAAA,CAAA,EAAxBA,KAAwB,EAAxBA;AACH;;AAEDA,IAAAA,KAAAA,CAAAA,WAAAA,GAAoBA,KAAAA,CAAAA,YAAAA,CAAmBA,KAAAA,CAAAA,YAAAA,CAAAA,MAAAA,GAAvCA,CAAoBA,CAApBA;AAEAA,IAAAA,KAAAA,CAAAA,iBAAAA;AAEA,WAAA,KAAA;;AAGJ;;;;;;;;;;;;;;;;qBAcAE,qB,kCAAsBC,K,EAAOC,K,EAAOC,G,EAAKC,G,EAAKC,G,EAAKC,G,EACnD;AACI,QAAMC,EAAAA,GAAKN,KAAAA,GAAS,MAATA,GAAAA,GAAX,GAAA;AACA,QAAMO,EAAAA,GAAKN,KAAAA,GAAS,MAATA,GAAAA,GAAX,GAAA;AACA,QAAMO,EAAAA,GAAM,MAAD,GAAC,GAAc,MAA1B,KAAA;AACA,QAAMC,EAAAA,GAAM,MAAD,GAAC,GAAc,MAA1B,KAAA;AACA,QAAMC,CAAAA,GAAI,OAAQJ,EAAAA,GAAD,EAACA,GAAYC,EAAAA,GAA9B,EAAU,CAAV;AACA,QAAMI,CAAAA,GAAI,OAAQL,EAAAA,GAAD,EAACA,GAAYC,EAAAA,GAA9B,EAAU,CAAV;AACA,QAAMK,CAAAA,GAAKJ,EAAAA,GAAD,EAACA,GAAYC,EAAAA,GAAvB,EAAA;AAEA,QAAMI,CAAAA,GAAI,MAAMC,IAAAA,CAAAA,IAAAA,CAAUJ,CAAAA,GAAAA,CAAAA,GAA1B,CAAgBI,CAAhB;AACA,QAAMC,EAAAA,GAAKD,IAAAA,CAAAA,IAAAA,CAAX,CAAWA,CAAX;AACA,QAAME,GAAAA,GAAM,MAAA,CAAA,GAAZ,EAAA;AACA,QAAMC,EAAAA,GAAK,MAAMH,IAAAA,CAAAA,IAAAA,CAAjB,CAAiBA,CAAjB;AACA,QAAMI,EAAAA,GAAKP,CAAAA,GAAX,EAAA;AAEA,WAAO,CACEK,GAAAA,GAAD,CAACA,GACED,EAAAA,GAAAA,CAAAA,IAAUF,CAAAA,GADb,EACGE,CADFC,GAGE,CAAE,MAAA,CAAA,GAAD,CAAC,GAAgBL,CAAAA,GAAlB,CAAA,IACEG,IAAAA,CAAAA,GAAAA,CAAS,CAAE,MAAD,EAAC,GAAD,EAAC,GAAF,CAAA,KAAyBI,EAAAA,GALxC,EAKe,CAATJ,CALN,KAQG,MARV,GAAO,CAAP;;AAWJ;;;;;;;;;;;;;;;;;;qBAgBAK,kB,+BAAmBnB,K,EAAOC,K,EAAOC,G,EAAKC,G,EAAKiB,I,EAAMC,I,EAAMjB,G,EAAKC,G,EAC5D;AACI,QAAMiB,CAAAA,GAAN,EAAA;AACA,QAAIC,MAAAA,GAAJ,GAAA;AACA,QAAIC,CAAAA,GAAJ,GAAA;AACA,QAAIC,EAAAA,GAAJ,GAAA;AACA,QAAIC,EAAAA,GAAJ,GAAA;AACA,QAAIC,EAAAA,GAAJ,GAAA;AACA,QAAIC,GAAAA,GAAJ,GAAA;AACA,QAAIC,GAAAA,GAAJ,GAAA;AACA,QAAIC,CAAAA,GAAJ,GAAA;AACA,QAAIC,CAAAA,GAAJ,GAAA;AACA,QAAIC,EAAAA,GAAJ,GAAA;AACA,QAAIC,EAAAA,GAAJ,GAAA;AACA,QAAIC,KAAAA,GAAJ,KAAA;AACA,QAAIC,KAAAA,GAAJ,KAAA;;AAEA,SAAK,IAAIrC,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,IAAhB,CAAA,EAAwB,EAAxB,CAAA,EACA;AACI0B,MAAAA,CAAAA,GAAI1B,CAAAA,GAAJ0B,CAAAA;AACAC,MAAAA,EAAAA,GAAKD,CAAAA,GAALC,CAAAA;AACAC,MAAAA,EAAAA,GAAKD,EAAAA,GAALC,CAAAA;AACAC,MAAAA,EAAAA,GAAM,MAANA,CAAAA;AACAC,MAAAA,GAAAA,GAAMD,EAAAA,GAANC,EAAAA;AACAC,MAAAA,GAAAA,GAAMD,GAAAA,GAANC,EAAAA;AAEAC,MAAAA,CAAAA,GAAKD,GAAAA,GAAD,KAACA,GAAgB,MAAA,GAAA,GAAA,CAAA,GAAjB,GAACA,GAAwC,MAAA,EAAA,GAAA,EAAA,GAAzC,IAACA,GAAiEH,EAAAA,GAAtEI,GAAAA;AACAC,MAAAA,CAAAA,GAAKF,GAAAA,GAAD,KAACA,GAAgB,MAAA,GAAA,GAAA,CAAA,GAAjB,GAACA,GAAwC,IAAA,EAAA,GAAA,EAAA,GAAzC,IAACA,GAA+DH,EAAAA,GAApEK,GAAAA;AACAC,MAAAA,EAAAA,GAAKE,KAAAA,GAALF,CAAAA;AACAC,MAAAA,EAAAA,GAAKE,KAAAA,GAALF,CAAAA;AACAC,MAAAA,KAAAA,GAAAA,CAAAA;AACAC,MAAAA,KAAAA,GAAAA,CAAAA;AAEAZ,MAAAA,MAAAA,IAAUT,IAAAA,CAAAA,IAAAA,CAAWkB,EAAAA,GAAD,EAACA,GAAYC,EAAAA,GAAjCV,EAAUT,CAAVS;AACH;;AAED,WAAA,MAAA;;AAGJ;;;;;;;;;qBAOAa,c,2BAAeC,M,EACf;AACI,QAAId,MAAAA,GAAST,IAAAA,CAAAA,IAAAA,CAAUuB,MAAAA,GAAS1C,QAAAA,CAAAA,MAAAA,CAAhC,SAAamB,CAAb;;AAEA,QAAIS,MAAAA,GAAS5B,QAAAA,CAAAA,MAAAA,CAAb,WAAA,EACA;AACI4B,MAAAA,MAAAA,GAAS5B,QAAAA,CAAAA,MAAAA,CAAT4B,WAAAA;AAFJ,KAAA,MAIK,IAAIA,MAAAA,GAAS5B,QAAAA,CAAAA,MAAAA,CAAb,WAAA,EACL;AACI4B,MAAAA,MAAAA,GAAS5B,QAAAA,CAAAA,MAAAA,CAAT4B,WAAAA;AACH;;AAED,WAAA,MAAA;;AAGJ;;;;;;;;;;;;qBAUAe,S,wBACA;AAAA,QADUC,SACV,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADsB,CACtB;AAAA,QADyBC,KACzB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADiC,CACjC;AAAA,QADoCC,KACpC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAD4C,CAC5C;AAAA,QAD+CC,SAC/C,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAD2D,GAC3D;AACI,SAAA,SAAA,GAAA,SAAA;AACA,SAAA,SAAA,GAAA,KAAA;AACA,SAAA,SAAA,GAAA,KAAA;AACA,SAAA,aAAA,GAAA,SAAA;;AAEA,QAAI,KAAJ,WAAA,EACA;AACI,UAAI,KAAA,WAAA,CAAA,KAAA,CAAA,MAAA,CAAJ,MAAA,EACA;AACI;AACA,YAAMC,KAAAA,GAAQ,IAAA,KAAA,CAAA,OAAA,CAAY,KAAA,WAAA,CAAA,KAAA,CAAA,MAAA,CAAA,KAAA,CAAoC,CAA9D,CAA0B,CAAZ,CAAd;AAEAA,QAAAA,KAAAA,CAAAA,MAAAA,GAAAA,KAAAA;AAEA,aAAA,SAAA,CAAA,KAAA;AAPJ,OAAA,MAUA;AACI;AACA,aAAA,WAAA,CAAA,SAAA,GAA6B,KAA7B,SAAA;AACA,aAAA,WAAA,CAAA,SAAA,GAA6B,KAA7B,SAAA;AACA,aAAA,WAAA,CAAA,SAAA,GAA6B,KAA7B,SAAA;AACA,aAAA,WAAA,CAAA,aAAA,GAAiC,KAAjC,aAAA;AACH;AACJ;;AAED,WAAA,IAAA;;AAGJ;;;;;;;;;qBAOAC,M,mBAAOd,C,EAAGC,C,EACV;AACI,QAAMY,KAAAA,GAAQ,IAAA,KAAA,CAAA,OAAA,CAAY,CAAA,CAAA,EAA1B,CAA0B,CAAZ,CAAd;AAEAA,IAAAA,KAAAA,CAAAA,MAAAA,GAAAA,KAAAA;AACA,SAAA,SAAA,CAAA,KAAA;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;;;qBAQAE,M,mBAAOf,C,EAAGC,C,EACV;AACI,QAAMe,MAAAA,GAAS,KAAA,WAAA,CAAA,KAAA,CAAf,MAAA;AAEA,QAAM9C,KAAAA,GAAQ8C,MAAAA,CAAOA,MAAAA,CAAAA,MAAAA,GAArB,CAAcA,CAAd;AACA,QAAM7C,KAAAA,GAAQ6C,MAAAA,CAAOA,MAAAA,CAAAA,MAAAA,GAArB,CAAcA,CAAd;;AAEA,QAAI9C,KAAAA,KAAAA,CAAAA,IAAeC,KAAAA,KAAnB,CAAA,EACA;AACI6C,MAAAA,MAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AACA,WAAA,KAAA;AACH;;AAED,WAAA,IAAA;;AAGJ;;;;;;;;;;;;qBAUAC,gB,6BAAiB7C,G,EAAKC,G,EAAKC,G,EAAKC,G,EAChC;AACI,QAAI,KAAJ,WAAA,EACA;AACI,UAAI,KAAA,WAAA,CAAA,KAAA,CAAA,MAAA,CAAA,MAAA,KAAJ,CAAA,EACA;AACI,aAAA,WAAA,CAAA,KAAA,CAAA,MAAA,GAAgC,CAAA,CAAA,EAAhC,CAAgC,CAAhC;AACH;AALL,KAAA,MAQA;AACI,WAAA,MAAA,CAAA,CAAA,EAAA,CAAA;AACH;;AAED,QAAMyC,MAAAA,GAAS,KAAA,WAAA,CAAA,KAAA,CAAf,MAAA;AACA,QAAIE,EAAAA,GAAJ,CAAA;AACA,QAAIC,EAAAA,GAAJ,CAAA;;AAEA,QAAIH,MAAAA,CAAAA,MAAAA,KAAJ,CAAA,EACA;AACI,WAAA,MAAA,CAAA,CAAA,EAAA,CAAA;AACH;;AAED,QAAM9C,KAAAA,GAAQ8C,MAAAA,CAAOA,MAAAA,CAAAA,MAAAA,GAArB,CAAcA,CAAd;AACA,QAAM7C,KAAAA,GAAQ6C,MAAAA,CAAOA,MAAAA,CAAAA,MAAAA,GAArB,CAAcA,CAAd;AACA,QAAMxB,CAAAA,GAAI3B,QAAAA,CAAAA,MAAAA,CAAAA,QAAAA,GACE,KAAA,cAAA,CAAoB,KAAA,qBAAA,CAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EADtBA,GACsB,CAApB,CADFA,GAAV,EAAA;;AAIA,SAAK,IAAIG,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,IAAhB,CAAA,EAAwB,EAAxB,CAAA,EACA;AACI,UAAMoD,CAAAA,GAAIpD,CAAAA,GAAV,CAAA;AAEAkD,MAAAA,EAAAA,GAAKhD,KAAAA,GAAS,CAACE,GAAAA,GAAD,KAAA,IAAd8C,CAAAA;AACAC,MAAAA,EAAAA,GAAKhD,KAAAA,GAAS,CAACE,GAAAA,GAAD,KAAA,IAAd8C,CAAAA;AAEAH,MAAAA,MAAAA,CAAAA,IAAAA,CAAYE,EAAAA,GAAM,CAAE9C,GAAAA,GAAO,CAACE,GAAAA,GAAD,GAAA,IAAR,CAACF,GAAF,EAAA,IAAlB4C,CAAAA,EACIG,EAAAA,GAAM,CAAE9C,GAAAA,GAAO,CAACE,GAAAA,GAAD,GAAA,IAAR,CAACF,GAAF,EAAA,IADV2C,CAAAA;AAEH;;AAED,SAAA,KAAA;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;;;;;;qBAWAK,a,0BAAcjD,G,EAAKC,G,EAAKiB,I,EAAMC,I,EAAMjB,G,EAAKC,G,EACzC;AACI,QAAI,KAAJ,WAAA,EACA;AACI,UAAI,KAAA,WAAA,CAAA,KAAA,CAAA,MAAA,CAAA,MAAA,KAAJ,CAAA,EACA;AACI,aAAA,WAAA,CAAA,KAAA,CAAA,MAAA,GAAgC,CAAA,CAAA,EAAhC,CAAgC,CAAhC;AACH;AALL,KAAA,MAQA;AACI,WAAA,MAAA,CAAA,CAAA,EAAA,CAAA;AACH;;AAED,QAAMyC,MAAAA,GAAS,KAAA,WAAA,CAAA,KAAA,CAAf,MAAA;AAEA,QAAM9C,KAAAA,GAAQ8C,MAAAA,CAAOA,MAAAA,CAAAA,MAAAA,GAArB,CAAcA,CAAd;AACA,QAAM7C,KAAAA,GAAQ6C,MAAAA,CAAOA,MAAAA,CAAAA,MAAAA,GAArB,CAAcA,CAAd;AAEAA,IAAAA,MAAAA,CAAAA,MAAAA,IAAAA,CAAAA;AAEA,QAAMxB,CAAAA,GAAI3B,QAAAA,CAAAA,MAAAA,CAAAA,QAAAA,GACE,KAAA,cAAA,CAAoB,KAAA,kBAAA,CAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GAAA,EADtBA,GACsB,CAApB,CADFA,GAAV,EAAA;AAIA,KAAA,GAAA,eAAA,CAAA,OAAA,EAAA,KAAA,EAAA,KAAA,EAAA,GAAA,EAAA,GAAA,EAAA,IAAA,EAAA,IAAA,EAAA,GAAA,EAAA,GAAA,EAAA,CAAA,EAAA,MAAA;AAEA,SAAA,KAAA;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;;;;;;;qBAYAyD,K,kBAAMC,E,EAAIC,E,EAAIC,E,EAAIC,E,EAAIC,M,EACtB;AACI,QAAI,KAAJ,WAAA,EACA;AACI,UAAI,KAAA,WAAA,CAAA,KAAA,CAAA,MAAA,CAAA,MAAA,KAAJ,CAAA,EACA;AACI,aAAA,WAAA,CAAA,KAAA,CAAA,MAAA,CAAA,IAAA,CAAA,EAAA,EAAA,EAAA;AACH;AALL,KAAA,MAQA;AACI,WAAA,MAAA,CAAA,EAAA,EAAA,EAAA;AACH;;AAED,QAAMX,MAAAA,GAAS,KAAA,WAAA,CAAA,KAAA,CAAf,MAAA;AACA,QAAM9C,KAAAA,GAAQ8C,MAAAA,CAAOA,MAAAA,CAAAA,MAAAA,GAArB,CAAcA,CAAd;AACA,QAAM7C,KAAAA,GAAQ6C,MAAAA,CAAOA,MAAAA,CAAAA,MAAAA,GAArB,CAAcA,CAAd;AACA,QAAMY,EAAAA,GAAKzD,KAAAA,GAAX,EAAA;AACA,QAAM0D,EAAAA,GAAK3D,KAAAA,GAAX,EAAA;AACA,QAAMe,EAAAA,GAAKyC,EAAAA,GAAX,EAAA;AACA,QAAMI,EAAAA,GAAKL,EAAAA,GAAX,EAAA;AACA,QAAMM,EAAAA,GAAK/C,IAAAA,CAAAA,GAAAA,CAAU4C,EAAAA,GAAD,EAACA,GAAYC,EAAAA,GAAjC,EAAW7C,CAAX;;AAEA,QAAI+C,EAAAA,GAAAA,MAAAA,IAAeJ,MAAAA,KAAnB,CAAA,EACA;AACI,UAAIX,MAAAA,CAAOA,MAAAA,CAAAA,MAAAA,GAAPA,CAAAA,CAAAA,KAAAA,EAAAA,IAAoCA,MAAAA,CAAOA,MAAAA,CAAAA,MAAAA,GAAPA,CAAAA,CAAAA,KAAxC,EAAA,EACA;AACIA,QAAAA,MAAAA,CAAAA,IAAAA,CAAAA,EAAAA,EAAAA,EAAAA;AACH;AALL,KAAA,MAQA;AACI,UAAMgB,EAAAA,GAAMJ,EAAAA,GAAD,EAACA,GAAYC,EAAAA,GAAxB,EAAA;AACA,UAAMI,EAAAA,GAAMhD,EAAAA,GAAD,EAACA,GAAY6C,EAAAA,GAAxB,EAAA;AACA,UAAMI,EAAAA,GAAMN,EAAAA,GAAD,EAACA,GAAYC,EAAAA,GAAxB,EAAA;AACA,UAAMM,EAAAA,GAAKR,MAAAA,GAAS3C,IAAAA,CAAAA,IAAAA,CAAT2C,EAAS3C,CAAT2C,GAAX,EAAA;AACA,UAAMS,EAAAA,GAAKT,MAAAA,GAAS3C,IAAAA,CAAAA,IAAAA,CAAT2C,EAAS3C,CAAT2C,GAAX,EAAA;AACA,UAAMU,EAAAA,GAAKF,EAAAA,GAAAA,EAAAA,GAAX,EAAA;AACA,UAAMG,EAAAA,GAAKF,EAAAA,GAAAA,EAAAA,GAAX,EAAA;AACA,UAAMG,EAAAA,GAAMJ,EAAAA,GAAD,EAACA,GAAYC,EAAAA,GAAxB,EAAA;AACA,UAAMI,EAAAA,GAAML,EAAAA,GAAD,EAACA,GAAYC,EAAAA,GAAxB,EAAA;AACA,UAAMK,EAAAA,GAAKZ,EAAAA,IAAMO,EAAAA,GAAjB,EAAWP,CAAX;AACA,UAAMa,EAAAA,GAAKd,EAAAA,IAAMQ,EAAAA,GAAjB,EAAWR,CAAX;AACA,UAAMe,EAAAA,GAAKb,EAAAA,IAAMK,EAAAA,GAAjB,EAAWL,CAAX;AACA,UAAMc,EAAAA,GAAK3D,EAAAA,IAAMkD,EAAAA,GAAjB,EAAWlD,CAAX;AACA,UAAM4D,UAAAA,GAAa7D,IAAAA,CAAAA,KAAAA,CAAW0D,EAAAA,GAAX1D,EAAAA,EAAoByD,EAAAA,GAAvC,EAAmBzD,CAAnB;AACA,UAAM8D,QAAAA,GAAW9D,IAAAA,CAAAA,KAAAA,CAAW4D,EAAAA,GAAX5D,EAAAA,EAAoB2D,EAAAA,GAArC,EAAiB3D,CAAjB;AAEA,WAAA,GAAA,CAASuD,EAAAA,GAAT,EAAA,EAAkBC,EAAAA,GAAlB,EAAA,EAAA,MAAA,EAAA,UAAA,EAAA,QAAA,EAAyDX,EAAAA,GAAAA,EAAAA,GAAUC,EAAAA,GAAnE,EAAA;AACH;;AAED,SAAA,KAAA;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;;;;;;;;;qBAcAiB,G,gBAAIR,E,EAAIC,E,EAAIb,M,EAAQkB,U,EAAYC,Q,EAChC;AAAA,QAD0CE,aAC1C,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAD0D,KAC1D;;AACI,QAAIH,UAAAA,KAAJ,QAAA,EACA;AACI,aAAA,IAAA;AACH;;AAED,QAAI,CAAA,aAAA,IAAkBC,QAAAA,IAAtB,UAAA,EACA;AACIA,MAAAA,QAAAA,IAAAA,MAAAA,CAAAA,IAAAA;AAFJ,KAAA,MAIK,IAAIE,aAAAA,IAAiBH,UAAAA,IAArB,QAAA,EACL;AACIA,MAAAA,UAAAA,IAAAA,MAAAA,CAAAA,IAAAA;AACH;;AAED,QAAMI,KAAAA,GAAQH,QAAAA,GAAd,UAAA;AACA,QAAMI,IAAAA,GAAOrF,QAAAA,CAAAA,MAAAA,CAAAA,QAAAA,GACE,KAAA,cAAA,CAAoBmB,IAAAA,CAAAA,GAAAA,CAAAA,KAAAA,IADtBnB,MACE,CADFA,GAEEmB,IAAAA,CAAAA,IAAAA,CAAUA,IAAAA,CAAAA,GAAAA,CAAAA,KAAAA,IAAAA,MAAAA,CAAVA,IAAAA,IAFf,EAAA;;AAIA,QAAIiE,KAAAA,KAAJ,CAAA,EACA;AACI,aAAA,IAAA;AACH;;AAED,QAAME,MAAAA,GAASZ,EAAAA,GAAMvD,IAAAA,CAAAA,GAAAA,CAAAA,UAAAA,IAArB,MAAA;AACA,QAAMoE,MAAAA,GAASZ,EAAAA,GAAMxD,IAAAA,CAAAA,GAAAA,CAAAA,UAAAA,IAArB,MAAA,CA1BJ,CA4BI;;AACA,QAAIgC,MAAAA,GAAS,KAAA,WAAA,GAAmB,KAAA,WAAA,CAAA,KAAA,CAAnB,MAAA,GAAb,IAAA;;AAEA,QAAA,MAAA,EACA;AACI;AACA,UAAMqC,KAAAA,GAAQrE,IAAAA,CAAAA,GAAAA,CAASgC,MAAAA,CAAOA,MAAAA,CAAAA,MAAAA,GAAPA,CAAAA,CAAAA,GAAvB,MAAchC,CAAd;AACA,UAAMsE,KAAAA,GAAQtE,IAAAA,CAAAA,GAAAA,CAASgC,MAAAA,CAAOA,MAAAA,CAAAA,MAAAA,GAAPA,CAAAA,CAAAA,GAAvB,MAAchC,CAAd;;AAEA,UAAIqE,KAAAA,GAAAA,KAAAA,IAAiBC,KAAAA,GAArB,KAAA,EACA,CACI;AACA;AAHJ,OAAA,MAMA;AACItC,QAAAA,MAAAA,CAAAA,IAAAA,CAAAA,MAAAA,EAAAA,MAAAA;AACH;AAdL,KAAA,MAiBA;AACI,WAAA,MAAA,CAAA,MAAA,EAAA,MAAA;AACAA,MAAAA,MAAAA,GAAS,KAAA,WAAA,CAAA,KAAA,CAATA,MAAAA;AACH;;AAED,QAAMuC,KAAAA,GAAQN,KAAAA,IAASC,IAAAA,GAAvB,CAAcD,CAAd;AACA,QAAMO,MAAAA,GAASD,KAAAA,GAAf,CAAA;AAEA,QAAME,MAAAA,GAASzE,IAAAA,CAAAA,GAAAA,CAAf,KAAeA,CAAf;AACA,QAAM0E,MAAAA,GAAS1E,IAAAA,CAAAA,GAAAA,CAAf,KAAeA,CAAf;AAEA,QAAM2E,QAAAA,GAAWT,IAAAA,GAAjB,CAAA;AAEA,QAAMU,SAAAA,GAAaD,QAAAA,GAAD,CAACA,GAAnB,QAAA;;AAEA,SAAK,IAAI3F,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,IAAhB,QAAA,EAA+B,EAA/B,CAAA,EACA;AACI,UAAM6F,IAAAA,GAAO7F,CAAAA,GAAK4F,SAAAA,GAAlB,CAAA;AAEA,UAAME,KAAAA,GAAUP,KAAD,GAAA,UAACA,GAAuBC,MAAAA,GAAvC,IAAA;AAEA,UAAM1E,CAAAA,GAAIE,IAAAA,CAAAA,GAAAA,CAAV,KAAUA,CAAV;AACA,UAAMD,CAAAA,GAAI,CAACC,IAAAA,CAAAA,GAAAA,CAAX,KAAWA,CAAX;AAEAgC,MAAAA,MAAAA,CAAAA,IAAAA,CACK,CAAEyC,MAAAA,GAAD,CAACA,GAAeC,MAAAA,GAAjB,CAAA,IAAD,MAAC,GADL1C,EAAAA,EAEK,CAAEyC,MAAAA,GAAS,CAAV,CAACA,GAAgBC,MAAAA,GAAlB,CAAA,IAAD,MAAC,GAFL1C,EAAAA;AAIH;;AAED,SAAA,KAAA;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;;;qBAQA+C,S,wBACA;AAAA,QADUrD,KACV,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADkB,CAClB;AAAA,QADqBC,KACrB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAD6B,CAC7B;AACI,SAAA,OAAA,GAAA,IAAA;AACA,SAAA,SAAA,GAAA,KAAA;AACA,SAAA,SAAA,GAAA,KAAA;;AAEA,QAAI,KAAJ,WAAA,EACA;AACI,UAAI,KAAA,WAAA,CAAA,KAAA,CAAA,MAAA,CAAA,MAAA,IAAJ,CAAA,EACA;AACI,aAAA,WAAA,CAAA,IAAA,GAAwB,KAAxB,OAAA;AACA,aAAA,WAAA,CAAA,SAAA,GAA6B,KAA7B,SAAA;AACA,aAAA,WAAA,CAAA,SAAA,GAA6B,KAA7B,SAAA;AACH;AACJ;;AAED,WAAA,IAAA;;AAGJ;;;;;;;qBAKAqD,O,sBACA;AACI,SAAA,OAAA,GAAA,KAAA;AACA,SAAA,SAAA,GAAA,IAAA;AACA,SAAA,SAAA,GAAA,CAAA;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;;;qBAQAC,Q,qBAASjE,C,EAAGC,C,EAAGiE,K,EAAOC,M,EACtB;AACI,SAAA,SAAA,CAAe,IAAA,KAAA,CAAA,SAAA,CAAA,CAAA,EAAA,CAAA,EAAA,KAAA,EAAf,MAAe,CAAf;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;;;;qBASAC,e,4BAAgBpE,C,EAAGC,C,EAAGiE,K,EAAOC,M,EAAQxC,M,EACrC;AACI,SAAA,SAAA,CAAe,IAAA,KAAA,CAAA,gBAAA,CAAA,CAAA,EAAA,CAAA,EAAA,KAAA,EAAA,MAAA,EAAf,MAAe,CAAf;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;;;qBAQA0C,U,uBAAWrE,C,EAAGC,C,EAAG0B,M,EACjB;AACI,SAAA,SAAA,CAAe,IAAA,KAAA,CAAA,MAAA,CAAA,CAAA,EAAA,CAAA,EAAf,MAAe,CAAf;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;;;;qBASA2C,W,wBAAYtE,C,EAAGC,C,EAAGiE,K,EAAOC,M,EACzB;AACI,SAAA,SAAA,CAAe,IAAA,KAAA,CAAA,OAAA,CAAA,CAAA,EAAA,CAAA,EAAA,KAAA,EAAf,MAAe,CAAf;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;qBAMAI,W,wBAAYC,I,EACZ;AACI;AACA;AACA,QAAIxD,MAAAA,GAAJ,IAAA;AAEA,QAAIyD,MAAAA,GAAJ,IAAA;;AAEA,QAAIzD,MAAAA,YAAAA,KAAAA,CAAJ,OAAA,EACA;AACIyD,MAAAA,MAAAA,GAASzD,MAAAA,CAATyD,MAAAA;AACAzD,MAAAA,MAAAA,GAASA,MAAAA,CAATA,MAAAA;AACH;;AAED,QAAI,CAAC0D,KAAAA,CAAAA,OAAAA,CAAL,MAAKA,CAAL,EACA;AACI;AACA;AACA1D,MAAAA,MAAAA,GAAS,IAAA,KAAA,CAAU2D,SAAAA,CAAnB3D,MAAS,CAATA;;AAEA,WAAK,IAAIhD,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAIgD,MAAAA,CAApB,MAAA,EAAmC,EAAnC,CAAA,EACA;AACIA,QAAAA,MAAAA,CAAAA,CAAAA,CAAAA,GAAY2D,SAAAA,CADhB,CACgBA,CAAZ3D,CADJ,CAC8B;AAC7B;AACJ;;AAED,QAAMH,KAAAA,GAAQ,IAAA,KAAA,CAAA,OAAA,CAAd,MAAc,CAAd;AAEAA,IAAAA,KAAAA,CAAAA,MAAAA,GAAAA,MAAAA;AAEA,SAAA,SAAA,CAAA,KAAA;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;;;;;;qBAWA+D,Q,qBAAS5E,C,EAAGC,C,EAAGe,M,EAAQW,M,EAAQkD,W,EAC/B;AAAA,QAD4CC,QAC5C,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADuD,CACvD;AACID,IAAAA,WAAAA,GAAcA,WAAAA,IAAelD,MAAAA,GAA7BkD,CAAAA;AAEA,QAAMhC,UAAAA,GAAc,CAAA,CAAA,GAAK7D,IAAAA,CAAL,EAAA,GAAD,CAAC,GAApB,QAAA;AACA,QAAM+F,GAAAA,GAAM/D,MAAAA,GAAZ,CAAA;AACA,QAAMgE,KAAAA,GAAQ,MAAA,CAAA,IAAA,GAAd,GAAA;AACA,QAAMC,OAAAA,GAAN,EAAA;;AAEA,SAAK,IAAIjH,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAhB,GAAA,EAAyBA,CAAzB,EAAA,EACA;AACI,UAAMkH,CAAAA,GAAIlH,CAAAA,GAAAA,CAAAA,GAAAA,WAAAA,GAAV,MAAA;AACA,UAAM8F,KAAAA,GAAS9F,CAAAA,GAAD,KAACA,GAAf,UAAA;AAEAiH,MAAAA,OAAAA,CAAAA,IAAAA,CACIjF,CAAAA,GAAKkF,CAAAA,GAAIlG,IAAAA,CAAAA,GAAAA,CADbiG,KACajG,CADbiG,EAEIhF,CAAAA,GAAKiF,CAAAA,GAAIlG,IAAAA,CAAAA,GAAAA,CAFbiG,KAEajG,CAFbiG;AAIH;;AAED,WAAO,KAAA,WAAA,CAAP,OAAO,CAAP;;AAGJ;;;;;;;qBAKAE,K,oBACA;AACI,QAAI,KAAA,SAAA,IAAkB,KAAlB,OAAA,IAAkC,KAAA,YAAA,CAAA,MAAA,GAAtC,CAAA,EACA;AACI,WAAA,SAAA,GAAA,CAAA;AACA,WAAA,aAAA,GAAA,GAAA;AAEA,WAAA,OAAA,GAAA,KAAA;AAEA,WAAA,WAAA,GAAmB,CAAnB,CAAA;AACA,WAAA,eAAA,GAAuB,CAAvB,CAAA;AACA,WAAA,KAAA;AACA,WAAA,UAAA;AACA,WAAA,YAAA,CAAA,MAAA,GAAA,CAAA;AACH;;AAED,SAAA,WAAA,GAAA,IAAA;AACA,SAAA,WAAA,GAAA,IAAA;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;qBAMAC,U,yBACA;AACI,WAAO,KAAA,YAAA,CAAA,MAAA,KAAA,CAAA,IACA,KAAA,YAAA,CAAA,CAAA,EAAA,KAAA,CAAA,IAAA,KAAoC,MAAA,CAAA,MAAA,CADpC,IAAA,IAEA,CAAC,KAAA,YAAA,CAAA,CAAA,EAFR,SAAA;;AAKJ;;;;;;;;qBAMAC,Y,yBAAaC,Q,EACb;AACI;AACA,QAAI,KAAA,KAAA,KAAe,KAAnB,aAAA,EACA;AACI,WAAA,aAAA,GAAqB,KAArB,KAAA;AACA,WAAA,SAAA,GAAiB,KAAjB,UAAiB,EAAjB;AACH,KANL,CAQI;;;AACA,QAAI,KAAJ,SAAA,EACA;AACI,WAAA,iBAAA,CAAA,QAAA;AAFJ,KAAA,MAKA;AACIA,MAAAA,QAAAA,CAAAA,iBAAAA,CAA2BA,QAAAA,CAAAA,OAAAA,CAA3BA,QAAAA;AACAA,MAAAA,QAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,MAAAA,CAAAA,IAAAA;AACH;;AAGL;;;;;;;;qBAMAC,iB,8BAAkBD,Q,EAClB;AACI,QAAME,IAAAA,GAAO,KAAA,YAAA,CAAA,CAAA,EAAb,KAAA;;AAEA,QAAI,CAAC,KAAL,WAAA,EACA;AACI,WAAA,WAAA,GAAmB,IAAA,QAAA,CAAA,OAAA,CAAW,IAAA,SAAA,CAAA,OAAA,CAAY,SAAA,CAAA,OAAA,CAA1C,KAA8B,CAAX,CAAnB;AACH;;AAED,QAAMC,MAAAA,GAAS,KAAf,WAAA;AACA,QAAMC,SAAAA,GAAY,KAAA,YAAA,CAAA,CAAA,EAAlB,SAAA;;AAEA,QAAI,KAAA,IAAA,KAAJ,QAAA,EACA;AACID,MAAAA,MAAAA,CAAAA,IAAAA,GAAAA,SAAAA;AAFJ,KAAA,MAIK,IAAI,KAAA,IAAA,KAAc,KAAd,aAAA,IAAoCC,SAAAA,KAAc,KAAtD,kBAAA,EACL;AACI,UAAMC,EAAAA,GAAN,UAAA;AACA,UAAMhG,EAAAA,GAAN,UAAA;AAEA,OAAA,GAAA,MAAA,CAAA,OAAA,EAAA,SAAA,EAAA,EAAA;AACA,OAAA,GAAA,MAAA,CAAA,OAAA,EAAQ,KAAR,IAAA,EAAA,EAAA;AAEAgG,MAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAShG,EAAAA,CAATgG,CAAShG,CAATgG;AACAA,MAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAShG,EAAAA,CAATgG,CAAShG,CAATgG;AACAA,MAAAA,EAAAA,CAAAA,CAAAA,CAAAA,IAAShG,EAAAA,CAATgG,CAAShG,CAATgG;AAEAF,MAAAA,MAAAA,CAAAA,IAAAA,GAAc,CAAA,GAAA,MAAA,CAAA,OAAA,EAAdA,EAAc,CAAdA;AAEA,WAAA,aAAA,GAAqB,KAArB,IAAA;AACA,WAAA,kBAAA,GAAA,SAAA;AACH;;AAEDA,IAAAA,MAAAA,CAAAA,KAAAA,GAAe,KAAA,YAAA,CAAA,CAAA,EAAfA,SAAAA;AACAA,IAAAA,MAAAA,CAAAA,UAAAA,GAAoB,KAAA,UAAA,GAAkBA,MAAAA,CAAtCA,KAAAA;AACAA,IAAAA,MAAAA,CAAAA,SAAAA,GAAmB,KAAnBA,SAAAA;AAEAA,IAAAA,MAAAA,CAAAA,QAAAA,CAAAA,MAAAA,CAAAA,KAAAA,GAA+BD,IAAAA,CAA/BC,KAAAA;AACAA,IAAAA,MAAAA,CAAAA,QAAAA,CAAAA,MAAAA,CAAAA,MAAAA,GAAgCD,IAAAA,CAAhCC,MAAAA;AAEAA,IAAAA,MAAAA,CAAAA,SAAAA,CAAAA,cAAAA,GAAkC,KAAA,SAAA,CAAlCA,cAAAA;AAEAA,IAAAA,MAAAA,CAAAA,MAAAA,CAAAA,GAAAA,CAAkB,CAACD,IAAAA,CAAD,CAAA,GAAUA,IAAAA,CAA5BC,KAAAA,EAAwC,CAACD,IAAAA,CAAD,CAAA,GAAUA,IAAAA,CAAlDC,MAAAA;;AACAA,IAAAA,MAAAA,CAAAA,eAAAA;;AAEAA,IAAAA,MAAAA,CAAAA,YAAAA,CAAAA,QAAAA;;AAGJ;;;;;;;;qBAMAG,a,0BAAcN,Q,EACd;AACI,QAAI,KAAA,MAAA,KAAJ,IAAA,EACA;AACI;AACH;;AAEDA,IAAAA,QAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,MAAAA,CAAAA,IAAAA;;AAGJ;;;;;;;qBAKAO,gB,+BACA;AACI,QAAI,KAAA,WAAA,KAAqB,KAAzB,KAAA,EACA;AACI,WAAA,WAAA,GAAmB,KAAnB,KAAA;AACA,WAAA,iBAAA;AAEA,WAAA,iBAAA,GAAA,IAAA;AACH;;AAED,QAAMC,EAAAA,GAAK,KAAX,YAAA;;AAEA,SAAA,OAAA,CAAA,QAAA,CAAsB,KAAtB,SAAA,EAAsCA,EAAAA,CAAtC,IAAA,EAA+CA,EAAAA,CAA/C,IAAA,EAAwDA,EAAAA,CAAxD,IAAA,EAAiEA,EAAAA,CAAjE,IAAA;;AAGJ;;;;;;;;qBAMAC,a,0BAAcC,K,EACd;AACI,SAAA,cAAA,CAAA,YAAA,CAAA,KAAA,EAAA,SAAA;AAEA,QAAMC,YAAAA,GAAe,KAArB,YAAA;;AAEA,SAAK,IAAIjI,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAIiI,YAAAA,CAApB,MAAA,EAAyC,EAAzC,CAAA,EACA;AACI,UAAMC,IAAAA,GAAOD,YAAAA,CAAb,CAAaA,CAAb;;AAEA,UAAI,CAACC,IAAAA,CAAL,IAAA,EACA;AACI;AACH,OANL,CAQI;;;AACA,UAAIA,IAAAA,CAAJ,KAAA,EACA;AACI,YAAIA,IAAAA,CAAAA,KAAAA,CAAAA,QAAAA,CAAoBxI,SAAAA,CAApBwI,CAAAA,EAAiCxI,SAAAA,CAArC,CAAIwI,CAAJ,EACA;AACI,cAAIC,OAAAA,GAAJ,KAAA;;AAEA,cAAID,IAAAA,CAAJ,KAAA,EACA;AACI,iBAAK,IAAIlI,EAAAA,GAAT,CAAA,EAAgBA,EAAAA,GAAIkI,IAAAA,CAAAA,KAAAA,CAApB,MAAA,EAAuClI,EAAvC,EAAA,EACA;AACI,kBAAMoI,IAAAA,GAAOF,IAAAA,CAAAA,KAAAA,CAAb,EAAaA,CAAb;;AAEA,kBAAIE,IAAAA,CAAAA,QAAAA,CAAc1I,SAAAA,CAAd0I,CAAAA,EAA2B1I,SAAAA,CAA/B,CAAI0I,CAAJ,EACA;AACID,gBAAAA,OAAAA,GAAAA,IAAAA;AACA;AACH;AACJ;AACJ;;AAED,cAAI,CAAJ,OAAA,EACA;AACI,mBAAA,IAAA;AACH;AACJ;AACJ;AACJ;;AAED,WAAA,KAAA;;AAGJ;;;;;;qBAIAE,iB,gCACA;AACI,QAAIC,IAAAA,GAAJ,QAAA;AACA,QAAIC,IAAAA,GAAO,CAAX,QAAA;AAEA,QAAIC,IAAAA,GAAJ,QAAA;AACA,QAAIC,IAAAA,GAAO,CAAX,QAAA;;AAEA,QAAI,KAAA,YAAA,CAAJ,MAAA,EACA;AACI,UAAI5F,KAAAA,GAAJ,CAAA;AACA,UAAIb,CAAAA,GAAJ,CAAA;AACA,UAAIC,CAAAA,GAAJ,CAAA;AACA,UAAIyG,CAAAA,GAAJ,CAAA;AACA,UAAIC,CAAAA,GAAJ,CAAA;;AAEA,WAAK,IAAI3I,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAI,KAAA,YAAA,CAApB,MAAA,EAA8CA,CAA9C,EAAA,EACA;AACI,YAAMkI,IAAAA,GAAO,KAAA,YAAA,CAAb,CAAa,CAAb;AACA,YAAMU,IAAAA,GAAOV,IAAAA,CAAb,IAAA;AACA,YAAMzF,SAAAA,GAAYyF,IAAAA,CAAlB,SAAA;AACA,YAAMW,aAAAA,GAAgBX,IAAAA,CAAtB,aAAA;AAEA,YAAMY,UAAAA,GAAarG,SAAAA,GAAnB,aAAA;AAEAI,QAAAA,KAAAA,GAAQqF,IAAAA,CAARrF,KAAAA;;AAEA,YAAI+F,IAAAA,KAAS,MAAA,CAAA,MAAA,CAATA,IAAAA,IAAwBA,IAAAA,KAAS,MAAA,CAAA,MAAA,CAArC,IAAA,EACA;AACI5G,UAAAA,CAAAA,GAAIa,KAAAA,CAAAA,CAAAA,GAAJb,UAAAA;AACAC,UAAAA,CAAAA,GAAIY,KAAAA,CAAAA,CAAAA,GAAJZ,UAAAA;AACAyG,UAAAA,CAAAA,GAAI7F,KAAAA,CAAAA,KAAAA,GAAeiG,UAAAA,GAAnBJ,CAAAA;AACAC,UAAAA,CAAAA,GAAI9F,KAAAA,CAAAA,MAAAA,GAAgBiG,UAAAA,GAApBH,CAAAA;AAEAL,UAAAA,IAAAA,GAAOtG,CAAAA,GAAAA,IAAAA,GAAAA,CAAAA,GAAPsG,IAAAA;AACAC,UAAAA,IAAAA,GAAOvG,CAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAeA,CAAAA,GAAfA,CAAAA,GAAPuG,IAAAA;AAEAC,UAAAA,IAAAA,GAAOvG,CAAAA,GAAAA,IAAAA,GAAAA,CAAAA,GAAPuG,IAAAA;AACAC,UAAAA,IAAAA,GAAOxG,CAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAeA,CAAAA,GAAfA,CAAAA,GAAPwG,IAAAA;AAXJ,SAAA,MAaK,IAAIG,IAAAA,KAAS,MAAA,CAAA,MAAA,CAAb,IAAA,EACL;AACI5G,UAAAA,CAAAA,GAAIa,KAAAA,CAAJb,CAAAA;AACAC,UAAAA,CAAAA,GAAIY,KAAAA,CAAJZ,CAAAA;AACAyG,UAAAA,CAAAA,GAAI7F,KAAAA,CAAAA,MAAAA,GAAJ6F,UAAAA;AACAC,UAAAA,CAAAA,GAAI9F,KAAAA,CAAAA,MAAAA,GAAJ8F,UAAAA;AAEAL,UAAAA,IAAAA,GAAOtG,CAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAeA,CAAAA,GAAfA,CAAAA,GAAPsG,IAAAA;AACAC,UAAAA,IAAAA,GAAOvG,CAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAeA,CAAAA,GAAfA,CAAAA,GAAPuG,IAAAA;AAEAC,UAAAA,IAAAA,GAAOvG,CAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAeA,CAAAA,GAAfA,CAAAA,GAAPuG,IAAAA;AACAC,UAAAA,IAAAA,GAAOxG,CAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAeA,CAAAA,GAAfA,CAAAA,GAAPwG,IAAAA;AAXC,SAAA,MAaA,IAAIG,IAAAA,KAAS,MAAA,CAAA,MAAA,CAAb,IAAA,EACL;AACI5G,UAAAA,CAAAA,GAAIa,KAAAA,CAAJb,CAAAA;AACAC,UAAAA,CAAAA,GAAIY,KAAAA,CAAJZ,CAAAA;AACAyG,UAAAA,CAAAA,GAAI7F,KAAAA,CAAAA,KAAAA,GAAJ6F,UAAAA;AACAC,UAAAA,CAAAA,GAAI9F,KAAAA,CAAAA,MAAAA,GAAJ8F,UAAAA;AAEAL,UAAAA,IAAAA,GAAOtG,CAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAeA,CAAAA,GAAfA,CAAAA,GAAPsG,IAAAA;AACAC,UAAAA,IAAAA,GAAOvG,CAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAeA,CAAAA,GAAfA,CAAAA,GAAPuG,IAAAA;AAEAC,UAAAA,IAAAA,GAAOvG,CAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAeA,CAAAA,GAAfA,CAAAA,GAAPuG,IAAAA;AACAC,UAAAA,IAAAA,GAAOxG,CAAAA,GAAAA,CAAAA,GAAAA,IAAAA,GAAeA,CAAAA,GAAfA,CAAAA,GAAPwG,IAAAA;AAXC,SAAA,MAcL;AACI;AACA,cAAMzF,MAAAA,GAASH,KAAAA,CAAf,MAAA;AACA,cAAIY,EAAAA,GAAJ,CAAA;AACA,cAAIC,EAAAA,GAAJ,CAAA;AACA,cAAIxB,EAAAA,GAAJ,CAAA;AACA,cAAIC,EAAAA,GAAJ,CAAA;AACA,cAAI4G,EAAAA,GAAJ,CAAA;AACA,cAAIC,EAAAA,GAAJ,CAAA;AACA,cAAIzE,EAAAA,GAAJ,CAAA;AACA,cAAIC,EAAAA,GAAJ,CAAA;;AAEA,eAAK,IAAIpB,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAAA,CAAAA,GAAQJ,MAAAA,CAAxB,MAAA,EAAuCI,CAAAA,IAAvC,CAAA,EACA;AACIpB,YAAAA,CAAAA,GAAIgB,MAAAA,CAAJhB,CAAIgB,CAAJhB;AACAC,YAAAA,CAAAA,GAAIe,MAAAA,CAAOI,CAAAA,GAAXnB,CAAIe,CAAJf;AACAwB,YAAAA,EAAAA,GAAKT,MAAAA,CAAOI,CAAAA,GAAZK,CAAKT,CAALS;AACAC,YAAAA,EAAAA,GAAKV,MAAAA,CAAOI,CAAAA,GAAZM,CAAKV,CAALU;AACAxB,YAAAA,EAAAA,GAAKlB,IAAAA,CAAAA,GAAAA,CAASyC,EAAAA,GAAdvB,CAAKlB,CAALkB;AACAC,YAAAA,EAAAA,GAAKnB,IAAAA,CAAAA,GAAAA,CAAS0C,EAAAA,GAAdvB,CAAKnB,CAALmB;AACAwG,YAAAA,CAAAA,GAAIG,UAAAA,GAAJH,CAAAA;AACAD,YAAAA,CAAAA,GAAI1H,IAAAA,CAAAA,IAAAA,CAAWkB,EAAAA,GAAD,EAACA,GAAYC,EAAAA,GAA3BuG,EAAI1H,CAAJ0H;;AAEA,gBAAIA,CAAAA,GAAJ,IAAA,EACA;AACI;AACH;;AAEDK,YAAAA,EAAAA,GAAK,CAAEJ,CAAAA,GAAAA,CAAAA,GAAD,EAACA,GAAF,EAAA,IAALI,CAAAA;AACAC,YAAAA,EAAAA,GAAK,CAAEL,CAAAA,GAAAA,CAAAA,GAAD,EAACA,GAAF,EAAA,IAALK,CAAAA;AACAzE,YAAAA,EAAAA,GAAK,CAACd,EAAAA,GAAD,CAAA,IAALc,CAAAA;AACAC,YAAAA,EAAAA,GAAK,CAACd,EAAAA,GAAD,CAAA,IAALc,CAAAA;AAEA8D,YAAAA,IAAAA,GAAO/D,EAAAA,GAAAA,EAAAA,GAAAA,IAAAA,GAAiBA,EAAAA,GAAjBA,EAAAA,GAAP+D,IAAAA;AACAC,YAAAA,IAAAA,GAAOhE,EAAAA,GAAAA,EAAAA,GAAAA,IAAAA,GAAiBA,EAAAA,GAAjBA,EAAAA,GAAPgE,IAAAA;AAEAC,YAAAA,IAAAA,GAAOhE,EAAAA,GAAAA,EAAAA,GAAAA,IAAAA,GAAiBA,EAAAA,GAAjBA,EAAAA,GAAPgE,IAAAA;AACAC,YAAAA,IAAAA,GAAOjE,EAAAA,GAAAA,EAAAA,GAAAA,IAAAA,GAAiBA,EAAAA,GAAjBA,EAAAA,GAAPiE,IAAAA;AACH;AACJ;AACJ;AAnGL,KAAA,MAsGA;AACIH,MAAAA,IAAAA,GAAAA,CAAAA;AACAC,MAAAA,IAAAA,GAAAA,CAAAA;AACAC,MAAAA,IAAAA,GAAAA,CAAAA;AACAC,MAAAA,IAAAA,GAAAA,CAAAA;AACH;;AAED,QAAMQ,OAAAA,GAAU,KAAhB,aAAA;AAEA,SAAA,YAAA,CAAA,IAAA,GAAyBX,IAAAA,GAAzB,OAAA;AACA,SAAA,YAAA,CAAA,IAAA,GAAyBC,IAAAA,GAAzB,OAAA;AAEA,SAAA,YAAA,CAAA,IAAA,GAAyBC,IAAAA,GAAzB,OAAA;AACA,SAAA,YAAA,CAAA,IAAA,GAAyBC,IAAAA,GAAzB,OAAA;;AAGJ;;;;;;;;qBAMAS,S,sBAAUrG,K,EACV;AACI,QAAI,KAAJ,WAAA,EACA;AACI;AACA,UAAI,KAAA,WAAA,CAAA,KAAA,CAAA,MAAA,CAAA,MAAA,IAAJ,CAAA,EACA;AACI,aAAA,YAAA,CAAA,GAAA;AACH;AACJ;;AAED,SAAA,WAAA,GAAA,IAAA;AAEA,QAAMqF,IAAAA,GAAO,IAAA,cAAA,CAAA,OAAA,CACT,KADS,SAAA,EAET,KAFS,SAAA,EAGT,KAHS,SAAA,EAIT,KAJS,SAAA,EAKT,KALS,SAAA,EAMT,KANS,OAAA,EAOT,KAPS,WAAA,EAAA,KAAA,EAST,KATJ,aAAa,CAAb;AAYA,SAAA,YAAA,CAAA,IAAA,CAAA,IAAA;;AAEA,QAAIA,IAAAA,CAAAA,IAAAA,KAAc,MAAA,CAAA,MAAA,CAAlB,IAAA,EACA;AACIA,MAAAA,IAAAA,CAAAA,KAAAA,CAAAA,MAAAA,GAAoBA,IAAAA,CAAAA,KAAAA,CAApBA,MAAAA;AACA,WAAA,WAAA,GAAA,IAAA;AACH;;AAED,SAAA,KAAA;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;;qBAOAiB,qB,kCAAsBC,S,EACtB;AAAA,QADiCC,UACjC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAD8C,CAC9C;AACI,QAAMC,MAAAA,GAAS,KAAf,cAAe,EAAf;;AAEA,QAAMC,YAAAA,GAAe,eAAA,CAAA,OAAA,CAAA,MAAA,CAAqBD,MAAAA,CAArB,KAAA,EAAmCA,MAAAA,CAAnC,MAAA,EAAA,SAAA,EAArB,UAAqB,CAArB;;AAEA,QAAI,CAAJ,cAAA,EACA;AACI9J,MAAAA,cAAAA,GAAiB,IAAA,gBAAA,CAAjBA,OAAiB,EAAjBA;AACH;;AAED,SAAA,SAAA,CAAA,oBAAA;AACA,SAAA,SAAA,CAAA,cAAA,CAAA,IAAA,CAAA,UAAA;AAEAC,IAAAA,UAAAA,CAAAA,MAAAA;AAEAA,IAAAA,UAAAA,CAAAA,EAAAA,IAAiB6J,MAAAA,CAAjB7J,CAAAA;AACAA,IAAAA,UAAAA,CAAAA,EAAAA,IAAiB6J,MAAAA,CAAjB7J,CAAAA;AAEAD,IAAAA,cAAAA,CAAAA,MAAAA,CAAAA,IAAAA,EAAAA,YAAAA,EAAAA,IAAAA,EAAAA,UAAAA;;AAEA,QAAMgK,OAAAA,GAAU,SAAA,CAAA,OAAA,CAAA,UAAA,CAAmBD,YAAAA,CAAAA,WAAAA,CAAAA,mBAAAA,CAAnB,MAAA,EAAA,SAAA,EAAhB,UAAgB,CAAhB;;AAEAC,IAAAA,OAAAA,CAAAA,WAAAA,CAAAA,UAAAA,GAAAA,UAAAA;AACAA,IAAAA,OAAAA,CAAAA,WAAAA,CAAAA,MAAAA;AAEA,WAAA,OAAA;;AAGJ;;;;;;;qBAKAC,S,wBACA;AACI;AACA,QAAMC,WAAAA,GAAc,KAApB,WAAA;;AAEA,QAAIA,WAAAA,IAAeA,WAAAA,CAAnB,KAAA,EACA;AACIA,MAAAA,WAAAA,CAAAA,KAAAA,CAAAA,KAAAA;AACH;;AAED,WAAA,IAAA;;AAGJ;;;;;;;qBAKAC,O,sBACA;AACI;AACA,QAAMvB,IAAAA,GAAO,KAAA,YAAA,CAAb,GAAa,EAAb;AAEA,SAAA,WAAA,GAAmB,KAAA,YAAA,CAAkB,KAAA,YAAA,CAAA,MAAA,GAArC,CAAmB,CAAnB;AAEA,SAAA,WAAA,CAAA,OAAA,CAAyBA,IAAAA,CAAzB,KAAA;AACA,SAAA,WAAA,GAAA,IAAA;AAEA,WAAA,IAAA;;AAGJ;;;;;;;;;;;;;;qBAYAwB,O,oBAAQC,O,EACR;AACI,IAAA,UAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA,EAAA,OAAA,EADJ,CAGI;;;AACA,SAAK,IAAI7J,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAI,KAAA,YAAA,CAApB,MAAA,EAA8C,EAA9C,CAAA,EACA;AACI,WAAA,YAAA,CAAA,CAAA,EAAA,OAAA;AACH,KAPL,CASI;;;AACA,SAAK,IAAL,EAAA,IAAiB,KAAjB,MAAA,EACA;AACI,WAAK,IAAIoD,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAI,KAAA,MAAA,CAAA,EAAA,EAAA,IAAA,CAApB,MAAA,EAAiD,EAAjD,CAAA,EACA;AACI,aAAA,MAAA,CAAA,EAAA,EAAA,IAAA,CAAA,CAAA,EAAA,OAAA;AACH;AACJ;;AAED,QAAI,KAAJ,WAAA,EACA;AACI,WAAA,WAAA,CAAA,OAAA;AACH;;AAED,SAAA,YAAA,GAAA,IAAA;AAEA,SAAA,WAAA,GAAA,IAAA;AACA,SAAA,MAAA,GAAA,IAAA;AACA,SAAA,YAAA,GAAA,IAAA;;;;;;kBA30CavD,Q;AAg1CrBA,QAAAA,CAAAA,eAAAA,GAAAA,IAAAA;AAEA;;;;;;;;;;;;;;;;AAeAA,QAAAA,CAAAA,MAAAA,GAAkB;AACdiK,EAAAA,QAAAA,EADc,KAAA;AAEdC,EAAAA,SAAAA,EAFc,EAAA;AAGdC,EAAAA,WAAAA,EAHc,CAAA;AAIdC,EAAAA,WAAAA,EAAa;AAJC,CAAlBpK","sourcesContent":["import Container from '../display/Container';\nimport RenderTexture from '../textures/RenderTexture';\nimport Texture from '../textures/Texture';\nimport GraphicsData from './GraphicsData';\nimport Sprite from '../sprites/Sprite';\nimport { Matrix, Point, Rectangle, RoundedRectangle, Ellipse, Polygon, Circle } from '../math';\nimport { hex2rgb, rgb2hex } from '../utils';\nimport { SHAPES, BLEND_MODES, PI_2 } from '../const';\nimport Bounds from '../display/Bounds';\nimport bezierCurveTo from './utils/bezierCurveTo';\nimport CanvasRenderer from '../renderers/canvas/CanvasRenderer';\n\nlet canvasRenderer;\nconst tempMatrix = new Matrix();\nconst tempPoint = new Point();\nconst tempColor1 = new Float32Array(4);\nconst tempColor2 = new Float32Array(4);\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nexport default class Graphics extends Container\n{\n    /**\n     *\n     * @param {boolean} [nativeLines=false] - If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n     */\n    constructor(nativeLines = false)\n    {\n        super();\n\n        /**\n         * The alpha value used when filling the Graphics object.\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.fillAlpha = 1;\n\n        /**\n         * The width (thickness) of any lines drawn.\n         *\n         * @member {number}\n         * @default 0\n         */\n        this.lineWidth = 0;\n\n        /**\n         * If true the lines will be draw using LINES instead of TRIANGLE_STRIP\n         *\n         * @member {boolean}\n         */\n        this.nativeLines = nativeLines;\n\n        /**\n         * The color of any lines drawn.\n         *\n         * @member {string}\n         * @default 0\n         */\n        this.lineColor = 0;\n\n        /**\n         * The alignment of any lines drawn (0.5 = middle, 1 = outter, 0 = inner).\n         *\n         * @member {number}\n         * @default 0.5\n         */\n        this.lineAlignment = 0.5;\n\n        /**\n         * Graphics data\n         *\n         * @member {PIXI.GraphicsData[]}\n         * @private\n         */\n        this.graphicsData = [];\n\n        /**\n         * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to\n         * reset the tint.\n         *\n         * @member {number}\n         * @default 0xFFFFFF\n         */\n        this.tint = 0xFFFFFF;\n\n        /**\n         * The previous tint applied to the graphic shape. Used to compare to the current tint and\n         * check if theres change.\n         *\n         * @member {number}\n         * @private\n         * @default 0xFFFFFF\n         */\n        this._prevTint = 0xFFFFFF;\n\n        /**\n         * The blend mode to be applied to the graphic shape. Apply a value of\n         * `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL;\n         * @see PIXI.BLEND_MODES\n         */\n        this.blendMode = BLEND_MODES.NORMAL;\n\n        /**\n         * Current path\n         *\n         * @member {PIXI.GraphicsData}\n         * @private\n         */\n        this.currentPath = null;\n\n        /**\n         * Array containing some WebGL-related properties used by the WebGL renderer.\n         *\n         * @member {object<number, object>}\n         * @private\n         */\n        // TODO - _webgl should use a prototype object, not a random undocumented object...\n        this._webGL = {};\n\n        /**\n         * Whether this shape is being used as a mask.\n         *\n         * @member {boolean}\n         */\n        this.isMask = false;\n\n        /**\n         * The bounds' padding used for bounds calculation.\n         *\n         * @member {number}\n         */\n        this.boundsPadding = 0;\n\n        /**\n         * A cache of the local bounds to prevent recalculation.\n         *\n         * @member {PIXI.Rectangle}\n         * @private\n         */\n        this._localBounds = new Bounds();\n\n        /**\n         * Used to detect if the graphics object has changed. If this is set to true then the graphics\n         * object will be recalculated.\n         *\n         * @member {boolean}\n         * @private\n         */\n        this.dirty = 0;\n\n        /**\n         * Used to detect if we need to do a fast rect check using the id compare method\n         * @type {Number}\n         */\n        this.fastRectDirty = -1;\n\n        /**\n         * Used to detect if we clear the graphics webGL data\n         * @type {Number}\n         */\n        this.clearDirty = 0;\n\n        /**\n         * Used to detect if we we need to recalculate local bounds\n         * @type {Number}\n         */\n        this.boundsDirty = -1;\n\n        /**\n         * Used to detect if the cached sprite object needs to be updated.\n         *\n         * @member {boolean}\n         * @private\n         */\n        this.cachedSpriteDirty = false;\n\n        this._spriteRect = null;\n        this._fastRect = false;\n\n        this._prevRectTint = null;\n        this._prevRectFillColor = null;\n\n        /**\n         * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n         * This is useful if your graphics element does not change often, as it will speed up the rendering\n         * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n         * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n         * you are constantly redrawing the graphics element.\n         *\n         * @name cacheAsBitmap\n         * @member {boolean}\n         * @memberof PIXI.Graphics#\n         * @default false\n         */\n    }\n\n    /**\n     * Creates a new Graphics object with the same values as this one.\n     * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n     *\n     * @return {PIXI.Graphics} A clone of the graphics object\n     */\n    clone()\n    {\n        const clone = new Graphics();\n\n        clone.renderable = this.renderable;\n        clone.fillAlpha = this.fillAlpha;\n        clone.lineWidth = this.lineWidth;\n        clone.lineColor = this.lineColor;\n        clone.lineAlignment = this.lineAlignment;\n        clone.tint = this.tint;\n        clone.blendMode = this.blendMode;\n        clone.isMask = this.isMask;\n        clone.boundsPadding = this.boundsPadding;\n        clone.dirty = 0;\n        clone.cachedSpriteDirty = this.cachedSpriteDirty;\n\n        // copy graphics data\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            clone.graphicsData.push(this.graphicsData[i].clone());\n        }\n\n        clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];\n\n        clone.updateLocalBounds();\n\n        return clone;\n    }\n\n    /**\n     * Calculate length of quadratic curve\n     * @see {@link http://www.malczak.linuxpl.com/blog/quadratic-bezier-curve-length/}\n     * for the detailed explanation of math behind this.\n     *\n     * @private\n     * @param {number} fromX - x-coordinate of curve start point\n     * @param {number} fromY - y-coordinate of curve start point\n     * @param {number} cpX - x-coordinate of curve control point\n     * @param {number} cpY - y-coordinate of curve control point\n     * @param {number} toX - x-coordinate of curve end point\n     * @param {number} toY - y-coordinate of curve end point\n     * @return {number} Length of quadratic curve\n     */\n    _quadraticCurveLength(fromX, fromY, cpX, cpY, toX, toY)\n    {\n        const ax = fromX - (2.0 * cpX) + toX;\n        const ay = fromY - (2.0 * cpY) + toY;\n        const bx = (2.0 * cpX) - (2.0 * fromX);\n        const by = (2.0 * cpY) - (2.0 * fromY);\n        const a = 4.0 * ((ax * ax) + (ay * ay));\n        const b = 4.0 * ((ax * bx) + (ay * by));\n        const c = (bx * bx) + (by * by);\n\n        const s = 2.0 * Math.sqrt(a + b + c);\n        const a2 = Math.sqrt(a);\n        const a32 = 2.0 * a * a2;\n        const c2 = 2.0 * Math.sqrt(c);\n        const ba = b / a2;\n\n        return (\n                (a32 * s)\n                + (a2 * b * (s - c2))\n                + (\n                   ((4.0 * c * a) - (b * b))\n                   * Math.log(((2.0 * a2) + ba + s) / (ba + c2))\n                  )\n               )\n               / (4.0 * a32);\n    }\n\n    /**\n     * Calculate length of bezier curve.\n     * Analytical solution is impossible, since it involves an integral that does not integrate in general.\n     * Therefore numerical solution is used.\n     *\n     * @private\n     * @param {number} fromX - Starting point x\n     * @param {number} fromY - Starting point y\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {number} Length of bezier curve\n     */\n    _bezierCurveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY)\n    {\n        const n = 10;\n        let result = 0.0;\n        let t = 0.0;\n        let t2 = 0.0;\n        let t3 = 0.0;\n        let nt = 0.0;\n        let nt2 = 0.0;\n        let nt3 = 0.0;\n        let x = 0.0;\n        let y = 0.0;\n        let dx = 0.0;\n        let dy = 0.0;\n        let prevX = fromX;\n        let prevY = fromY;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            t = i / n;\n            t2 = t * t;\n            t3 = t2 * t;\n            nt = (1.0 - t);\n            nt2 = nt * nt;\n            nt3 = nt2 * nt;\n\n            x = (nt3 * fromX) + (3.0 * nt2 * t * cpX) + (3.0 * nt * t2 * cpX2) + (t3 * toX);\n            y = (nt3 * fromY) + (3.0 * nt2 * t * cpY) + (3 * nt * t2 * cpY2) + (t3 * toY);\n            dx = prevX - x;\n            dy = prevY - y;\n            prevX = x;\n            prevY = y;\n\n            result += Math.sqrt((dx * dx) + (dy * dy));\n        }\n\n        return result;\n    }\n\n    /**\n     * Calculate number of segments for the curve based on its length to ensure its smoothness.\n     *\n     * @private\n     * @param {number} length - length of curve\n     * @return {number} Number of segments\n     */\n    _segmentsCount(length)\n    {\n        let result = Math.ceil(length / Graphics.CURVES.maxLength);\n\n        if (result < Graphics.CURVES.minSegments)\n        {\n            result = Graphics.CURVES.minSegments;\n        }\n        else if (result > Graphics.CURVES.maxSegments)\n        {\n            result = Graphics.CURVES.maxSegments;\n        }\n\n        return result;\n    }\n\n    /**\n     * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo()\n     * method or the drawCircle() method.\n     *\n     * @param {number} [lineWidth=0] - width of the line to draw, will update the objects stored style\n     * @param {number} [color=0] - color of the line to draw, will update the objects stored style\n     * @param {number} [alpha=1] - alpha of the line to draw, will update the objects stored style\n     * @param {number} [alignment=0.5] - alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outter)\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineStyle(lineWidth = 0, color = 0, alpha = 1, alignment = 0.5)\n    {\n        this.lineWidth = lineWidth;\n        this.lineColor = color;\n        this.lineAlpha = alpha;\n        this.lineAlignment = alignment;\n\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length)\n            {\n                // halfway through a line? start a new one!\n                const shape = new Polygon(this.currentPath.shape.points.slice(-2));\n\n                shape.closed = false;\n\n                this.drawShape(shape);\n            }\n            else\n            {\n                // otherwise its empty so lets just set the line properties\n                this.currentPath.lineWidth = this.lineWidth;\n                this.currentPath.lineColor = this.lineColor;\n                this.currentPath.lineAlpha = this.lineAlpha;\n                this.currentPath.lineAlignment = this.lineAlignment;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Moves the current drawing position to x, y.\n     *\n     * @param {number} x - the X coordinate to move to\n     * @param {number} y - the Y coordinate to move to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    moveTo(x, y)\n    {\n        const shape = new Polygon([x, y]);\n\n        shape.closed = false;\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draws a line using the current line style from the current drawing position to (x, y);\n     * The current drawing position is then set to (x, y).\n     *\n     * @param {number} x - the X coordinate to draw to\n     * @param {number} y - the Y coordinate to draw to\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    lineTo(x, y)\n    {\n        const points = this.currentPath.shape.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n            this.dirty++;\n        }\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a quadratic bezier curve and then draws it.\n     * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    quadraticCurveTo(cpX, cpY, toX, toY)\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length === 0)\n            {\n                this.currentPath.shape.points = [0, 0];\n            }\n        }\n        else\n        {\n            this.moveTo(0, 0);\n        }\n\n        const points = this.currentPath.shape.points;\n        let xa = 0;\n        let ya = 0;\n\n        if (points.length === 0)\n        {\n            this.moveTo(0, 0);\n        }\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n        const n = Graphics.CURVES.adaptive\n                  ? this._segmentsCount(this._quadraticCurveLength(fromX, fromY, cpX, cpY, toX, toY))\n                  : 20;\n\n        for (let i = 1; i <= n; ++i)\n        {\n            const j = i / n;\n\n            xa = fromX + ((cpX - fromX) * j);\n            ya = fromY + ((cpY - fromY) * j);\n\n            points.push(xa + (((cpX + ((toX - cpX) * j)) - xa) * j),\n                ya + (((cpY + ((toY - cpY) * j)) - ya) * j));\n        }\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Calculate the points for a bezier curve and then draws it.\n     *\n     * @param {number} cpX - Control point x\n     * @param {number} cpY - Control point y\n     * @param {number} cpX2 - Second Control point x\n     * @param {number} cpY2 - Second Control point y\n     * @param {number} toX - Destination point x\n     * @param {number} toY - Destination point y\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    bezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY)\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length === 0)\n            {\n                this.currentPath.shape.points = [0, 0];\n            }\n        }\n        else\n        {\n            this.moveTo(0, 0);\n        }\n\n        const points = this.currentPath.shape.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        points.length -= 2;\n\n        const n = Graphics.CURVES.adaptive\n                  ? this._segmentsCount(this._bezierCurveLength(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY))\n                  : 20;\n\n        bezierCurveTo(fromX, fromY, cpX, cpY, cpX2, cpY2, toX, toY, n, points);\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * The arcTo() method creates an arc/curve between two tangents on the canvas.\n     *\n     * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n     *\n     * @param {number} x1 - The x-coordinate of the beginning of the arc\n     * @param {number} y1 - The y-coordinate of the beginning of the arc\n     * @param {number} x2 - The x-coordinate of the end of the arc\n     * @param {number} y2 - The y-coordinate of the end of the arc\n     * @param {number} radius - The radius of the arc\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    arcTo(x1, y1, x2, y2, radius)\n    {\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length === 0)\n            {\n                this.currentPath.shape.points.push(x1, y1);\n            }\n        }\n        else\n        {\n            this.moveTo(x1, y1);\n        }\n\n        const points = this.currentPath.shape.points;\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n        const a1 = fromY - y1;\n        const b1 = fromX - x1;\n        const a2 = y2 - y1;\n        const b2 = x2 - x1;\n        const mm = Math.abs((a1 * b2) - (b1 * a2));\n\n        if (mm < 1.0e-8 || radius === 0)\n        {\n            if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1)\n            {\n                points.push(x1, y1);\n            }\n        }\n        else\n        {\n            const dd = (a1 * a1) + (b1 * b1);\n            const cc = (a2 * a2) + (b2 * b2);\n            const tt = (a1 * a2) + (b1 * b2);\n            const k1 = radius * Math.sqrt(dd) / mm;\n            const k2 = radius * Math.sqrt(cc) / mm;\n            const j1 = k1 * tt / dd;\n            const j2 = k2 * tt / cc;\n            const cx = (k1 * b2) + (k2 * b1);\n            const cy = (k1 * a2) + (k2 * a1);\n            const px = b1 * (k2 + j1);\n            const py = a1 * (k2 + j1);\n            const qx = b2 * (k1 + j2);\n            const qy = a2 * (k1 + j2);\n            const startAngle = Math.atan2(py - cy, px - cx);\n            const endAngle = Math.atan2(qy - cy, qx - cx);\n\n            this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n        }\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * The arc method creates an arc/curve (used to create circles, or parts of circles).\n     *\n     * @param {number} cx - The x-coordinate of the center of the circle\n     * @param {number} cy - The y-coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @param {number} startAngle - The starting angle, in radians (0 is at the 3 o'clock position\n     *  of the arc's circle)\n     * @param {number} endAngle - The ending angle, in radians\n     * @param {boolean} [anticlockwise=false] - Specifies whether the drawing should be\n     *  counter-clockwise or clockwise. False is default, and indicates clockwise, while true\n     *  indicates counter-clockwise.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    arc(cx, cy, radius, startAngle, endAngle, anticlockwise = false)\n    {\n        if (startAngle === endAngle)\n        {\n            return this;\n        }\n\n        if (!anticlockwise && endAngle <= startAngle)\n        {\n            endAngle += PI_2;\n        }\n        else if (anticlockwise && startAngle <= endAngle)\n        {\n            startAngle += PI_2;\n        }\n\n        const sweep = endAngle - startAngle;\n        const segs = Graphics.CURVES.adaptive\n                     ? this._segmentsCount(Math.abs(sweep) * radius)\n                     : Math.ceil(Math.abs(sweep) / PI_2) * 40;\n\n        if (sweep === 0)\n        {\n            return this;\n        }\n\n        const startX = cx + (Math.cos(startAngle) * radius);\n        const startY = cy + (Math.sin(startAngle) * radius);\n\n        // If the currentPath exists, take its points. Otherwise call `moveTo` to start a path.\n        let points = this.currentPath ? this.currentPath.shape.points : null;\n\n        if (points)\n        {\n            // We check how far our start is from the last existing point\n            const xDiff = Math.abs(points[points.length - 2] - startX);\n            const yDiff = Math.abs(points[points.length - 1] - startY);\n\n            if (xDiff < 0.001 && yDiff < 0.001)\n            {\n                // If the point is very close, we don't add it, since this would lead to artifacts\n                // during tesselation due to floating point imprecision.\n            }\n            else\n            {\n                points.push(startX, startY);\n            }\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n            points = this.currentPath.shape.points;\n        }\n\n        const theta = sweep / (segs * 2);\n        const theta2 = theta * 2;\n\n        const cTheta = Math.cos(theta);\n        const sTheta = Math.sin(theta);\n\n        const segMinus = segs - 1;\n\n        const remainder = (segMinus % 1) / segMinus;\n\n        for (let i = 0; i <= segMinus; ++i)\n        {\n            const real = i + (remainder * i);\n\n            const angle = ((theta) + startAngle + (theta2 * real));\n\n            const c = Math.cos(angle);\n            const s = -Math.sin(angle);\n\n            points.push(\n                (((cTheta * c) + (sTheta * s)) * radius) + cx,\n                (((cTheta * -s) + (sTheta * c)) * radius) + cy\n            );\n        }\n\n        this.dirty++;\n\n        return this;\n    }\n\n    /**\n     * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n     * (such as lineTo() or drawCircle()) use when drawing.\n     *\n     * @param {number} [color=0] - the color of the fill\n     * @param {number} [alpha=1] - the alpha of the fill\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    beginFill(color = 0, alpha = 1)\n    {\n        this.filling = true;\n        this.fillColor = color;\n        this.fillAlpha = alpha;\n\n        if (this.currentPath)\n        {\n            if (this.currentPath.shape.points.length <= 2)\n            {\n                this.currentPath.fill = this.filling;\n                this.currentPath.fillColor = this.fillColor;\n                this.currentPath.fillAlpha = this.fillAlpha;\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    endFill()\n    {\n        this.filling = false;\n        this.fillColor = null;\n        this.fillAlpha = 1;\n\n        return this;\n    }\n\n    /**\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawRect(x, y, width, height)\n    {\n        this.drawShape(new Rectangle(x, y, width, height));\n\n        return this;\n    }\n\n    /**\n     *\n     * @param {number} x - The X coord of the top-left of the rectangle\n     * @param {number} y - The Y coord of the top-left of the rectangle\n     * @param {number} width - The width of the rectangle\n     * @param {number} height - The height of the rectangle\n     * @param {number} radius - Radius of the rectangle corners\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawRoundedRect(x, y, width, height, radius)\n    {\n        this.drawShape(new RoundedRectangle(x, y, width, height, radius));\n\n        return this;\n    }\n\n    /**\n     * Draws a circle.\n     *\n     * @param {number} x - The X coordinate of the center of the circle\n     * @param {number} y - The Y coordinate of the center of the circle\n     * @param {number} radius - The radius of the circle\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawCircle(x, y, radius)\n    {\n        this.drawShape(new Circle(x, y, radius));\n\n        return this;\n    }\n\n    /**\n     * Draws an ellipse.\n     *\n     * @param {number} x - The X coordinate of the center of the ellipse\n     * @param {number} y - The Y coordinate of the center of the ellipse\n     * @param {number} width - The half width of the ellipse\n     * @param {number} height - The half height of the ellipse\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawEllipse(x, y, width, height)\n    {\n        this.drawShape(new Ellipse(x, y, width, height));\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon using the given path.\n     *\n     * @param {number[]|PIXI.Point[]|PIXI.Polygon} path - The path data used to construct the polygon.\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawPolygon(path)\n    {\n        // prevents an argument assignment deopt\n        // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        let points = path;\n\n        let closed = true;\n\n        if (points instanceof Polygon)\n        {\n            closed = points.closed;\n            points = points.points;\n        }\n\n        if (!Array.isArray(points))\n        {\n            // prevents an argument leak deopt\n            // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n            points = new Array(arguments.length);\n\n            for (let i = 0; i < points.length; ++i)\n            {\n                points[i] = arguments[i]; // eslint-disable-line prefer-rest-params\n            }\n        }\n\n        const shape = new Polygon(points);\n\n        shape.closed = closed;\n\n        this.drawShape(shape);\n\n        return this;\n    }\n\n    /**\n     * Draw a star shape with an abitrary number of points.\n     *\n     * @param {number} x - Center X position of the star\n     * @param {number} y - Center Y position of the star\n     * @param {number} points - The number of points of the star, must be > 1\n     * @param {number} radius - The outer radius of the star\n     * @param {number} [innerRadius] - The inner radius between points, default half `radius`\n     * @param {number} [rotation=0] - The rotation of the star in radians, where 0 is vertical\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    drawStar(x, y, points, radius, innerRadius, rotation = 0)\n    {\n        innerRadius = innerRadius || radius / 2;\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const len = points * 2;\n        const delta = PI_2 / len;\n        const polygon = [];\n\n        for (let i = 0; i < len; i++)\n        {\n            const r = i % 2 ? innerRadius : radius;\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (r * Math.cos(angle)),\n                y + (r * Math.sin(angle))\n            );\n        }\n\n        return this.drawPolygon(polygon);\n    }\n\n    /**\n     * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n     *\n     * @return {PIXI.Graphics} This Graphics object. Good for chaining method calls\n     */\n    clear()\n    {\n        if (this.lineWidth || this.filling || this.graphicsData.length > 0)\n        {\n            this.lineWidth = 0;\n            this.lineAlignment = 0.5;\n\n            this.filling = false;\n\n            this.boundsDirty = -1;\n            this.canvasTintDirty = -1;\n            this.dirty++;\n            this.clearDirty++;\n            this.graphicsData.length = 0;\n        }\n\n        this.currentPath = null;\n        this._spriteRect = null;\n\n        return this;\n    }\n\n    /**\n     * True if graphics consists of one rectangle, and thus, can be drawn like a Sprite and\n     * masked with gl.scissor.\n     *\n     * @returns {boolean} True if only 1 rect.\n     */\n    isFastRect()\n    {\n        return this.graphicsData.length === 1\n            && this.graphicsData[0].shape.type === SHAPES.RECT\n            && !this.graphicsData[0].lineWidth;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderWebGL(renderer)\n    {\n        // if the sprite is not visible or the alpha is 0 then no need to render this element\n        if (this.dirty !== this.fastRectDirty)\n        {\n            this.fastRectDirty = this.dirty;\n            this._fastRect = this.isFastRect();\n        }\n\n        // TODO this check can be moved to dirty?\n        if (this._fastRect)\n        {\n            this._renderSpriteRect(renderer);\n        }\n        else\n        {\n            renderer.setObjectRenderer(renderer.plugins.graphics);\n            renderer.plugins.graphics.render(this);\n        }\n    }\n\n    /**\n     * Renders a sprite rectangle.\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderSpriteRect(renderer)\n    {\n        const rect = this.graphicsData[0].shape;\n\n        if (!this._spriteRect)\n        {\n            this._spriteRect = new Sprite(new Texture(Texture.WHITE));\n        }\n\n        const sprite = this._spriteRect;\n        const fillColor = this.graphicsData[0].fillColor;\n\n        if (this.tint === 0xffffff)\n        {\n            sprite.tint = fillColor;\n        }\n        else if (this.tint !== this._prevRectTint || fillColor !== this._prevRectFillColor)\n        {\n            const t1 = tempColor1;\n            const t2 = tempColor2;\n\n            hex2rgb(fillColor, t1);\n            hex2rgb(this.tint, t2);\n\n            t1[0] *= t2[0];\n            t1[1] *= t2[1];\n            t1[2] *= t2[2];\n\n            sprite.tint = rgb2hex(t1);\n\n            this._prevRectTint = this.tint;\n            this._prevRectFillColor = fillColor;\n        }\n\n        sprite.alpha = this.graphicsData[0].fillAlpha;\n        sprite.worldAlpha = this.worldAlpha * sprite.alpha;\n        sprite.blendMode = this.blendMode;\n\n        sprite._texture._frame.width = rect.width;\n        sprite._texture._frame.height = rect.height;\n\n        sprite.transform.worldTransform = this.transform.worldTransform;\n\n        sprite.anchor.set(-rect.x / rect.width, -rect.y / rect.height);\n        sprite._onAnchorUpdate();\n\n        sprite._renderWebGL(renderer);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer)\n    {\n        if (this.isMask === true)\n        {\n            return;\n        }\n\n        renderer.plugins.graphics.render(this);\n    }\n\n    /**\n     * Retrieves the bounds of the graphic shape as a rectangle object\n     *\n     * @private\n     */\n    _calculateBounds()\n    {\n        if (this.boundsDirty !== this.dirty)\n        {\n            this.boundsDirty = this.dirty;\n            this.updateLocalBounds();\n\n            this.cachedSpriteDirty = true;\n        }\n\n        const lb = this._localBounds;\n\n        this._bounds.addFrame(this.transform, lb.minX, lb.minY, lb.maxX, lb.maxY);\n    }\n\n    /**\n     * Tests if a point is inside this graphics object\n     *\n     * @param {PIXI.Point} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const graphicsData = this.graphicsData;\n\n        for (let i = 0; i < graphicsData.length; ++i)\n        {\n            const data = graphicsData[i];\n\n            if (!data.fill)\n            {\n                continue;\n            }\n\n            // only deal with fills..\n            if (data.shape)\n            {\n                if (data.shape.contains(tempPoint.x, tempPoint.y))\n                {\n                    let hitHole = false;\n\n                    if (data.holes)\n                    {\n                        for (let i = 0; i < data.holes.length; i++)\n                        {\n                            const hole = data.holes[i];\n\n                            if (hole.contains(tempPoint.x, tempPoint.y))\n                            {\n                                hitHole = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (!hitHole)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Update the bounds of the object\n     *\n     */\n    updateLocalBounds()\n    {\n        let minX = Infinity;\n        let maxX = -Infinity;\n\n        let minY = Infinity;\n        let maxY = -Infinity;\n\n        if (this.graphicsData.length)\n        {\n            let shape = 0;\n            let x = 0;\n            let y = 0;\n            let w = 0;\n            let h = 0;\n\n            for (let i = 0; i < this.graphicsData.length; i++)\n            {\n                const data = this.graphicsData[i];\n                const type = data.type;\n                const lineWidth = data.lineWidth;\n                const lineAlignment = data.lineAlignment;\n\n                const lineOffset = lineWidth * lineAlignment;\n\n                shape = data.shape;\n\n                if (type === SHAPES.RECT || type === SHAPES.RREC)\n                {\n                    x = shape.x - lineOffset;\n                    y = shape.y - lineOffset;\n                    w = shape.width + (lineOffset * 2);\n                    h = shape.height + (lineOffset * 2);\n\n                    minX = x < minX ? x : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y < minY ? y : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                }\n                else if (type === SHAPES.CIRC)\n                {\n                    x = shape.x;\n                    y = shape.y;\n                    w = shape.radius + lineOffset;\n                    h = shape.radius + lineOffset;\n\n                    minX = x - w < minX ? x - w : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y - h < minY ? y - h : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                }\n                else if (type === SHAPES.ELIP)\n                {\n                    x = shape.x;\n                    y = shape.y;\n                    w = shape.width + lineOffset;\n                    h = shape.height + lineOffset;\n\n                    minX = x - w < minX ? x - w : minX;\n                    maxX = x + w > maxX ? x + w : maxX;\n\n                    minY = y - h < minY ? y - h : minY;\n                    maxY = y + h > maxY ? y + h : maxY;\n                }\n                else\n                {\n                    // POLY\n                    const points = shape.points;\n                    let x2 = 0;\n                    let y2 = 0;\n                    let dx = 0;\n                    let dy = 0;\n                    let rw = 0;\n                    let rh = 0;\n                    let cx = 0;\n                    let cy = 0;\n\n                    for (let j = 0; j + 2 < points.length; j += 2)\n                    {\n                        x = points[j];\n                        y = points[j + 1];\n                        x2 = points[j + 2];\n                        y2 = points[j + 3];\n                        dx = Math.abs(x2 - x);\n                        dy = Math.abs(y2 - y);\n                        h = lineOffset * 2;\n                        w = Math.sqrt((dx * dx) + (dy * dy));\n\n                        if (w < 1e-9)\n                        {\n                            continue;\n                        }\n\n                        rw = ((h / w * dy) + dx) / 2;\n                        rh = ((h / w * dx) + dy) / 2;\n                        cx = (x2 + x) / 2;\n                        cy = (y2 + y) / 2;\n\n                        minX = cx - rw < minX ? cx - rw : minX;\n                        maxX = cx + rw > maxX ? cx + rw : maxX;\n\n                        minY = cy - rh < minY ? cy - rh : minY;\n                        maxY = cy + rh > maxY ? cy + rh : maxY;\n                    }\n                }\n            }\n        }\n        else\n        {\n            minX = 0;\n            maxX = 0;\n            minY = 0;\n            maxY = 0;\n        }\n\n        const padding = this.boundsPadding;\n\n        this._localBounds.minX = minX - padding;\n        this._localBounds.maxX = maxX + padding;\n\n        this._localBounds.minY = minY - padding;\n        this._localBounds.maxY = maxY + padding;\n    }\n\n    /**\n     * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n     *\n     * @param {PIXI.Circle|PIXI.Ellipse|PIXI.Polygon|PIXI.Rectangle|PIXI.RoundedRectangle} shape - The shape object to draw.\n     * @return {PIXI.GraphicsData} The generated GraphicsData object.\n     */\n    drawShape(shape)\n    {\n        if (this.currentPath)\n        {\n            // check current path!\n            if (this.currentPath.shape.points.length <= 2)\n            {\n                this.graphicsData.pop();\n            }\n        }\n\n        this.currentPath = null;\n\n        const data = new GraphicsData(\n            this.lineWidth,\n            this.lineColor,\n            this.lineAlpha,\n            this.fillColor,\n            this.fillAlpha,\n            this.filling,\n            this.nativeLines,\n            shape,\n            this.lineAlignment\n        );\n\n        this.graphicsData.push(data);\n\n        if (data.type === SHAPES.POLY)\n        {\n            data.shape.closed = data.shape.closed;\n            this.currentPath = data;\n        }\n\n        this.dirty++;\n\n        return data;\n    }\n\n    /**\n     * Generates a canvas texture.\n     *\n     * @param {number} scaleMode - The scale mode of the texture.\n     * @param {number} resolution - The resolution of the texture.\n     * @return {PIXI.Texture} The new texture.\n     */\n    generateCanvasTexture(scaleMode, resolution = 1)\n    {\n        const bounds = this.getLocalBounds();\n\n        const canvasBuffer = RenderTexture.create(bounds.width, bounds.height, scaleMode, resolution);\n\n        if (!canvasRenderer)\n        {\n            canvasRenderer = new CanvasRenderer();\n        }\n\n        this.transform.updateLocalTransform();\n        this.transform.localTransform.copy(tempMatrix);\n\n        tempMatrix.invert();\n\n        tempMatrix.tx -= bounds.x;\n        tempMatrix.ty -= bounds.y;\n\n        canvasRenderer.render(this, canvasBuffer, true, tempMatrix);\n\n        const texture = Texture.fromCanvas(canvasBuffer.baseTexture._canvasRenderTarget.canvas, scaleMode, 'graphics');\n\n        texture.baseTexture.resolution = resolution;\n        texture.baseTexture.update();\n\n        return texture;\n    }\n\n    /**\n     * Closes the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    closePath()\n    {\n        // ok so close path assumes next one is a hole!\n        const currentPath = this.currentPath;\n\n        if (currentPath && currentPath.shape)\n        {\n            currentPath.shape.close();\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds a hole in the current path.\n     *\n     * @return {PIXI.Graphics} Returns itself.\n     */\n    addHole()\n    {\n        // this is a hole!\n        const hole = this.graphicsData.pop();\n\n        this.currentPath = this.graphicsData[this.graphicsData.length - 1];\n\n        this.currentPath.addHole(hole.shape);\n        this.currentPath = null;\n\n        return this;\n    }\n\n    /**\n     * Destroys the Graphics object.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all\n     *  options have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have\n     *  their destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        // destroy each of the GraphicsData objects\n        for (let i = 0; i < this.graphicsData.length; ++i)\n        {\n            this.graphicsData[i].destroy();\n        }\n\n        // for each webgl data entry, destroy the WebGLGraphicsData\n        for (const id in this._webGL)\n        {\n            for (let j = 0; j < this._webGL[id].data.length; ++j)\n            {\n                this._webGL[id].data[j].destroy();\n            }\n        }\n\n        if (this._spriteRect)\n        {\n            this._spriteRect.destroy();\n        }\n\n        this.graphicsData = null;\n\n        this.currentPath = null;\n        this._webGL = null;\n        this._localBounds = null;\n    }\n\n}\n\nGraphics._SPRITE_TEXTURE = null;\n\n/**\n * Graphics curves resolution settings. If `adaptive` flag is set to `true`,\n * the resolution is calculated based on the curve's length to ensure better visual quality.\n * Adaptive draw works with `bezierCurveTo` and `quadraticCurveTo`.\n *\n * @static\n * @constant\n * @memberof PIXI.Graphics\n * @name CURVES\n * @type {object}\n * @property {boolean} adaptive=false - flag indicating if the resolution should be adaptive\n * @property {number} maxLength=10 - maximal length of a single segment of the curve (if adaptive = false, ignored)\n * @property {number} minSegments=8 - minimal number of segments in the curve (if adaptive = false, ignored)\n * @property {number} maxSegments=2048 - maximal number of segments in the curve (if adaptive = false, ignored)\n */\nGraphics.CURVES = {\n    adaptive: false,\n    maxLength: 10,\n    minSegments: 8,\n    maxSegments: 2048,\n};\n"]},"metadata":{},"sourceType":"script"}