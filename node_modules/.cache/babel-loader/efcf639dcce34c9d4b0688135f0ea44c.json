{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _utils = require('../../utils');\n\nvar _canUseNewCanvasBlendModes = require('../../renderers/canvas/utils/canUseNewCanvasBlendModes');\n\nvar _canUseNewCanvasBlendModes2 = _interopRequireDefault(_canUseNewCanvasBlendModes);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Utility methods for Sprite/Texture tinting.\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar CanvasTinter = {\n  /**\n   * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {PIXI.Sprite} sprite - the sprite to tint\n   * @param {number} color - the color to use to tint the sprite with\n   * @return {HTMLCanvasElement} The tinted canvas\n   */\n  getTintedTexture: function getTintedTexture(sprite, color) {\n    var texture = sprite._texture;\n    color = CanvasTinter.roundColor(color);\n    var stringColor = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n    texture.tintCache = texture.tintCache || {};\n    var cachedTexture = texture.tintCache[stringColor];\n    var canvas = void 0;\n\n    if (cachedTexture) {\n      if (cachedTexture.tintId === texture._updateID) {\n        return texture.tintCache[stringColor];\n      }\n\n      canvas = texture.tintCache[stringColor];\n    } else {\n      canvas = CanvasTinter.canvas || document.createElement('canvas');\n    }\n\n    CanvasTinter.tintMethod(texture, color, canvas);\n    canvas.tintId = texture._updateID;\n\n    if (CanvasTinter.convertTintToImage) {\n      // is this better?\n      var tintImage = new Image();\n      tintImage.src = canvas.toDataURL();\n      texture.tintCache[stringColor] = tintImage;\n    } else {\n      texture.tintCache[stringColor] = canvas; // if we are not converting the texture to an image then we need to lose the reference to the canvas\n\n      CanvasTinter.canvas = null;\n    }\n\n    return canvas;\n  },\n\n  /**\n   * Tint a texture using the 'multiply' operation.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {PIXI.Texture} texture - the texture to tint\n   * @param {number} color - the color to use to tint the sprite with\n   * @param {HTMLCanvasElement} canvas - the current canvas\n   */\n  tintWithMultiply: function tintWithMultiply(texture, color, canvas) {\n    var context = canvas.getContext('2d');\n\n    var crop = texture._frame.clone();\n\n    var resolution = texture.baseTexture.resolution;\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n    canvas.width = Math.ceil(crop.width);\n    canvas.height = Math.ceil(crop.height);\n    context.save();\n    context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, crop.width, crop.height);\n    context.globalCompositeOperation = 'multiply';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n    context.globalCompositeOperation = 'destination-atop';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n    context.restore();\n  },\n\n  /**\n   * Tint a texture using the 'overlay' operation.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {PIXI.Texture} texture - the texture to tint\n   * @param {number} color - the color to use to tint the sprite with\n   * @param {HTMLCanvasElement} canvas - the current canvas\n   */\n  tintWithOverlay: function tintWithOverlay(texture, color, canvas) {\n    var context = canvas.getContext('2d');\n\n    var crop = texture._frame.clone();\n\n    var resolution = texture.baseTexture.resolution;\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n    canvas.width = Math.ceil(crop.width);\n    canvas.height = Math.ceil(crop.height);\n    context.save();\n    context.globalCompositeOperation = 'copy';\n    context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, crop.width, crop.height);\n    context.globalCompositeOperation = 'destination-atop';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height); // context.globalCompositeOperation = 'copy';\n\n    context.restore();\n  },\n\n  /**\n   * Tint a texture pixel per pixel.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {PIXI.Texture} texture - the texture to tint\n   * @param {number} color - the color to use to tint the sprite with\n   * @param {HTMLCanvasElement} canvas - the current canvas\n   */\n  tintWithPerPixel: function tintWithPerPixel(texture, color, canvas) {\n    var context = canvas.getContext('2d');\n\n    var crop = texture._frame.clone();\n\n    var resolution = texture.baseTexture.resolution;\n    crop.x *= resolution;\n    crop.y *= resolution;\n    crop.width *= resolution;\n    crop.height *= resolution;\n    canvas.width = Math.ceil(crop.width);\n    canvas.height = Math.ceil(crop.height);\n    context.save();\n    context.globalCompositeOperation = 'copy';\n    context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n    context.restore();\n    var rgbValues = (0, _utils.hex2rgb)(color);\n    var r = rgbValues[0];\n    var g = rgbValues[1];\n    var b = rgbValues[2];\n    var pixelData = context.getImageData(0, 0, crop.width, crop.height);\n    var pixels = pixelData.data;\n\n    for (var i = 0; i < pixels.length; i += 4) {\n      pixels[i + 0] *= r;\n      pixels[i + 1] *= g;\n      pixels[i + 2] *= b;\n    }\n\n    context.putImageData(pixelData, 0, 0);\n  },\n\n  /**\n   * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @param {number} color - the color to round, should be a hex color\n   * @return {number} The rounded color.\n   */\n  roundColor: function roundColor(color) {\n    var step = CanvasTinter.cacheStepsPerColorChannel;\n    var rgbValues = (0, _utils.hex2rgb)(color);\n    rgbValues[0] = Math.min(255, rgbValues[0] / step * step);\n    rgbValues[1] = Math.min(255, rgbValues[1] / step * step);\n    rgbValues[2] = Math.min(255, rgbValues[2] / step * step);\n    return (0, _utils.rgb2hex)(rgbValues);\n  },\n\n  /**\n   * Number of steps which will be used as a cap when rounding colors.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @type {number}\n   */\n  cacheStepsPerColorChannel: 8,\n\n  /**\n   * Tint cache boolean flag.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @type {boolean}\n   */\n  convertTintToImage: false,\n\n  /**\n   * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @type {boolean}\n   */\n  canUseMultiply: (0, _canUseNewCanvasBlendModes2.default)(),\n\n  /**\n   * The tinting method that will be used.\n   *\n   * @memberof PIXI.CanvasTinter\n   * @type {tintMethodFunctionType}\n   */\n  tintMethod: 0\n};\nCanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;\n/**\n * The tintMethod type.\n *\n * @memberof PIXI.CanvasTinter\n * @callback tintMethodFunctionType\n * @param texture {PIXI.Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\n\nexports.default = CanvasTinter;","map":{"version":3,"sources":["../../../../src/core/sprites/canvas/CanvasTinter.js"],"names":["CanvasTinter","getTintedTexture","texture","sprite","color","stringColor","cachedTexture","canvas","document","tintImage","tintWithMultiply","context","crop","resolution","Math","tintWithOverlay","tintWithPerPixel","rgbValues","r","g","b","pixelData","pixels","i","roundColor","step","cacheStepsPerColorChannel","convertTintToImage","canUseMultiply","tintMethod"],"mappings":"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","sourcesContent":["import { hex2rgb, rgb2hex } from '../../utils';\nimport canUseNewCanvasBlendModes from '../../renderers/canvas/utils/canUseNewCanvasBlendModes';\n\n/**\n * Utility methods for Sprite/Texture tinting.\n *\n * @class\n * @memberof PIXI\n */\nconst CanvasTinter = {\n    /**\n     * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Sprite} sprite - the sprite to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @return {HTMLCanvasElement} The tinted canvas\n     */\n    getTintedTexture: (sprite, color) =>\n    {\n        const texture = sprite._texture;\n\n        color = CanvasTinter.roundColor(color);\n\n        const stringColor = `#${(`00000${(color | 0).toString(16)}`).substr(-6)}`;\n\n        texture.tintCache = texture.tintCache || {};\n\n        const cachedTexture = texture.tintCache[stringColor];\n\n        let canvas;\n\n        if (cachedTexture)\n        {\n            if (cachedTexture.tintId === texture._updateID)\n            {\n                return texture.tintCache[stringColor];\n            }\n\n            canvas = texture.tintCache[stringColor];\n        }\n        else\n        {\n            canvas = CanvasTinter.canvas || document.createElement('canvas');\n        }\n\n        CanvasTinter.tintMethod(texture, color, canvas);\n\n        canvas.tintId = texture._updateID;\n\n        if (CanvasTinter.convertTintToImage)\n        {\n            // is this better?\n            const tintImage = new Image();\n\n            tintImage.src = canvas.toDataURL();\n\n            texture.tintCache[stringColor] = tintImage;\n        }\n        else\n        {\n            texture.tintCache[stringColor] = canvas;\n            // if we are not converting the texture to an image then we need to lose the reference to the canvas\n            CanvasTinter.canvas = null;\n        }\n\n        return canvas;\n    },\n\n    /**\n     * Tint a texture using the 'multiply' operation.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithMultiply: (texture, color, canvas) =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = Math.ceil(crop.width);\n        canvas.height = Math.ceil(crop.height);\n\n        context.save();\n        context.fillStyle = `#${(`00000${(color | 0).toString(16)}`).substr(-6)}`;\n\n        context.fillRect(0, 0, crop.width, crop.height);\n\n        context.globalCompositeOperation = 'multiply';\n\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        context.globalCompositeOperation = 'destination-atop';\n\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n        context.restore();\n    },\n\n    /**\n     * Tint a texture using the 'overlay' operation.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithOverlay(texture, color, canvas)\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = Math.ceil(crop.width);\n        canvas.height = Math.ceil(crop.height);\n\n        context.save();\n        context.globalCompositeOperation = 'copy';\n        context.fillStyle = `#${(`00000${(color | 0).toString(16)}`).substr(-6)}`;\n        context.fillRect(0, 0, crop.width, crop.height);\n\n        context.globalCompositeOperation = 'destination-atop';\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n\n        // context.globalCompositeOperation = 'copy';\n        context.restore();\n    },\n\n    /**\n     * Tint a texture pixel per pixel.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {PIXI.Texture} texture - the texture to tint\n     * @param {number} color - the color to use to tint the sprite with\n     * @param {HTMLCanvasElement} canvas - the current canvas\n     */\n    tintWithPerPixel: (texture, color, canvas) =>\n    {\n        const context = canvas.getContext('2d');\n        const crop = texture._frame.clone();\n        const resolution = texture.baseTexture.resolution;\n\n        crop.x *= resolution;\n        crop.y *= resolution;\n        crop.width *= resolution;\n        crop.height *= resolution;\n\n        canvas.width = Math.ceil(crop.width);\n        canvas.height = Math.ceil(crop.height);\n\n        context.save();\n        context.globalCompositeOperation = 'copy';\n        context.drawImage(\n            texture.baseTexture.source,\n            crop.x,\n            crop.y,\n            crop.width,\n            crop.height,\n            0,\n            0,\n            crop.width,\n            crop.height\n        );\n        context.restore();\n\n        const rgbValues = hex2rgb(color);\n        const r = rgbValues[0];\n        const g = rgbValues[1];\n        const b = rgbValues[2];\n\n        const pixelData = context.getImageData(0, 0, crop.width, crop.height);\n\n        const pixels = pixelData.data;\n\n        for (let i = 0; i < pixels.length; i += 4)\n        {\n            pixels[i + 0] *= r;\n            pixels[i + 1] *= g;\n            pixels[i + 2] *= b;\n        }\n\n        context.putImageData(pixelData, 0, 0);\n    },\n\n    /**\n     * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @param {number} color - the color to round, should be a hex color\n     * @return {number} The rounded color.\n     */\n    roundColor: (color) =>\n    {\n        const step = CanvasTinter.cacheStepsPerColorChannel;\n\n        const rgbValues = hex2rgb(color);\n\n        rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);\n        rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);\n        rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);\n\n        return rgb2hex(rgbValues);\n    },\n\n    /**\n     * Number of steps which will be used as a cap when rounding colors.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {number}\n     */\n    cacheStepsPerColorChannel: 8,\n\n    /**\n     * Tint cache boolean flag.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {boolean}\n     */\n    convertTintToImage: false,\n\n    /**\n     * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {boolean}\n     */\n    canUseMultiply: canUseNewCanvasBlendModes(),\n\n    /**\n     * The tinting method that will be used.\n     *\n     * @memberof PIXI.CanvasTinter\n     * @type {tintMethodFunctionType}\n     */\n    tintMethod: 0,\n};\n\nCanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;\n\n/**\n * The tintMethod type.\n *\n * @memberof PIXI.CanvasTinter\n * @callback tintMethodFunctionType\n * @param texture {PIXI.Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\n\nexport default CanvasTinter;\n"]},"metadata":{},"sourceType":"script"}