{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _BaseTexture2 = require('./BaseTexture');\n\nvar _BaseTexture3 = _interopRequireDefault(_BaseTexture2);\n\nvar _settings = require('../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * A BaseRenderTexture is a special texture that allows any PixiJS display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a BaseRenderTexture should be preloaded\n * otherwise black rectangles will be drawn instead.\n *\n * A BaseRenderTexture takes a snapshot of any Display Object given to its render method. The position\n * and rotation of the given Display Objects is ignored. For example:\n *\n * ```js\n * let renderer = PIXI.autoDetectRenderer(1024, 1024);\n * let baseRenderTexture = new PIXI.BaseRenderTexture(800, 600);\n * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);\n * let sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n *\n * sprite.position.x = 800/2;\n * sprite.position.y = 600/2;\n * sprite.anchor.x = 0.5;\n * sprite.anchor.y = 0.5;\n *\n * renderer.render(sprite, renderTexture);\n * ```\n *\n * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0\n * you can clear the transform\n *\n * ```js\n *\n * sprite.setTransform()\n *\n * let baseRenderTexture = new PIXI.BaseRenderTexture(100, 100);\n * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);\n *\n * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture\n * ```\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n */\n\n\nvar BaseRenderTexture = function (_BaseTexture) {\n  _inherits(BaseRenderTexture, _BaseTexture);\n  /**\n   * @param {number} [width=100] - The width of the base render texture\n   * @param {number} [height=100] - The height of the base render texture\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated\n   */\n\n\n  function BaseRenderTexture() {\n    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 100;\n    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    var scaleMode = arguments[2];\n    var resolution = arguments[3];\n\n    _classCallCheck(this, BaseRenderTexture);\n\n    var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, null, scaleMode));\n\n    _this.resolution = resolution || _settings2.default.RESOLUTION;\n    _this.width = Math.ceil(width);\n    _this.height = Math.ceil(height);\n    _this.realWidth = _this.width * _this.resolution;\n    _this.realHeight = _this.height * _this.resolution;\n    _this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;\n    _this.hasLoaded = true;\n    /**\n     * A map of renderer IDs to webgl renderTargets\n     *\n     * @private\n     * @member {object<number, WebGLTexture>}\n     */\n\n    _this._glRenderTargets = {};\n    /**\n     * A reference to the canvas render target (we only need one as this can be shared across renderers)\n     *\n     * @private\n     * @member {object<number, WebGLTexture>}\n     */\n\n    _this._canvasRenderTarget = null;\n    /**\n     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n     *\n     * @member {boolean}\n     */\n\n    _this.valid = false;\n    return _this;\n  }\n  /**\n   * Resizes the BaseRenderTexture.\n   *\n   * @param {number} width - The width to resize to.\n   * @param {number} height - The height to resize to.\n   */\n\n\n  BaseRenderTexture.prototype.resize = function resize(width, height) {\n    width = Math.ceil(width);\n    height = Math.ceil(height);\n\n    if (width === this.width && height === this.height) {\n      return;\n    }\n\n    this.valid = width > 0 && height > 0;\n    this.width = width;\n    this.height = height;\n    this.realWidth = this.width * this.resolution;\n    this.realHeight = this.height * this.resolution;\n\n    if (!this.valid) {\n      return;\n    }\n\n    this.emit('update', this);\n  };\n  /**\n   * Destroys this texture\n   *\n   */\n\n\n  BaseRenderTexture.prototype.destroy = function destroy() {\n    _BaseTexture.prototype.destroy.call(this, true);\n\n    this.renderer = null;\n  };\n\n  return BaseRenderTexture;\n}(_BaseTexture3.default);\n\nexports.default = BaseRenderTexture;","map":{"version":3,"sources":["../../../src/core/textures/BaseRenderTexture.js"],"names":["BaseRenderTexture","width","height","scaleMode","resolution","Math","resize","destroy"],"mappings":";;;;AAAA,IAAA,aAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAwCqBA,iB;;AAEjB;;;;;;;;AAMA,WAAA,iBAAA,GACA;AAAA,QADYC,KACZ,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADoB,GACpB;AAAA,QADyBC,MACzB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADkC,GAClC;AAAA,QADuCC,SACvC,GAAA,SAAA,CAAA,CAAA,CAAA;AAAA,QADkDC,UAClD,GAAA,SAAA,CAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,iBAAA,CAAA;;AAAA,QAAA,KAAA,GAAA,0BAAA,CAAA,IAAA,EACI,YAAA,CAAA,IAAA,CAAA,IAAA,EAAA,IAAA,EADJ,SACI,CADJ,CAAA;;AAGI,IAAA,KAAA,CAAA,UAAA,GAAkBA,UAAAA,IAAc,UAAA,CAAA,OAAA,CAAhC,UAAA;AAEA,IAAA,KAAA,CAAA,KAAA,GAAaC,IAAAA,CAAAA,IAAAA,CAAb,KAAaA,CAAb;AACA,IAAA,KAAA,CAAA,MAAA,GAAcA,IAAAA,CAAAA,IAAAA,CAAd,MAAcA,CAAd;AAEA,IAAA,KAAA,CAAA,SAAA,GAAiB,KAAA,CAAA,KAAA,GAAa,KAAA,CAA9B,UAAA;AACA,IAAA,KAAA,CAAA,UAAA,GAAkB,KAAA,CAAA,MAAA,GAAc,KAAA,CAAhC,UAAA;AAEA,IAAA,KAAA,CAAA,SAAA,GAAiBF,SAAAA,KAAAA,SAAAA,GAAAA,SAAAA,GAAsC,UAAA,CAAA,OAAA,CAAvD,UAAA;AACA,IAAA,KAAA,CAAA,SAAA,GAAA,IAAA;AAEA;;;;;;;AAMA,IAAA,KAAA,CAAA,gBAAA,GAAA,EAAA;AAEA;;;;;;;AAMA,IAAA,KAAA,CAAA,mBAAA,GAAA,IAAA;AAEA;;;;;;AAKA,IAAA,KAAA,CAAA,KAAA,GAAA,KAAA;AAnCJ,WAAA,KAAA;AAoCC;AAED;;;;;;;;8BAMAG,M,mBAAOL,K,EAAOC,M,EACd;AACID,IAAAA,KAAAA,GAAQI,IAAAA,CAAAA,IAAAA,CAARJ,KAAQI,CAARJ;AACAC,IAAAA,MAAAA,GAASG,IAAAA,CAAAA,IAAAA,CAATH,MAASG,CAATH;;AAEA,QAAID,KAAAA,KAAU,KAAVA,KAAAA,IAAwBC,MAAAA,KAAW,KAAvC,MAAA,EACA;AACI;AACH;;AAED,SAAA,KAAA,GAAcD,KAAAA,GAAAA,CAAAA,IAAaC,MAAAA,GAA3B,CAAA;AAEA,SAAA,KAAA,GAAA,KAAA;AACA,SAAA,MAAA,GAAA,MAAA;AAEA,SAAA,SAAA,GAAiB,KAAA,KAAA,GAAa,KAA9B,UAAA;AACA,SAAA,UAAA,GAAkB,KAAA,MAAA,GAAc,KAAhC,UAAA;;AAEA,QAAI,CAAC,KAAL,KAAA,EACA;AACI;AACH;;AAED,SAAA,IAAA,CAAA,QAAA,EAAA,IAAA;;AAGJ;;;;;;8BAIAK,O,sBACA;AACI,IAAA,YAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA,EAAA,IAAA;;AACA,SAAA,QAAA,GAAA,IAAA;;;;;;kBAtFaP,iB","sourcesContent":["import BaseTexture from './BaseTexture';\nimport settings from '../settings';\n\n/**\n * A BaseRenderTexture is a special texture that allows any PixiJS display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a BaseRenderTexture should be preloaded\n * otherwise black rectangles will be drawn instead.\n *\n * A BaseRenderTexture takes a snapshot of any Display Object given to its render method. The position\n * and rotation of the given Display Objects is ignored. For example:\n *\n * ```js\n * let renderer = PIXI.autoDetectRenderer(1024, 1024);\n * let baseRenderTexture = new PIXI.BaseRenderTexture(800, 600);\n * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);\n * let sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n *\n * sprite.position.x = 800/2;\n * sprite.position.y = 600/2;\n * sprite.anchor.x = 0.5;\n * sprite.anchor.y = 0.5;\n *\n * renderer.render(sprite, renderTexture);\n * ```\n *\n * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0\n * you can clear the transform\n *\n * ```js\n *\n * sprite.setTransform()\n *\n * let baseRenderTexture = new PIXI.BaseRenderTexture(100, 100);\n * let renderTexture = new PIXI.RenderTexture(baseRenderTexture);\n *\n * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture\n * ```\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n */\nexport default class BaseRenderTexture extends BaseTexture\n{\n    /**\n     * @param {number} [width=100] - The width of the base render texture\n     * @param {number} [height=100] - The height of the base render texture\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated\n     */\n    constructor(width = 100, height = 100, scaleMode, resolution)\n    {\n        super(null, scaleMode);\n\n        this.resolution = resolution || settings.RESOLUTION;\n\n        this.width = Math.ceil(width);\n        this.height = Math.ceil(height);\n\n        this.realWidth = this.width * this.resolution;\n        this.realHeight = this.height * this.resolution;\n\n        this.scaleMode = scaleMode !== undefined ? scaleMode : settings.SCALE_MODE;\n        this.hasLoaded = true;\n\n        /**\n         * A map of renderer IDs to webgl renderTargets\n         *\n         * @private\n         * @member {object<number, WebGLTexture>}\n         */\n        this._glRenderTargets = {};\n\n        /**\n         * A reference to the canvas render target (we only need one as this can be shared across renderers)\n         *\n         * @private\n         * @member {object<number, WebGLTexture>}\n         */\n        this._canvasRenderTarget = null;\n\n        /**\n         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n         *\n         * @member {boolean}\n         */\n        this.valid = false;\n    }\n\n    /**\n     * Resizes the BaseRenderTexture.\n     *\n     * @param {number} width - The width to resize to.\n     * @param {number} height - The height to resize to.\n     */\n    resize(width, height)\n    {\n        width = Math.ceil(width);\n        height = Math.ceil(height);\n\n        if (width === this.width && height === this.height)\n        {\n            return;\n        }\n\n        this.valid = (width > 0 && height > 0);\n\n        this.width = width;\n        this.height = height;\n\n        this.realWidth = this.width * this.resolution;\n        this.realHeight = this.height * this.resolution;\n\n        if (!this.valid)\n        {\n            return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /**\n     * Destroys this texture\n     *\n     */\n    destroy()\n    {\n        super.destroy(true);\n        this.renderer = null;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}