{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _math = require('../../../math');\n\nvar _const = require('../../../const');\n\nvar _settings = require('../../../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nvar _pixiGlCore = require('pixi-gl-core');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * @class\n * @memberof PIXI\n */\n\n\nvar RenderTarget = function () {\n  /**\n   * @param {WebGLRenderingContext} gl - The current WebGL drawing context\n   * @param {number} [width=0] - the horizontal range of the filter\n   * @param {number} [height=0] - the vertical range of the filter\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {number} [resolution=1] - The current resolution / device pixel ratio\n   * @param {boolean} [root=false] - Whether this object is the root element or not\n   */\n  function RenderTarget(gl, width, height, scaleMode, resolution, root) {\n    _classCallCheck(this, RenderTarget); // TODO Resolution could go here ( eg low res blurs )\n\n    /**\n     * The current WebGL drawing context.\n     *\n     * @member {WebGLRenderingContext}\n     */\n\n\n    this.gl = gl; // next time to create a frame buffer and texture\n\n    /**\n     * A frame buffer\n     *\n     * @member {PIXI.glCore.GLFramebuffer}\n     */\n\n    this.frameBuffer = null;\n    /**\n     * The texture\n     *\n     * @member {PIXI.glCore.GLTexture}\n     */\n\n    this.texture = null;\n    /**\n     * The background colour of this render target, as an array of [r,g,b,a] values\n     *\n     * @member {number[]}\n     */\n\n    this.clearColor = [0, 0, 0, 0];\n    /**\n     * The size of the object as a rectangle\n     *\n     * @member {PIXI.Rectangle}\n     */\n\n    this.size = new _math.Rectangle(0, 0, 1, 1);\n    /**\n     * The current resolution / device pixel ratio\n     *\n     * @member {number}\n     * @default 1\n     */\n\n    this.resolution = resolution || _settings2.default.RESOLUTION;\n    /**\n     * The projection matrix\n     *\n     * @member {PIXI.Matrix}\n     */\n\n    this.projectionMatrix = new _math.Matrix();\n    /**\n     * The object's transform\n     *\n     * @member {PIXI.Matrix}\n     */\n\n    this.transform = null;\n    /**\n     * The frame.\n     *\n     * @member {PIXI.Rectangle}\n     */\n\n    this.frame = null;\n    /**\n     * The stencil buffer stores masking data for the render target\n     *\n     * @member {glCore.GLBuffer}\n     */\n\n    this.defaultFrame = new _math.Rectangle();\n    this.destinationFrame = null;\n    this.sourceFrame = null;\n    /**\n     * The stencil buffer stores masking data for the render target\n     *\n     * @member {glCore.GLBuffer}\n     */\n\n    this.stencilBuffer = null;\n    /**\n     * The data structure for the stencil masks\n     *\n     * @member {PIXI.Graphics[]}\n     */\n\n    this.stencilMaskStack = [];\n    /**\n     * Stores filter data for the render target\n     *\n     * @member {object[]}\n     */\n\n    this.filterData = null;\n    /**\n     * The key for pooled texture of FilterSystem\n     * @private\n     * @member {string}\n     */\n\n    this.filterPoolKey = '';\n    /**\n     * The scale mode.\n     *\n     * @member {number}\n     * @default PIXI.settings.SCALE_MODE\n     * @see PIXI.SCALE_MODES\n     */\n\n    this.scaleMode = scaleMode !== undefined ? scaleMode : _settings2.default.SCALE_MODE;\n    /**\n     * Whether this object is the root element or not\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    this.root = root || false;\n\n    if (!this.root) {\n      this.frameBuffer = _pixiGlCore.GLFramebuffer.createRGBA(gl, 100, 100);\n\n      if (this.scaleMode === _const.SCALE_MODES.NEAREST) {\n        this.frameBuffer.texture.enableNearestScaling();\n      } else {\n        this.frameBuffer.texture.enableLinearScaling();\n      }\n      /*\n          A frame buffer needs a target to render to..\n          create a texture and bind it attach it to the framebuffer..\n       */\n      // this is used by the base texture\n\n\n      this.texture = this.frameBuffer.texture;\n    } else {\n      // make it a null framebuffer..\n      this.frameBuffer = new _pixiGlCore.GLFramebuffer(gl, 100, 100);\n      this.frameBuffer.framebuffer = null;\n    }\n\n    this.setFrame();\n    this.resize(width, height);\n  }\n  /**\n   * Clears the filter texture.\n   *\n   * @param {number[]} [clearColor=this.clearColor] - Array of [r,g,b,a] to clear the framebuffer\n   */\n\n\n  RenderTarget.prototype.clear = function clear(clearColor) {\n    var cc = clearColor || this.clearColor;\n    this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]); // r,g,b,a);\n  };\n  /**\n   * Binds the stencil buffer.\n   *\n   */\n\n\n  RenderTarget.prototype.attachStencilBuffer = function attachStencilBuffer() {\n    // TODO check if stencil is done?\n\n    /**\n     * The stencil buffer is used for masking in pixi\n     * lets create one and then add attach it to the framebuffer..\n     */\n    if (!this.root) {\n      this.frameBuffer.enableStencil();\n    }\n  };\n  /**\n   * Sets the frame of the render target.\n   *\n   * @param {Rectangle} destinationFrame - The destination frame.\n   * @param {Rectangle} sourceFrame - The source frame.\n   */\n\n\n  RenderTarget.prototype.setFrame = function setFrame(destinationFrame, sourceFrame) {\n    this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;\n    this.sourceFrame = sourceFrame || this.sourceFrame || this.destinationFrame;\n  };\n  /**\n   * Binds the buffers and initialises the viewport.\n   *\n   */\n\n\n  RenderTarget.prototype.activate = function activate() {\n    // TODO refactor usage of frame..\n    var gl = this.gl; // make sure the texture is unbound!\n\n    this.frameBuffer.bind();\n    this.calculateProjection(this.destinationFrame, this.sourceFrame);\n\n    if (this.transform) {\n      this.projectionMatrix.append(this.transform);\n    } // TODO add a check as them may be the same!\n\n\n    if (this.destinationFrame !== this.sourceFrame) {\n      gl.enable(gl.SCISSOR_TEST);\n      gl.scissor(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);\n    } else {\n      gl.disable(gl.SCISSOR_TEST);\n    } // TODO - does not need to be updated all the time??\n\n\n    gl.viewport(this.destinationFrame.x | 0, this.destinationFrame.y | 0, this.destinationFrame.width * this.resolution | 0, this.destinationFrame.height * this.resolution | 0);\n  };\n  /**\n   * Updates the projection matrix based on a projection frame (which is a rectangle)\n   *\n   * @param {Rectangle} destinationFrame - The destination frame.\n   * @param {Rectangle} sourceFrame - The source frame.\n   */\n\n\n  RenderTarget.prototype.calculateProjection = function calculateProjection(destinationFrame, sourceFrame) {\n    var pm = this.projectionMatrix;\n    sourceFrame = sourceFrame || destinationFrame;\n    pm.identity(); // TODO: make dest scale source\n\n    if (!this.root) {\n      pm.a = 1 / destinationFrame.width * 2;\n      pm.d = 1 / destinationFrame.height * 2;\n      pm.tx = -1 - sourceFrame.x * pm.a;\n      pm.ty = -1 - sourceFrame.y * pm.d;\n    } else {\n      pm.a = 1 / destinationFrame.width * 2;\n      pm.d = -1 / destinationFrame.height * 2;\n      pm.tx = -1 - sourceFrame.x * pm.a;\n      pm.ty = 1 - sourceFrame.y * pm.d;\n    }\n  };\n  /**\n   * Resizes the texture to the specified width and height\n   *\n   * @param {number} width - the new width of the texture\n   * @param {number} height - the new height of the texture\n   */\n\n\n  RenderTarget.prototype.resize = function resize(width, height) {\n    width = width | 0;\n    height = height | 0;\n\n    if (this.size.width === width && this.size.height === height) {\n      return;\n    }\n\n    this.size.width = width;\n    this.size.height = height;\n    this.defaultFrame.width = width;\n    this.defaultFrame.height = height;\n    this.frameBuffer.resize(width * this.resolution, height * this.resolution);\n    var projectionFrame = this.frame || this.size;\n    this.calculateProjection(projectionFrame);\n  };\n  /**\n   * Destroys the render target.\n   *\n   */\n\n\n  RenderTarget.prototype.destroy = function destroy() {\n    if (this.frameBuffer.stencil) {\n      this.gl.deleteRenderbuffer(this.frameBuffer.stencil);\n    }\n\n    this.frameBuffer.destroy();\n    this.frameBuffer = null;\n    this.texture = null;\n  };\n\n  return RenderTarget;\n}();\n\nexports.default = RenderTarget;","map":{"version":3,"sources":["../../../../../src/core/renderers/webgl/utils/RenderTarget.js"],"names":["RenderTarget","resolution","scaleMode","root","clear","clearColor","cc","attachStencilBuffer","setFrame","destinationFrame","sourceFrame","activate","gl","calculateProjection","pm","resize","width","height","projectionFrame","destroy"],"mappings":"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","sourcesContent":["import { Rectangle, Matrix } from '../../../math';\nimport { SCALE_MODES } from '../../../const';\nimport settings from '../../../settings';\nimport { GLFramebuffer } from 'pixi-gl-core';\n\n/**\n * @class\n * @memberof PIXI\n */\nexport default class RenderTarget\n{\n    /**\n     * @param {WebGLRenderingContext} gl - The current WebGL drawing context\n     * @param {number} [width=0] - the horizontal range of the filter\n     * @param {number} [height=0] - the vertical range of the filter\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [resolution=1] - The current resolution / device pixel ratio\n     * @param {boolean} [root=false] - Whether this object is the root element or not\n     */\n    constructor(gl, width, height, scaleMode, resolution, root)\n    {\n        // TODO Resolution could go here ( eg low res blurs )\n\n        /**\n         * The current WebGL drawing context.\n         *\n         * @member {WebGLRenderingContext}\n         */\n        this.gl = gl;\n\n        // next time to create a frame buffer and texture\n\n        /**\n         * A frame buffer\n         *\n         * @member {PIXI.glCore.GLFramebuffer}\n         */\n        this.frameBuffer = null;\n\n        /**\n         * The texture\n         *\n         * @member {PIXI.glCore.GLTexture}\n         */\n        this.texture = null;\n\n        /**\n         * The background colour of this render target, as an array of [r,g,b,a] values\n         *\n         * @member {number[]}\n         */\n        this.clearColor = [0, 0, 0, 0];\n\n        /**\n         * The size of the object as a rectangle\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.size = new Rectangle(0, 0, 1, 1);\n\n        /**\n         * The current resolution / device pixel ratio\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.resolution = resolution || settings.RESOLUTION;\n\n        /**\n         * The projection matrix\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.projectionMatrix = new Matrix();\n\n        /**\n         * The object's transform\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.transform = null;\n\n        /**\n         * The frame.\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.frame = null;\n\n        /**\n         * The stencil buffer stores masking data for the render target\n         *\n         * @member {glCore.GLBuffer}\n         */\n        this.defaultFrame = new Rectangle();\n        this.destinationFrame = null;\n        this.sourceFrame = null;\n\n        /**\n         * The stencil buffer stores masking data for the render target\n         *\n         * @member {glCore.GLBuffer}\n         */\n        this.stencilBuffer = null;\n\n        /**\n         * The data structure for the stencil masks\n         *\n         * @member {PIXI.Graphics[]}\n         */\n        this.stencilMaskStack = [];\n\n        /**\n         * Stores filter data for the render target\n         *\n         * @member {object[]}\n         */\n        this.filterData = null;\n\n        /**\n         * The key for pooled texture of FilterSystem\n         * @private\n         * @member {string}\n         */\n        this.filterPoolKey = '';\n\n        /**\n         * The scale mode.\n         *\n         * @member {number}\n         * @default PIXI.settings.SCALE_MODE\n         * @see PIXI.SCALE_MODES\n         */\n        this.scaleMode = scaleMode !== undefined ? scaleMode : settings.SCALE_MODE;\n\n        /**\n         * Whether this object is the root element or not\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.root = root || false;\n\n        if (!this.root)\n        {\n            this.frameBuffer = GLFramebuffer.createRGBA(gl, 100, 100);\n\n            if (this.scaleMode === SCALE_MODES.NEAREST)\n            {\n                this.frameBuffer.texture.enableNearestScaling();\n            }\n            else\n            {\n                this.frameBuffer.texture.enableLinearScaling();\n            }\n            /*\n                A frame buffer needs a target to render to..\n                create a texture and bind it attach it to the framebuffer..\n             */\n\n            // this is used by the base texture\n            this.texture = this.frameBuffer.texture;\n        }\n        else\n        {\n            // make it a null framebuffer..\n            this.frameBuffer = new GLFramebuffer(gl, 100, 100);\n            this.frameBuffer.framebuffer = null;\n        }\n\n        this.setFrame();\n\n        this.resize(width, height);\n    }\n\n    /**\n     * Clears the filter texture.\n     *\n     * @param {number[]} [clearColor=this.clearColor] - Array of [r,g,b,a] to clear the framebuffer\n     */\n    clear(clearColor)\n    {\n        const cc = clearColor || this.clearColor;\n\n        this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]);// r,g,b,a);\n    }\n\n    /**\n     * Binds the stencil buffer.\n     *\n     */\n    attachStencilBuffer()\n    {\n        // TODO check if stencil is done?\n        /**\n         * The stencil buffer is used for masking in pixi\n         * lets create one and then add attach it to the framebuffer..\n         */\n        if (!this.root)\n        {\n            this.frameBuffer.enableStencil();\n        }\n    }\n\n    /**\n     * Sets the frame of the render target.\n     *\n     * @param {Rectangle} destinationFrame - The destination frame.\n     * @param {Rectangle} sourceFrame - The source frame.\n     */\n    setFrame(destinationFrame, sourceFrame)\n    {\n        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;\n        this.sourceFrame = sourceFrame || this.sourceFrame || this.destinationFrame;\n    }\n\n    /**\n     * Binds the buffers and initialises the viewport.\n     *\n     */\n    activate()\n    {\n        // TODO refactor usage of frame..\n        const gl = this.gl;\n\n        // make sure the texture is unbound!\n        this.frameBuffer.bind();\n\n        this.calculateProjection(this.destinationFrame, this.sourceFrame);\n\n        if (this.transform)\n        {\n            this.projectionMatrix.append(this.transform);\n        }\n\n        // TODO add a check as them may be the same!\n        if (this.destinationFrame !== this.sourceFrame)\n        {\n            gl.enable(gl.SCISSOR_TEST);\n            gl.scissor(\n                this.destinationFrame.x | 0,\n                this.destinationFrame.y | 0,\n                (this.destinationFrame.width * this.resolution) | 0,\n                (this.destinationFrame.height * this.resolution) | 0\n            );\n        }\n        else\n        {\n            gl.disable(gl.SCISSOR_TEST);\n        }\n\n        // TODO - does not need to be updated all the time??\n        gl.viewport(\n            this.destinationFrame.x | 0,\n            this.destinationFrame.y | 0,\n            (this.destinationFrame.width * this.resolution) | 0,\n            (this.destinationFrame.height * this.resolution) | 0\n        );\n    }\n\n    /**\n     * Updates the projection matrix based on a projection frame (which is a rectangle)\n     *\n     * @param {Rectangle} destinationFrame - The destination frame.\n     * @param {Rectangle} sourceFrame - The source frame.\n     */\n    calculateProjection(destinationFrame, sourceFrame)\n    {\n        const pm = this.projectionMatrix;\n\n        sourceFrame = sourceFrame || destinationFrame;\n\n        pm.identity();\n\n        // TODO: make dest scale source\n        if (!this.root)\n        {\n            pm.a = 1 / destinationFrame.width * 2;\n            pm.d = 1 / destinationFrame.height * 2;\n\n            pm.tx = -1 - (sourceFrame.x * pm.a);\n            pm.ty = -1 - (sourceFrame.y * pm.d);\n        }\n        else\n        {\n            pm.a = 1 / destinationFrame.width * 2;\n            pm.d = -1 / destinationFrame.height * 2;\n\n            pm.tx = -1 - (sourceFrame.x * pm.a);\n            pm.ty = 1 - (sourceFrame.y * pm.d);\n        }\n    }\n\n    /**\n     * Resizes the texture to the specified width and height\n     *\n     * @param {number} width - the new width of the texture\n     * @param {number} height - the new height of the texture\n     */\n    resize(width, height)\n    {\n        width = width | 0;\n        height = height | 0;\n\n        if (this.size.width === width && this.size.height === height)\n        {\n            return;\n        }\n\n        this.size.width = width;\n        this.size.height = height;\n\n        this.defaultFrame.width = width;\n        this.defaultFrame.height = height;\n\n        this.frameBuffer.resize(width * this.resolution, height * this.resolution);\n\n        const projectionFrame = this.frame || this.size;\n\n        this.calculateProjection(projectionFrame);\n    }\n\n    /**\n     * Destroys the render target.\n     *\n     */\n    destroy()\n    {\n        if (this.frameBuffer.stencil)\n        {\n            this.gl.deleteRenderbuffer(this.frameBuffer.stencil);\n        }\n        this.frameBuffer.destroy();\n\n        this.frameBuffer = null;\n        this.texture = null;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}