{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _BaseRenderTexture = require('./BaseRenderTexture');\n\nvar _BaseRenderTexture2 = _interopRequireDefault(_BaseRenderTexture);\n\nvar _Texture2 = require('./Texture');\n\nvar _Texture3 = _interopRequireDefault(_Texture2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * A RenderTexture is a special texture that allows any PixiJS display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded\n * otherwise black rectangles will be drawn instead.\n *\n * A RenderTexture takes a snapshot of any Display Object given to its render method. For example:\n *\n * ```js\n * let renderer = PIXI.autoDetectRenderer(1024, 1024);\n * let renderTexture = PIXI.RenderTexture.create(800, 600);\n * let sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n *\n * sprite.position.x = 800/2;\n * sprite.position.y = 600/2;\n * sprite.anchor.x = 0.5;\n * sprite.anchor.y = 0.5;\n *\n * renderer.render(sprite, renderTexture);\n * ```\n *\n * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0\n * you can clear the transform\n *\n * ```js\n *\n * sprite.setTransform()\n *\n * let renderTexture = new PIXI.RenderTexture.create(100, 100);\n *\n * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture\n * ```\n *\n * @class\n * @extends PIXI.Texture\n * @memberof PIXI\n */\n\n\nvar RenderTexture = function (_Texture) {\n  _inherits(RenderTexture, _Texture);\n  /**\n   * @param {PIXI.BaseRenderTexture} baseRenderTexture - The renderer used for this RenderTexture\n   * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show\n   */\n\n\n  function RenderTexture(baseRenderTexture, frame) {\n    _classCallCheck(this, RenderTexture); // support for legacy..\n\n\n    var _legacyRenderer = null;\n\n    if (!(baseRenderTexture instanceof _BaseRenderTexture2.default)) {\n      /* eslint-disable prefer-rest-params, no-console */\n      var width = arguments[1];\n      var height = arguments[2];\n      var scaleMode = arguments[3];\n      var resolution = arguments[4]; // we have an old render texture..\n\n      console.warn('Please use RenderTexture.create(' + width + ', ' + height + ') instead of the ctor directly.');\n      _legacyRenderer = arguments[0];\n      /* eslint-enable prefer-rest-params, no-console */\n\n      frame = null;\n      baseRenderTexture = new _BaseRenderTexture2.default(width, height, scaleMode, resolution);\n    }\n    /**\n     * The base texture object that this texture uses\n     *\n     * @member {BaseTexture}\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _Texture.call(this, baseRenderTexture, frame));\n\n    _this.legacyRenderer = _legacyRenderer;\n    /**\n     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n     *\n     * @member {boolean}\n     */\n\n    _this.valid = true;\n\n    _this._updateUvs();\n\n    return _this;\n  }\n  /**\n   * Resizes the RenderTexture.\n   *\n   * @param {number} width - The width to resize to.\n   * @param {number} height - The height to resize to.\n   * @param {boolean} doNotResizeBaseTexture - Should the baseTexture.width and height values be resized as well?\n   */\n\n\n  RenderTexture.prototype.resize = function resize(width, height, doNotResizeBaseTexture) {\n    width = Math.ceil(width);\n    height = Math.ceil(height); // TODO - could be not required..\n\n    this.valid = width > 0 && height > 0;\n    this._frame.width = this.orig.width = width;\n    this._frame.height = this.orig.height = height;\n\n    if (!doNotResizeBaseTexture) {\n      this.baseTexture.resize(width, height);\n    }\n\n    this._updateUvs();\n  };\n  /**\n   * A short hand way of creating a render texture.\n   *\n   * @param {number} [width=100] - The width of the render texture\n   * @param {number} [height=100] - The height of the render texture\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated\n   * @return {PIXI.RenderTexture} The new render texture\n   */\n\n\n  RenderTexture.create = function create(width, height, scaleMode, resolution) {\n    return new RenderTexture(new _BaseRenderTexture2.default(width, height, scaleMode, resolution));\n  };\n\n  return RenderTexture;\n}(_Texture3.default);\n\nexports.default = RenderTexture;","map":{"version":3,"sources":["../../../src/core/textures/RenderTexture.js"],"names":["RenderTexture","_legacyRenderer","baseRenderTexture","width","arguments","height","scaleMode","resolution","console","frame","resize","doNotResizeBaseTexture","Math","create"],"mappings":";;;;AAAA,IAAA,kBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAqCqBA,a;;AAEjB;;;;;;AAIA,WAAA,aAAA,CAAA,iBAAA,EAAA,KAAA,EACA;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,aAAA,CAAA,CAAA,CACI;;;AACA,QAAIC,eAAAA,GAAJ,IAAA;;AAEA,QAAI,EAAEC,iBAAAA,YAAAA,mBAAAA,CAAN,OAAI,CAAJ,EACA;AACI;AACA,UAAMC,KAAAA,GAAQC,SAAAA,CAAd,CAAcA,CAAd;AACA,UAAMC,MAAAA,GAASD,SAAAA,CAAf,CAAeA,CAAf;AACA,UAAME,SAAAA,GAAYF,SAAAA,CAAlB,CAAkBA,CAAlB;AACA,UAAMG,UAAAA,GAAaH,SAAAA,CAAnB,CAAmBA,CAAnB,CALJ,CAOI;;AACAI,MAAAA,OAAAA,CAAAA,IAAAA,CAAAA,qCAAAA,KAAAA,GAAAA,IAAAA,GAAAA,MAAAA,GAAAA,iCAAAA;AACAP,MAAAA,eAAAA,GAAkBG,SAAAA,CAAlBH,CAAkBG,CAAlBH;AACA;;AAEAQ,MAAAA,KAAAA,GAAAA,IAAAA;AACAP,MAAAA,iBAAAA,GAAoB,IAAA,mBAAA,CAAA,OAAA,CAAA,KAAA,EAAA,MAAA,EAAA,SAAA,EAApBA,UAAoB,CAApBA;AACH;AAED;;;;;;;AArBJ,QAAA,KAAA,GAAA,0BAAA,CAAA,IAAA,EA0BI,QAAA,CAAA,IAAA,CAAA,IAAA,EAAA,iBAAA,EA1BJ,KA0BI,CA1BJ,CAAA;;AA+BI,IAAA,KAAA,CAAA,cAAA,GAAA,eAAA;AAEA;;;;;;AAKA,IAAA,KAAA,CAAA,KAAA,GAAA,IAAA;;AAEA,IAAA,KAAA,CAAA,UAAA;;AAxCJ,WAAA,KAAA;AAyCC;AAED;;;;;;;;;0BAOAQ,M,mBAAOP,K,EAAOE,M,EAAQM,sB,EACtB;AACIR,IAAAA,KAAAA,GAAQS,IAAAA,CAAAA,IAAAA,CAART,KAAQS,CAART;AACAE,IAAAA,MAAAA,GAASO,IAAAA,CAAAA,IAAAA,CAATP,MAASO,CAATP,CAFJ,CAII;;AACA,SAAA,KAAA,GAAcF,KAAAA,GAAAA,CAAAA,IAAaE,MAAAA,GAA3B,CAAA;AAEA,SAAA,MAAA,CAAA,KAAA,GAAoB,KAAA,IAAA,CAAA,KAAA,GAApB,KAAA;AACA,SAAA,MAAA,CAAA,MAAA,GAAqB,KAAA,IAAA,CAAA,MAAA,GAArB,MAAA;;AAEA,QAAI,CAAJ,sBAAA,EACA;AACI,WAAA,WAAA,CAAA,MAAA,CAAA,KAAA,EAAA,MAAA;AACH;;AAED,SAAA,UAAA;;AAGJ;;;;;;;;;;;gBASOQ,M,mBAAOV,K,EAAOE,M,EAAQC,S,EAAWC,U,EACxC;AACI,WAAO,IAAA,aAAA,CAAkB,IAAA,mBAAA,CAAA,OAAA,CAAA,KAAA,EAAA,MAAA,EAAA,SAAA,EAAzB,UAAyB,CAAlB,CAAP;;;;;;kBAvFaP,a","sourcesContent":["import BaseRenderTexture from './BaseRenderTexture';\nimport Texture from './Texture';\n\n/**\n * A RenderTexture is a special texture that allows any PixiJS display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded\n * otherwise black rectangles will be drawn instead.\n *\n * A RenderTexture takes a snapshot of any Display Object given to its render method. For example:\n *\n * ```js\n * let renderer = PIXI.autoDetectRenderer(1024, 1024);\n * let renderTexture = PIXI.RenderTexture.create(800, 600);\n * let sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n *\n * sprite.position.x = 800/2;\n * sprite.position.y = 600/2;\n * sprite.anchor.x = 0.5;\n * sprite.anchor.y = 0.5;\n *\n * renderer.render(sprite, renderTexture);\n * ```\n *\n * The Sprite in this case will be rendered using its local transform. To render this sprite at 0,0\n * you can clear the transform\n *\n * ```js\n *\n * sprite.setTransform()\n *\n * let renderTexture = new PIXI.RenderTexture.create(100, 100);\n *\n * renderer.render(sprite, renderTexture);  // Renders to center of RenderTexture\n * ```\n *\n * @class\n * @extends PIXI.Texture\n * @memberof PIXI\n */\nexport default class RenderTexture extends Texture\n{\n    /**\n     * @param {PIXI.BaseRenderTexture} baseRenderTexture - The renderer used for this RenderTexture\n     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show\n     */\n    constructor(baseRenderTexture, frame)\n    {\n        // support for legacy..\n        let _legacyRenderer = null;\n\n        if (!(baseRenderTexture instanceof BaseRenderTexture))\n        {\n            /* eslint-disable prefer-rest-params, no-console */\n            const width = arguments[1];\n            const height = arguments[2];\n            const scaleMode = arguments[3];\n            const resolution = arguments[4];\n\n            // we have an old render texture..\n            console.warn(`Please use RenderTexture.create(${width}, ${height}) instead of the ctor directly.`);\n            _legacyRenderer = arguments[0];\n            /* eslint-enable prefer-rest-params, no-console */\n\n            frame = null;\n            baseRenderTexture = new BaseRenderTexture(width, height, scaleMode, resolution);\n        }\n\n        /**\n         * The base texture object that this texture uses\n         *\n         * @member {BaseTexture}\n         */\n        super(\n            baseRenderTexture,\n            frame\n        );\n\n        this.legacyRenderer = _legacyRenderer;\n\n        /**\n         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n         *\n         * @member {boolean}\n         */\n        this.valid = true;\n\n        this._updateUvs();\n    }\n\n    /**\n     * Resizes the RenderTexture.\n     *\n     * @param {number} width - The width to resize to.\n     * @param {number} height - The height to resize to.\n     * @param {boolean} doNotResizeBaseTexture - Should the baseTexture.width and height values be resized as well?\n     */\n    resize(width, height, doNotResizeBaseTexture)\n    {\n        width = Math.ceil(width);\n        height = Math.ceil(height);\n\n        // TODO - could be not required..\n        this.valid = (width > 0 && height > 0);\n\n        this._frame.width = this.orig.width = width;\n        this._frame.height = this.orig.height = height;\n\n        if (!doNotResizeBaseTexture)\n        {\n            this.baseTexture.resize(width, height);\n        }\n\n        this._updateUvs();\n    }\n\n    /**\n     * A short hand way of creating a render texture.\n     *\n     * @param {number} [width=100] - The width of the render texture\n     * @param {number} [height=100] - The height of the render texture\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [resolution=1] - The resolution / device pixel ratio of the texture being generated\n     * @return {PIXI.RenderTexture} The new render texture\n     */\n    static create(width, height, scaleMode, resolution)\n    {\n        return new RenderTexture(new BaseRenderTexture(width, height, scaleMode, resolution));\n    }\n}\n"]},"metadata":{},"sourceType":"script"}