{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _SystemRenderer2 = require('../SystemRenderer');\n\nvar _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);\n\nvar _CanvasMaskManager = require('./utils/CanvasMaskManager');\n\nvar _CanvasMaskManager2 = _interopRequireDefault(_CanvasMaskManager);\n\nvar _CanvasRenderTarget = require('./utils/CanvasRenderTarget');\n\nvar _CanvasRenderTarget2 = _interopRequireDefault(_CanvasRenderTarget);\n\nvar _mapCanvasBlendModesToPixi = require('./utils/mapCanvasBlendModesToPixi');\n\nvar _mapCanvasBlendModesToPixi2 = _interopRequireDefault(_mapCanvasBlendModesToPixi);\n\nvar _utils = require('../../utils');\n\nvar _const = require('../../const');\n\nvar _settings = require('../../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should\n * be used for browsers that do not support WebGL. Don't forget to add the CanvasRenderer.view to\n * your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\n\n\nvar CanvasRenderer = function (_SystemRenderer) {\n  _inherits(CanvasRenderer, _SystemRenderer); // eslint-disable-next-line valid-jsdoc\n\n  /**\n   * @param {object} [options] - The optional renderer parameters\n   * @param {number} [options.width=800] - the width of the screen\n   * @param {number} [options.height=600] - the height of the screen\n   * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n   * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n   * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n   * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)\n   * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The\n   *  resolution of the renderer retina would be 2.\n   * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n   *  enable this if you need to call toDataUrl on the webgl context.\n   * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or\n   *      not before the new render pass.\n   * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n   *  (shown if not transparent).\n   * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,\n   *  stopping pixel interpolation.\n   */\n\n\n  function CanvasRenderer(options, arg2, arg3) {\n    _classCallCheck(this, CanvasRenderer);\n\n    var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'Canvas', options, arg2, arg3));\n\n    _this.type = _const.RENDERER_TYPE.CANVAS;\n    /**\n     * The root canvas 2d context that everything is drawn with.\n     *\n     * @member {CanvasRenderingContext2D}\n     */\n\n    _this.rootContext = _this.view.getContext('2d', {\n      alpha: _this.transparent\n    });\n    /**\n     * The currently active canvas 2d context (could change with renderTextures)\n     *\n     * @member {CanvasRenderingContext2D}\n     */\n\n    _this.context = _this.rootContext;\n    /**\n     * Boolean flag controlling canvas refresh.\n     *\n     * @member {boolean}\n     */\n\n    _this.refresh = true;\n    /**\n     * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.\n     *\n     * @member {PIXI.CanvasMaskManager}\n     */\n\n    _this.maskManager = new _CanvasMaskManager2.default(_this);\n    /**\n     * The canvas property used to set the canvas smoothing property.\n     *\n     * @member {string}\n     */\n\n    _this.smoothProperty = 'imageSmoothingEnabled';\n\n    if (!_this.rootContext.imageSmoothingEnabled) {\n      if (_this.rootContext.webkitImageSmoothingEnabled) {\n        _this.smoothProperty = 'webkitImageSmoothingEnabled';\n      } else if (_this.rootContext.mozImageSmoothingEnabled) {\n        _this.smoothProperty = 'mozImageSmoothingEnabled';\n      } else if (_this.rootContext.oImageSmoothingEnabled) {\n        _this.smoothProperty = 'oImageSmoothingEnabled';\n      } else if (_this.rootContext.msImageSmoothingEnabled) {\n        _this.smoothProperty = 'msImageSmoothingEnabled';\n      }\n    }\n\n    _this.initPlugins();\n\n    _this.blendModes = (0, _mapCanvasBlendModesToPixi2.default)();\n    _this._activeBlendMode = null;\n    _this.renderingToScreen = false;\n\n    _this.resize(_this.options.width, _this.options.height);\n    /**\n     * Fired after rendering finishes.\n     *\n     * @event PIXI.CanvasRenderer#postrender\n     */\n\n    /**\n     * Fired before rendering starts.\n     *\n     * @event PIXI.CanvasRenderer#prerender\n     */\n\n\n    return _this;\n  }\n  /**\n   * Renders the object to this canvas view\n   *\n   * @param {PIXI.DisplayObject} displayObject - The object to be rendered\n   * @param {PIXI.RenderTexture} [renderTexture] - A render texture to be rendered to.\n   *  If unset, it will render to the root context.\n   * @param {boolean} [clear=false] - Whether to clear the canvas before drawing\n   * @param {PIXI.Matrix} [transform] - A transformation to be applied\n   * @param {boolean} [skipUpdateTransform=false] - Whether to skip the update transform\n   */\n\n\n  CanvasRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {\n    if (!this.view) {\n      return;\n    } // can be handy to know!\n\n\n    this.renderingToScreen = !renderTexture;\n    this.emit('prerender');\n    var rootResolution = this.resolution;\n\n    if (renderTexture) {\n      renderTexture = renderTexture.baseTexture || renderTexture;\n\n      if (!renderTexture._canvasRenderTarget) {\n        renderTexture._canvasRenderTarget = new _CanvasRenderTarget2.default(renderTexture.width, renderTexture.height, renderTexture.resolution);\n        renderTexture.source = renderTexture._canvasRenderTarget.canvas;\n        renderTexture.valid = true;\n      }\n\n      this.context = renderTexture._canvasRenderTarget.context;\n      this.resolution = renderTexture._canvasRenderTarget.resolution;\n    } else {\n      this.context = this.rootContext;\n    }\n\n    var context = this.context;\n\n    if (!renderTexture) {\n      this._lastObjectRendered = displayObject;\n    }\n\n    if (!skipUpdateTransform) {\n      // update the scene graph\n      var cacheParent = displayObject.parent;\n      var tempWt = this._tempDisplayObjectParent.transform.worldTransform;\n\n      if (transform) {\n        transform.copy(tempWt); // lets not forget to flag the parent transform as dirty...\n\n        this._tempDisplayObjectParent.transform._worldID = -1;\n      } else {\n        tempWt.identity();\n      }\n\n      displayObject.parent = this._tempDisplayObjectParent;\n      displayObject.updateTransform();\n      displayObject.parent = cacheParent; // displayObject.hitArea = //TODO add a temp hit area\n    }\n\n    context.save();\n    context.setTransform(1, 0, 0, 1, 0, 0);\n    context.globalAlpha = 1;\n    this._activeBlendMode = _const.BLEND_MODES.NORMAL;\n    context.globalCompositeOperation = this.blendModes[_const.BLEND_MODES.NORMAL];\n\n    if (navigator.isCocoonJS && this.view.screencanvas) {\n      context.fillStyle = 'black';\n      context.clear();\n    }\n\n    if (clear !== undefined ? clear : this.clearBeforeRender) {\n      if (this.renderingToScreen) {\n        if (this.transparent) {\n          context.clearRect(0, 0, this.width, this.height);\n        } else {\n          context.fillStyle = this._backgroundColorString;\n          context.fillRect(0, 0, this.width, this.height);\n        }\n      } // else {\n      // TODO: implement background for CanvasRenderTarget or RenderTexture?\n      // }\n\n    } // TODO RENDER TARGET STUFF HERE..\n\n\n    var tempContext = this.context;\n    this.context = context;\n    displayObject.renderCanvas(this);\n    this.context = tempContext;\n    context.restore();\n    this.resolution = rootResolution;\n    this.emit('postrender');\n  };\n  /**\n   * Clear the canvas of renderer.\n   *\n   * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.\n   */\n\n\n  CanvasRenderer.prototype.clear = function clear(clearColor) {\n    var context = this.context;\n    clearColor = clearColor || this._backgroundColorString;\n\n    if (!this.transparent && clearColor) {\n      context.fillStyle = clearColor;\n      context.fillRect(0, 0, this.width, this.height);\n    } else {\n      context.clearRect(0, 0, this.width, this.height);\n    }\n  };\n  /**\n   * Sets the blend mode of the renderer.\n   *\n   * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.\n   */\n\n\n  CanvasRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {\n    if (this._activeBlendMode === blendMode) {\n      return;\n    }\n\n    this._activeBlendMode = blendMode;\n    this.context.globalCompositeOperation = this.blendModes[blendMode];\n  };\n  /**\n   * Removes everything from the renderer and optionally removes the Canvas DOM element.\n   *\n   * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n   */\n\n\n  CanvasRenderer.prototype.destroy = function destroy(removeView) {\n    this.destroyPlugins(); // call the base destroy\n\n    _SystemRenderer.prototype.destroy.call(this, removeView);\n\n    this.context = null;\n    this.refresh = true;\n    this.maskManager.destroy();\n    this.maskManager = null;\n    this.smoothProperty = null;\n  };\n  /**\n   * Resizes the canvas view to the specified width and height.\n   *\n   * @extends PIXI.SystemRenderer#resize\n   *\n   * @param {number} screenWidth - the new width of the screen\n   * @param {number} screenHeight - the new height of the screen\n   */\n\n\n  CanvasRenderer.prototype.resize = function resize(screenWidth, screenHeight) {\n    _SystemRenderer.prototype.resize.call(this, screenWidth, screenHeight); // reset the scale mode.. oddly this seems to be reset when the canvas is resized.\n    // surely a browser bug?? Let PixiJS fix that for you..\n\n\n    if (this.smoothProperty) {\n      this.rootContext[this.smoothProperty] = _settings2.default.SCALE_MODE === _const.SCALE_MODES.LINEAR;\n    }\n  };\n  /**\n   * Checks if blend mode has changed.\n   */\n\n\n  CanvasRenderer.prototype.invalidateBlendMode = function invalidateBlendMode() {\n    this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);\n  };\n\n  return CanvasRenderer;\n}(_SystemRenderer3.default);\n/**\n * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n * by creating a custom build. Consult the README for more information about creating custom\n * builds and excluding plugins.\n * @name PIXI.CanvasRenderer#plugins\n * @type {object}\n * @readonly\n * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.\n * @property {PIXI.extract.CanvasExtract} extract Extract image data from renderer.\n * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.\n * @property {PIXI.prepare.CanvasPrepare} prepare Pre-render display objects.\n */\n\n/**\n * Adds a plugin to the renderer.\n *\n * @method PIXI.CanvasRenderer#registerPlugin\n * @param {string} pluginName - The name of the plugin.\n * @param {Function} ctor - The constructor function or class for the plugin.\n */\n\n\nexports.default = CanvasRenderer;\n\n_utils.pluginTarget.mixin(CanvasRenderer);","map":{"version":3,"sources":["../../../../src/core/renderers/canvas/CanvasRenderer.js"],"names":["CanvasRenderer","alpha","render","displayObject","renderTexture","clear","transform","skipUpdateTransform","rootResolution","context","cacheParent","tempWt","navigator","tempContext","clearColor","setBlendMode","blendMode","destroy","removeView","resize","screenWidth","screenHeight","invalidateBlendMode"],"mappings":"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","sourcesContent":["import SystemRenderer from '../SystemRenderer';\nimport CanvasMaskManager from './utils/CanvasMaskManager';\nimport CanvasRenderTarget from './utils/CanvasRenderTarget';\nimport mapCanvasBlendModesToPixi from './utils/mapCanvasBlendModesToPixi';\nimport { pluginTarget } from '../../utils';\nimport { RENDERER_TYPE, SCALE_MODES, BLEND_MODES } from '../../const';\nimport settings from '../../settings';\n\n/**\n * The CanvasRenderer draws the scene and all its content onto a 2d canvas. This renderer should\n * be used for browsers that do not support WebGL. Don't forget to add the CanvasRenderer.view to\n * your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\nexport default class CanvasRenderer extends SystemRenderer\n{\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     * @param {object} [options] - The optional renderer parameters\n     * @param {number} [options.width=800] - the width of the screen\n     * @param {number} [options.height=600] - the height of the screen\n     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n     * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n     * @param {boolean} [options.antialias=false] - sets antialias (only applicable in chrome at the moment)\n     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer. The\n     *  resolution of the renderer retina would be 2.\n     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n     *  enable this if you need to call toDataUrl on the webgl context.\n     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear the canvas or\n     *      not before the new render pass.\n     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n     *  (shown if not transparent).\n     * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when rendering,\n     *  stopping pixel interpolation.\n     */\n    constructor(options, arg2, arg3)\n    {\n        super('Canvas', options, arg2, arg3);\n\n        this.type = RENDERER_TYPE.CANVAS;\n\n        /**\n         * The root canvas 2d context that everything is drawn with.\n         *\n         * @member {CanvasRenderingContext2D}\n         */\n        this.rootContext = this.view.getContext('2d', { alpha: this.transparent });\n\n        /**\n         * The currently active canvas 2d context (could change with renderTextures)\n         *\n         * @member {CanvasRenderingContext2D}\n         */\n        this.context = this.rootContext;\n\n        /**\n         * Boolean flag controlling canvas refresh.\n         *\n         * @member {boolean}\n         */\n        this.refresh = true;\n\n        /**\n         * Instance of a CanvasMaskManager, handles masking when using the canvas renderer.\n         *\n         * @member {PIXI.CanvasMaskManager}\n         */\n        this.maskManager = new CanvasMaskManager(this);\n\n        /**\n         * The canvas property used to set the canvas smoothing property.\n         *\n         * @member {string}\n         */\n        this.smoothProperty = 'imageSmoothingEnabled';\n\n        if (!this.rootContext.imageSmoothingEnabled)\n        {\n            if (this.rootContext.webkitImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'webkitImageSmoothingEnabled';\n            }\n            else if (this.rootContext.mozImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'mozImageSmoothingEnabled';\n            }\n            else if (this.rootContext.oImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'oImageSmoothingEnabled';\n            }\n            else if (this.rootContext.msImageSmoothingEnabled)\n            {\n                this.smoothProperty = 'msImageSmoothingEnabled';\n            }\n        }\n\n        this.initPlugins();\n\n        this.blendModes = mapCanvasBlendModesToPixi();\n        this._activeBlendMode = null;\n\n        this.renderingToScreen = false;\n\n        this.resize(this.options.width, this.options.height);\n\n        /**\n         * Fired after rendering finishes.\n         *\n         * @event PIXI.CanvasRenderer#postrender\n         */\n\n        /**\n         * Fired before rendering starts.\n         *\n         * @event PIXI.CanvasRenderer#prerender\n         */\n    }\n\n    /**\n     * Renders the object to this canvas view\n     *\n     * @param {PIXI.DisplayObject} displayObject - The object to be rendered\n     * @param {PIXI.RenderTexture} [renderTexture] - A render texture to be rendered to.\n     *  If unset, it will render to the root context.\n     * @param {boolean} [clear=false] - Whether to clear the canvas before drawing\n     * @param {PIXI.Matrix} [transform] - A transformation to be applied\n     * @param {boolean} [skipUpdateTransform=false] - Whether to skip the update transform\n     */\n    render(displayObject, renderTexture, clear, transform, skipUpdateTransform)\n    {\n        if (!this.view)\n        {\n            return;\n        }\n\n        // can be handy to know!\n        this.renderingToScreen = !renderTexture;\n\n        this.emit('prerender');\n\n        const rootResolution = this.resolution;\n\n        if (renderTexture)\n        {\n            renderTexture = renderTexture.baseTexture || renderTexture;\n\n            if (!renderTexture._canvasRenderTarget)\n            {\n                renderTexture._canvasRenderTarget = new CanvasRenderTarget(\n                    renderTexture.width,\n                    renderTexture.height,\n                    renderTexture.resolution\n                );\n                renderTexture.source = renderTexture._canvasRenderTarget.canvas;\n                renderTexture.valid = true;\n            }\n\n            this.context = renderTexture._canvasRenderTarget.context;\n            this.resolution = renderTexture._canvasRenderTarget.resolution;\n        }\n        else\n        {\n            this.context = this.rootContext;\n        }\n\n        const context = this.context;\n\n        if (!renderTexture)\n        {\n            this._lastObjectRendered = displayObject;\n        }\n\n        if (!skipUpdateTransform)\n        {\n            // update the scene graph\n            const cacheParent = displayObject.parent;\n            const tempWt = this._tempDisplayObjectParent.transform.worldTransform;\n\n            if (transform)\n            {\n                transform.copy(tempWt);\n\n                // lets not forget to flag the parent transform as dirty...\n                this._tempDisplayObjectParent.transform._worldID = -1;\n            }\n            else\n            {\n                tempWt.identity();\n            }\n\n            displayObject.parent = this._tempDisplayObjectParent;\n\n            displayObject.updateTransform();\n            displayObject.parent = cacheParent;\n            // displayObject.hitArea = //TODO add a temp hit area\n        }\n\n        context.save();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        context.globalAlpha = 1;\n        this._activeBlendMode = BLEND_MODES.NORMAL;\n        context.globalCompositeOperation = this.blendModes[BLEND_MODES.NORMAL];\n\n        if (navigator.isCocoonJS && this.view.screencanvas)\n        {\n            context.fillStyle = 'black';\n            context.clear();\n        }\n\n        if (clear !== undefined ? clear : this.clearBeforeRender)\n        {\n            if (this.renderingToScreen)\n            {\n                if (this.transparent)\n                {\n                    context.clearRect(0, 0, this.width, this.height);\n                }\n                else\n                {\n                    context.fillStyle = this._backgroundColorString;\n                    context.fillRect(0, 0, this.width, this.height);\n                }\n            } // else {\n            // TODO: implement background for CanvasRenderTarget or RenderTexture?\n            // }\n        }\n\n        // TODO RENDER TARGET STUFF HERE..\n        const tempContext = this.context;\n\n        this.context = context;\n        displayObject.renderCanvas(this);\n        this.context = tempContext;\n\n        context.restore();\n\n        this.resolution = rootResolution;\n\n        this.emit('postrender');\n    }\n\n    /**\n     * Clear the canvas of renderer.\n     *\n     * @param {string} [clearColor] - Clear the canvas with this color, except the canvas is transparent.\n     */\n    clear(clearColor)\n    {\n        const context = this.context;\n\n        clearColor = clearColor || this._backgroundColorString;\n\n        if (!this.transparent && clearColor)\n        {\n            context.fillStyle = clearColor;\n            context.fillRect(0, 0, this.width, this.height);\n        }\n        else\n        {\n            context.clearRect(0, 0, this.width, this.height);\n        }\n    }\n\n    /**\n     * Sets the blend mode of the renderer.\n     *\n     * @param {number} blendMode - See {@link PIXI.BLEND_MODES} for valid values.\n     */\n    setBlendMode(blendMode)\n    {\n        if (this._activeBlendMode === blendMode)\n        {\n            return;\n        }\n\n        this._activeBlendMode = blendMode;\n        this.context.globalCompositeOperation = this.blendModes[blendMode];\n    }\n\n    /**\n     * Removes everything from the renderer and optionally removes the Canvas DOM element.\n     *\n     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n     */\n    destroy(removeView)\n    {\n        this.destroyPlugins();\n\n        // call the base destroy\n        super.destroy(removeView);\n\n        this.context = null;\n\n        this.refresh = true;\n\n        this.maskManager.destroy();\n        this.maskManager = null;\n\n        this.smoothProperty = null;\n    }\n\n    /**\n     * Resizes the canvas view to the specified width and height.\n     *\n     * @extends PIXI.SystemRenderer#resize\n     *\n     * @param {number} screenWidth - the new width of the screen\n     * @param {number} screenHeight - the new height of the screen\n     */\n    resize(screenWidth, screenHeight)\n    {\n        super.resize(screenWidth, screenHeight);\n\n        // reset the scale mode.. oddly this seems to be reset when the canvas is resized.\n        // surely a browser bug?? Let PixiJS fix that for you..\n        if (this.smoothProperty)\n        {\n            this.rootContext[this.smoothProperty] = (settings.SCALE_MODE === SCALE_MODES.LINEAR);\n        }\n    }\n\n    /**\n     * Checks if blend mode has changed.\n     */\n    invalidateBlendMode()\n    {\n        this._activeBlendMode = this.blendModes.indexOf(this.context.globalCompositeOperation);\n    }\n}\n\n/**\n * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n * by creating a custom build. Consult the README for more information about creating custom\n * builds and excluding plugins.\n * @name PIXI.CanvasRenderer#plugins\n * @type {object}\n * @readonly\n * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.\n * @property {PIXI.extract.CanvasExtract} extract Extract image data from renderer.\n * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.\n * @property {PIXI.prepare.CanvasPrepare} prepare Pre-render display objects.\n */\n\n/**\n * Adds a plugin to the renderer.\n *\n * @method PIXI.CanvasRenderer#registerPlugin\n * @param {string} pluginName - The name of the plugin.\n * @param {Function} ctor - The constructor function or class for the plugin.\n */\n\npluginTarget.mixin(CanvasRenderer);\n"]},"metadata":{},"sourceType":"script"}