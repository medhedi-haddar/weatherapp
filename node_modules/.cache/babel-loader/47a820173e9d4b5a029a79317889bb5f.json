{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _core = require('../../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _Mesh = require('../Mesh');\n\nvar _Mesh2 = _interopRequireDefault(_Mesh);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Renderer dedicated to meshes.\n *\n * @class\n * @private\n * @memberof PIXI\n */\n\n\nvar MeshSpriteRenderer = function () {\n  /**\n   * @param {PIXI.CanvasRenderer} renderer - The renderer this downport works for\n   */\n  function MeshSpriteRenderer(renderer) {\n    _classCallCheck(this, MeshSpriteRenderer);\n\n    this.renderer = renderer;\n  }\n  /**\n   * Renders the Mesh\n   *\n   * @param {PIXI.mesh.Mesh} mesh - the Mesh to render\n   */\n\n\n  MeshSpriteRenderer.prototype.render = function render(mesh) {\n    var renderer = this.renderer;\n    var context = renderer.context;\n    var transform = mesh.worldTransform;\n    var res = renderer.resolution;\n\n    if (renderer.roundPixels) {\n      context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res | 0, transform.ty * res | 0);\n    } else {\n      context.setTransform(transform.a * res, transform.b * res, transform.c * res, transform.d * res, transform.tx * res, transform.ty * res);\n    }\n\n    renderer.context.globalAlpha = mesh.worldAlpha;\n    renderer.setBlendMode(mesh.blendMode);\n\n    if (mesh.drawMode === _Mesh2.default.DRAW_MODES.TRIANGLE_MESH) {\n      this._renderTriangleMesh(mesh);\n    } else {\n      this._renderTriangles(mesh);\n    }\n  };\n  /**\n   * Draws the object in Triangle Mesh mode\n   *\n   * @private\n   * @param {PIXI.mesh.Mesh} mesh - the Mesh to render\n   */\n\n\n  MeshSpriteRenderer.prototype._renderTriangleMesh = function _renderTriangleMesh(mesh) {\n    // draw triangles!!\n    var length = mesh.vertices.length / 2;\n\n    for (var i = 0; i < length - 2; i++) {\n      // draw some triangles!\n      var index = i * 2;\n\n      this._renderDrawTriangle(mesh, index, index + 2, index + 4);\n    }\n  };\n  /**\n   * Draws the object in triangle mode using canvas\n   *\n   * @private\n   * @param {PIXI.mesh.Mesh} mesh - the current mesh\n   */\n\n\n  MeshSpriteRenderer.prototype._renderTriangles = function _renderTriangles(mesh) {\n    // draw triangles!!\n    var indices = mesh.indices;\n    var length = indices.length;\n\n    for (var i = 0; i < length; i += 3) {\n      // draw some triangles!\n      var index0 = indices[i] * 2;\n      var index1 = indices[i + 1] * 2;\n      var index2 = indices[i + 2] * 2;\n\n      this._renderDrawTriangle(mesh, index0, index1, index2);\n    }\n  };\n  /**\n   * Draws one of the triangles that from the Mesh\n   *\n   * @private\n   * @param {PIXI.mesh.Mesh} mesh - the current mesh\n   * @param {number} index0 - the index of the first vertex\n   * @param {number} index1 - the index of the second vertex\n   * @param {number} index2 - the index of the third vertex\n   */\n\n\n  MeshSpriteRenderer.prototype._renderDrawTriangle = function _renderDrawTriangle(mesh, index0, index1, index2) {\n    var context = this.renderer.context;\n    var uvs = mesh.uvs;\n    var vertices = mesh.vertices;\n    var texture = mesh._texture;\n\n    if (!texture.valid) {\n      return;\n    }\n\n    var base = texture.baseTexture;\n    var textureSource = base.source;\n    var textureWidth = base.width;\n    var textureHeight = base.height;\n    var u0 = void 0;\n    var u1 = void 0;\n    var u2 = void 0;\n    var v0 = void 0;\n    var v1 = void 0;\n    var v2 = void 0;\n\n    if (mesh.uploadUvTransform) {\n      var ut = mesh._uvTransform.mapCoord;\n      u0 = (uvs[index0] * ut.a + uvs[index0 + 1] * ut.c + ut.tx) * base.width;\n      u1 = (uvs[index1] * ut.a + uvs[index1 + 1] * ut.c + ut.tx) * base.width;\n      u2 = (uvs[index2] * ut.a + uvs[index2 + 1] * ut.c + ut.tx) * base.width;\n      v0 = (uvs[index0] * ut.b + uvs[index0 + 1] * ut.d + ut.ty) * base.height;\n      v1 = (uvs[index1] * ut.b + uvs[index1 + 1] * ut.d + ut.ty) * base.height;\n      v2 = (uvs[index2] * ut.b + uvs[index2 + 1] * ut.d + ut.ty) * base.height;\n    } else {\n      u0 = uvs[index0] * base.width;\n      u1 = uvs[index1] * base.width;\n      u2 = uvs[index2] * base.width;\n      v0 = uvs[index0 + 1] * base.height;\n      v1 = uvs[index1 + 1] * base.height;\n      v2 = uvs[index2 + 1] * base.height;\n    }\n\n    var x0 = vertices[index0];\n    var x1 = vertices[index1];\n    var x2 = vertices[index2];\n    var y0 = vertices[index0 + 1];\n    var y1 = vertices[index1 + 1];\n    var y2 = vertices[index2 + 1];\n    var canvasPadding = mesh.canvasPadding / this.renderer.resolution;\n\n    if (canvasPadding > 0) {\n      var paddingX = canvasPadding / Math.abs(mesh.worldTransform.a);\n      var paddingY = canvasPadding / Math.abs(mesh.worldTransform.d);\n      var centerX = (x0 + x1 + x2) / 3;\n      var centerY = (y0 + y1 + y2) / 3;\n      var normX = x0 - centerX;\n      var normY = y0 - centerY;\n      var dist = Math.sqrt(normX * normX + normY * normY);\n      x0 = centerX + normX / dist * (dist + paddingX);\n      y0 = centerY + normY / dist * (dist + paddingY); //\n\n      normX = x1 - centerX;\n      normY = y1 - centerY;\n      dist = Math.sqrt(normX * normX + normY * normY);\n      x1 = centerX + normX / dist * (dist + paddingX);\n      y1 = centerY + normY / dist * (dist + paddingY);\n      normX = x2 - centerX;\n      normY = y2 - centerY;\n      dist = Math.sqrt(normX * normX + normY * normY);\n      x2 = centerX + normX / dist * (dist + paddingX);\n      y2 = centerY + normY / dist * (dist + paddingY);\n    }\n\n    context.save();\n    context.beginPath();\n    context.moveTo(x0, y0);\n    context.lineTo(x1, y1);\n    context.lineTo(x2, y2);\n    context.closePath();\n    context.clip(); // Compute matrix transform\n\n    var delta = u0 * v1 + v0 * u2 + u1 * v2 - v1 * u2 - v0 * u1 - u0 * v2;\n    var deltaA = x0 * v1 + v0 * x2 + x1 * v2 - v1 * x2 - v0 * x1 - x0 * v2;\n    var deltaB = u0 * x1 + x0 * u2 + u1 * x2 - x1 * u2 - x0 * u1 - u0 * x2;\n    var deltaC = u0 * v1 * x2 + v0 * x1 * u2 + x0 * u1 * v2 - x0 * v1 * u2 - v0 * u1 * x2 - u0 * x1 * v2;\n    var deltaD = y0 * v1 + v0 * y2 + y1 * v2 - v1 * y2 - v0 * y1 - y0 * v2;\n    var deltaE = u0 * y1 + y0 * u2 + u1 * y2 - y1 * u2 - y0 * u1 - u0 * y2;\n    var deltaF = u0 * v1 * y2 + v0 * y1 * u2 + y0 * u1 * v2 - y0 * v1 * u2 - v0 * u1 * y2 - u0 * y1 * v2;\n    context.transform(deltaA / delta, deltaD / delta, deltaB / delta, deltaE / delta, deltaC / delta, deltaF / delta);\n    context.drawImage(textureSource, 0, 0, textureWidth * base.resolution, textureHeight * base.resolution, 0, 0, textureWidth, textureHeight);\n    context.restore();\n    this.renderer.invalidateBlendMode();\n  };\n  /**\n   * Renders a flat Mesh\n   *\n   * @private\n   * @param {PIXI.mesh.Mesh} mesh - The Mesh to render\n   */\n\n\n  MeshSpriteRenderer.prototype.renderMeshFlat = function renderMeshFlat(mesh) {\n    var context = this.renderer.context;\n    var vertices = mesh.vertices;\n    var length = vertices.length / 2; // this.count++;\n\n    context.beginPath();\n\n    for (var i = 1; i < length - 2; ++i) {\n      // draw some triangles!\n      var index = i * 2;\n      var x0 = vertices[index];\n      var y0 = vertices[index + 1];\n      var x1 = vertices[index + 2];\n      var y1 = vertices[index + 3];\n      var x2 = vertices[index + 4];\n      var y2 = vertices[index + 5];\n      context.moveTo(x0, y0);\n      context.lineTo(x1, y1);\n      context.lineTo(x2, y2);\n    }\n\n    context.fillStyle = '#FF0000';\n    context.fill();\n    context.closePath();\n  };\n  /**\n   * destroy the the renderer.\n   *\n   */\n\n\n  MeshSpriteRenderer.prototype.destroy = function destroy() {\n    this.renderer = null;\n  };\n\n  return MeshSpriteRenderer;\n}();\n\nexports.default = MeshSpriteRenderer;\ncore.CanvasRenderer.registerPlugin('mesh', MeshSpriteRenderer);","map":{"version":3,"sources":["../../../src/mesh/canvas/CanvasMeshRenderer.js"],"names":["core","MeshSpriteRenderer","render","mesh","renderer","context","transform","res","_renderTriangleMesh","length","i","index","_renderTriangles","indices","index0","index1","index2","_renderDrawTriangle","uvs","vertices","texture","base","textureSource","textureWidth","textureHeight","u0","u1","u2","v0","v1","v2","ut","x0","x1","x2","y0","y1","y2","canvasPadding","paddingX","Math","paddingY","centerX","centerY","normX","normY","dist","delta","deltaA","deltaB","deltaC","deltaD","deltaE","deltaF","renderMeshFlat","destroy"],"mappings":"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","sourcesContent":["import * as core from '../../core';\nimport { default as Mesh } from '../Mesh';\n\n/**\n * Renderer dedicated to meshes.\n *\n * @class\n * @private\n * @memberof PIXI\n */\nexport default class MeshSpriteRenderer\n{\n    /**\n     * @param {PIXI.CanvasRenderer} renderer - The renderer this downport works for\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Renders the Mesh\n     *\n     * @param {PIXI.mesh.Mesh} mesh - the Mesh to render\n     */\n    render(mesh)\n    {\n        const renderer = this.renderer;\n        const context = renderer.context;\n\n        const transform = mesh.worldTransform;\n        const res = renderer.resolution;\n\n        if (renderer.roundPixels)\n        {\n            context.setTransform(\n                transform.a * res,\n                transform.b * res,\n                transform.c * res,\n                transform.d * res,\n                (transform.tx * res) | 0,\n                (transform.ty * res) | 0\n            );\n        }\n        else\n        {\n            context.setTransform(\n                transform.a * res,\n                transform.b * res,\n                transform.c * res,\n                transform.d * res,\n                transform.tx * res,\n                transform.ty * res\n            );\n        }\n\n        renderer.context.globalAlpha = mesh.worldAlpha;\n        renderer.setBlendMode(mesh.blendMode);\n\n        if (mesh.drawMode === Mesh.DRAW_MODES.TRIANGLE_MESH)\n        {\n            this._renderTriangleMesh(mesh);\n        }\n        else\n        {\n            this._renderTriangles(mesh);\n        }\n    }\n\n    /**\n     * Draws the object in Triangle Mesh mode\n     *\n     * @private\n     * @param {PIXI.mesh.Mesh} mesh - the Mesh to render\n     */\n    _renderTriangleMesh(mesh)\n    {\n        // draw triangles!!\n        const length = mesh.vertices.length / 2;\n\n        for (let i = 0; i < length - 2; i++)\n        {\n            // draw some triangles!\n            const index = i * 2;\n\n            this._renderDrawTriangle(mesh, index, (index + 2), (index + 4));\n        }\n    }\n\n    /**\n     * Draws the object in triangle mode using canvas\n     *\n     * @private\n     * @param {PIXI.mesh.Mesh} mesh - the current mesh\n     */\n    _renderTriangles(mesh)\n    {\n        // draw triangles!!\n        const indices = mesh.indices;\n        const length = indices.length;\n\n        for (let i = 0; i < length; i += 3)\n        {\n            // draw some triangles!\n            const index0 = indices[i] * 2;\n            const index1 = indices[i + 1] * 2;\n            const index2 = indices[i + 2] * 2;\n\n            this._renderDrawTriangle(mesh, index0, index1, index2);\n        }\n    }\n\n    /**\n     * Draws one of the triangles that from the Mesh\n     *\n     * @private\n     * @param {PIXI.mesh.Mesh} mesh - the current mesh\n     * @param {number} index0 - the index of the first vertex\n     * @param {number} index1 - the index of the second vertex\n     * @param {number} index2 - the index of the third vertex\n     */\n    _renderDrawTriangle(mesh, index0, index1, index2)\n    {\n        const context = this.renderer.context;\n        const uvs = mesh.uvs;\n        const vertices = mesh.vertices;\n        const texture = mesh._texture;\n\n        if (!texture.valid)\n        {\n            return;\n        }\n\n        const base = texture.baseTexture;\n        const textureSource = base.source;\n        const textureWidth = base.width;\n        const textureHeight = base.height;\n\n        let u0;\n        let u1;\n        let u2;\n        let v0;\n        let v1;\n        let v2;\n\n        if (mesh.uploadUvTransform)\n        {\n            const ut = mesh._uvTransform.mapCoord;\n\n            u0 = ((uvs[index0] * ut.a) + (uvs[index0 + 1] * ut.c) + ut.tx) * base.width;\n            u1 = ((uvs[index1] * ut.a) + (uvs[index1 + 1] * ut.c) + ut.tx) * base.width;\n            u2 = ((uvs[index2] * ut.a) + (uvs[index2 + 1] * ut.c) + ut.tx) * base.width;\n            v0 = ((uvs[index0] * ut.b) + (uvs[index0 + 1] * ut.d) + ut.ty) * base.height;\n            v1 = ((uvs[index1] * ut.b) + (uvs[index1 + 1] * ut.d) + ut.ty) * base.height;\n            v2 = ((uvs[index2] * ut.b) + (uvs[index2 + 1] * ut.d) + ut.ty) * base.height;\n        }\n        else\n        {\n            u0 = uvs[index0] * base.width;\n            u1 = uvs[index1] * base.width;\n            u2 = uvs[index2] * base.width;\n            v0 = uvs[index0 + 1] * base.height;\n            v1 = uvs[index1 + 1] * base.height;\n            v2 = uvs[index2 + 1] * base.height;\n        }\n\n        let x0 = vertices[index0];\n        let x1 = vertices[index1];\n        let x2 = vertices[index2];\n        let y0 = vertices[index0 + 1];\n        let y1 = vertices[index1 + 1];\n        let y2 = vertices[index2 + 1];\n\n        const canvasPadding = mesh.canvasPadding / this.renderer.resolution;\n\n        if (canvasPadding > 0)\n        {\n            const paddingX = canvasPadding / Math.abs(mesh.worldTransform.a);\n            const paddingY = canvasPadding / Math.abs(mesh.worldTransform.d);\n            const centerX = (x0 + x1 + x2) / 3;\n            const centerY = (y0 + y1 + y2) / 3;\n\n            let normX = x0 - centerX;\n            let normY = y0 - centerY;\n\n            let dist = Math.sqrt((normX * normX) + (normY * normY));\n\n            x0 = centerX + ((normX / dist) * (dist + paddingX));\n            y0 = centerY + ((normY / dist) * (dist + paddingY));\n\n            //\n\n            normX = x1 - centerX;\n            normY = y1 - centerY;\n\n            dist = Math.sqrt((normX * normX) + (normY * normY));\n            x1 = centerX + ((normX / dist) * (dist + paddingX));\n            y1 = centerY + ((normY / dist) * (dist + paddingY));\n\n            normX = x2 - centerX;\n            normY = y2 - centerY;\n\n            dist = Math.sqrt((normX * normX) + (normY * normY));\n            x2 = centerX + ((normX / dist) * (dist + paddingX));\n            y2 = centerY + ((normY / dist) * (dist + paddingY));\n        }\n\n        context.save();\n        context.beginPath();\n\n        context.moveTo(x0, y0);\n        context.lineTo(x1, y1);\n        context.lineTo(x2, y2);\n\n        context.closePath();\n\n        context.clip();\n\n        // Compute matrix transform\n        const delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);\n        const deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);\n        const deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);\n        const deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);\n        const deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);\n        const deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);\n        const deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);\n\n        context.transform(\n            deltaA / delta,\n            deltaD / delta,\n            deltaB / delta,\n            deltaE / delta,\n            deltaC / delta,\n            deltaF / delta\n        );\n\n        context.drawImage(\n            textureSource,\n            0,\n            0,\n            textureWidth * base.resolution,\n            textureHeight * base.resolution,\n            0,\n            0,\n            textureWidth,\n            textureHeight\n        );\n\n        context.restore();\n        this.renderer.invalidateBlendMode();\n    }\n\n    /**\n     * Renders a flat Mesh\n     *\n     * @private\n     * @param {PIXI.mesh.Mesh} mesh - The Mesh to render\n     */\n    renderMeshFlat(mesh)\n    {\n        const context = this.renderer.context;\n        const vertices = mesh.vertices;\n        const length = vertices.length / 2;\n\n        // this.count++;\n\n        context.beginPath();\n\n        for (let i = 1; i < length - 2; ++i)\n        {\n            // draw some triangles!\n            const index = i * 2;\n\n            const x0 = vertices[index];\n            const y0 = vertices[index + 1];\n\n            const x1 = vertices[index + 2];\n            const y1 = vertices[index + 3];\n\n            const x2 = vertices[index + 4];\n            const y2 = vertices[index + 5];\n\n            context.moveTo(x0, y0);\n            context.lineTo(x1, y1);\n            context.lineTo(x2, y2);\n        }\n\n        context.fillStyle = '#FF0000';\n        context.fill();\n        context.closePath();\n    }\n\n    /**\n     * destroy the the renderer.\n     *\n     */\n    destroy()\n    {\n        this.renderer = null;\n    }\n}\n\ncore.CanvasRenderer.registerPlugin('mesh', MeshSpriteRenderer);\n"]},"metadata":{},"sourceType":"script"}