{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _CanvasRenderer = require('../../renderers/canvas/CanvasRenderer');\n\nvar _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);\n\nvar _const = require('../../const');\n\nvar _math = require('../../math');\n\nvar _CanvasTinter = require('./CanvasTinter');\n\nvar _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar canvasRenderWorldTransform = new _math.Matrix();\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasSpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @private\n * @memberof PIXI\n */\n\nvar CanvasSpriteRenderer = function () {\n  /**\n   * @param {PIXI.WebGLRenderer} renderer -The renderer sprite this batch works for.\n   */\n  function CanvasSpriteRenderer(renderer) {\n    _classCallCheck(this, CanvasSpriteRenderer);\n\n    this.renderer = renderer;\n  }\n  /**\n   * Renders the sprite object.\n   *\n   * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n   */\n\n\n  CanvasSpriteRenderer.prototype.render = function render(sprite) {\n    var texture = sprite._texture;\n    var renderer = this.renderer;\n    var width = texture._frame.width;\n    var height = texture._frame.height;\n    var wt = sprite.transform.worldTransform;\n    var dx = 0;\n    var dy = 0;\n\n    if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.baseTexture.source) {\n      return;\n    }\n\n    renderer.setBlendMode(sprite.blendMode); //  Ignore null sources\n\n    if (texture.valid) {\n      renderer.context.globalAlpha = sprite.worldAlpha; // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture\n\n      var smoothingEnabled = texture.baseTexture.scaleMode === _const.SCALE_MODES.LINEAR;\n\n      if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled) {\n        renderer.context[renderer.smoothProperty] = smoothingEnabled;\n      }\n\n      if (texture.trim) {\n        dx = texture.trim.width / 2 + texture.trim.x - sprite.anchor.x * texture.orig.width;\n        dy = texture.trim.height / 2 + texture.trim.y - sprite.anchor.y * texture.orig.height;\n      } else {\n        dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n        dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n      }\n\n      if (texture.rotate) {\n        wt.copy(canvasRenderWorldTransform);\n        wt = canvasRenderWorldTransform;\n\n        _math.GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy); // the anchor has already been applied above, so lets set it to zero\n\n\n        dx = 0;\n        dy = 0;\n      }\n\n      dx -= width / 2;\n      dy -= height / 2; // Allow for pixel rounding\n\n      if (renderer.roundPixels) {\n        renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution | 0, wt.ty * renderer.resolution | 0);\n        dx = dx | 0;\n        dy = dy | 0;\n      } else {\n        renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);\n      }\n\n      var resolution = texture.baseTexture.resolution;\n\n      if (sprite.tint !== 0xFFFFFF) {\n        if (sprite.cachedTint !== sprite.tint || sprite.tintedTexture.tintId !== sprite._texture._updateID) {\n          sprite.cachedTint = sprite.tint; // TODO clean up caching - how to clean up the caches?\n\n          sprite.tintedTexture = _CanvasTinter2.default.getTintedTexture(sprite, sprite.tint);\n        }\n\n        renderer.context.drawImage(sprite.tintedTexture, 0, 0, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);\n      } else {\n        renderer.context.drawImage(texture.baseTexture.source, texture._frame.x * resolution, texture._frame.y * resolution, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);\n      }\n    }\n  };\n  /**\n   * destroy the sprite object.\n   *\n   */\n\n\n  CanvasSpriteRenderer.prototype.destroy = function destroy() {\n    this.renderer = null;\n  };\n\n  return CanvasSpriteRenderer;\n}();\n\nexports.default = CanvasSpriteRenderer;\n\n_CanvasRenderer2.default.registerPlugin('sprite', CanvasSpriteRenderer);","map":{"version":3,"sources":["../../../../src/core/sprites/canvas/CanvasSpriteRenderer.js"],"names":["canvasRenderWorldTransform","CanvasSpriteRenderer","render","sprite","texture","renderer","width","height","wt","dx","dy","smoothingEnabled","resolution","destroy"],"mappings":"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","sourcesContent":["import CanvasRenderer from '../../renderers/canvas/CanvasRenderer';\nimport { SCALE_MODES } from '../../const';\nimport { Matrix, GroupD8 } from '../../math';\nimport CanvasTinter from './CanvasTinter';\n\nconst canvasRenderWorldTransform = new Matrix();\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's CanvasSpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/CanvasSpriteRenderer.java\n */\n\n/**\n * Renderer dedicated to drawing and batching sprites.\n *\n * @class\n * @private\n * @memberof PIXI\n */\nexport default class CanvasSpriteRenderer\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer -The renderer sprite this batch works for.\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * Renders the sprite object.\n     *\n     * @param {PIXI.Sprite} sprite - the sprite to render when using this spritebatch\n     */\n    render(sprite)\n    {\n        const texture = sprite._texture;\n        const renderer = this.renderer;\n\n        const width = texture._frame.width;\n        const height = texture._frame.height;\n\n        let wt = sprite.transform.worldTransform;\n        let dx = 0;\n        let dy = 0;\n\n        if (texture.orig.width <= 0 || texture.orig.height <= 0 || !texture.baseTexture.source)\n        {\n            return;\n        }\n\n        renderer.setBlendMode(sprite.blendMode);\n\n        //  Ignore null sources\n        if (texture.valid)\n        {\n            renderer.context.globalAlpha = sprite.worldAlpha;\n\n            // If smoothingEnabled is supported and we need to change the smoothing property for sprite texture\n            const smoothingEnabled = texture.baseTexture.scaleMode === SCALE_MODES.LINEAR;\n\n            if (renderer.smoothProperty && renderer.context[renderer.smoothProperty] !== smoothingEnabled)\n            {\n                renderer.context[renderer.smoothProperty] = smoothingEnabled;\n            }\n\n            if (texture.trim)\n            {\n                dx = (texture.trim.width / 2) + texture.trim.x - (sprite.anchor.x * texture.orig.width);\n                dy = (texture.trim.height / 2) + texture.trim.y - (sprite.anchor.y * texture.orig.height);\n            }\n            else\n            {\n                dx = (0.5 - sprite.anchor.x) * texture.orig.width;\n                dy = (0.5 - sprite.anchor.y) * texture.orig.height;\n            }\n\n            if (texture.rotate)\n            {\n                wt.copy(canvasRenderWorldTransform);\n                wt = canvasRenderWorldTransform;\n                GroupD8.matrixAppendRotationInv(wt, texture.rotate, dx, dy);\n                // the anchor has already been applied above, so lets set it to zero\n                dx = 0;\n                dy = 0;\n            }\n\n            dx -= width / 2;\n            dy -= height / 2;\n\n            // Allow for pixel rounding\n            if (renderer.roundPixels)\n            {\n                renderer.context.setTransform(\n                    wt.a,\n                    wt.b,\n                    wt.c,\n                    wt.d,\n                    (wt.tx * renderer.resolution) | 0,\n                    (wt.ty * renderer.resolution) | 0\n                );\n\n                dx = dx | 0;\n                dy = dy | 0;\n            }\n            else\n            {\n                renderer.context.setTransform(\n                    wt.a,\n                    wt.b,\n                    wt.c,\n                    wt.d,\n                    wt.tx * renderer.resolution,\n                    wt.ty * renderer.resolution\n                );\n            }\n\n            const resolution = texture.baseTexture.resolution;\n\n            if (sprite.tint !== 0xFFFFFF)\n            {\n                if (sprite.cachedTint !== sprite.tint || sprite.tintedTexture.tintId !== sprite._texture._updateID)\n                {\n                    sprite.cachedTint = sprite.tint;\n\n                    // TODO clean up caching - how to clean up the caches?\n                    sprite.tintedTexture = CanvasTinter.getTintedTexture(sprite, sprite.tint);\n                }\n\n                renderer.context.drawImage(\n                    sprite.tintedTexture,\n                    0,\n                    0,\n                    width * resolution,\n                    height * resolution,\n                    dx * renderer.resolution,\n                    dy * renderer.resolution,\n                    width * renderer.resolution,\n                    height * renderer.resolution\n                );\n            }\n            else\n            {\n                renderer.context.drawImage(\n                    texture.baseTexture.source,\n                    texture._frame.x * resolution,\n                    texture._frame.y * resolution,\n                    width * resolution,\n                    height * resolution,\n                    dx * renderer.resolution,\n                    dy * renderer.resolution,\n                    width * renderer.resolution,\n                    height * renderer.resolution\n                );\n            }\n        }\n    }\n\n    /**\n     * destroy the sprite object.\n     *\n     */\n    destroy()\n    {\n        this.renderer = null;\n    }\n}\n\nCanvasRenderer.registerPlugin('sprite', CanvasSpriteRenderer);\n"]},"metadata":{},"sourceType":"script"}