{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.eachSeries = eachSeries;\nexports.queue = queue;\n/**\n * Smaller version of the async library constructs.\n *\n * @namespace async\n */\n\n/**\n * Noop function\n *\n * @ignore\n * @function\n * @memberof async\n */\n\nfunction _noop() {}\n/* empty */\n\n/**\n * Iterates an array in series.\n *\n * @memberof async\n * @param {Array.<*>} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n */\n\n\nfunction eachSeries(array, iterator, callback, deferNext) {\n  var i = 0;\n  var len = array.length;\n\n  (function next(err) {\n    if (err || i === len) {\n      if (callback) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    if (deferNext) {\n      setTimeout(function () {\n        iterator(array[i++], next);\n      }, 1);\n    } else {\n      iterator(array[i++], next);\n    }\n  })();\n}\n/**\n * Ensures a function is only called once.\n *\n * @ignore\n * @memberof async\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\n\n\nfunction onlyOnce(fn) {\n  return function onceWrapper() {\n    if (fn === null) {\n      throw new Error('Callback was already called.');\n    }\n\n    var callFn = fn;\n    fn = null;\n    callFn.apply(this, arguments);\n  };\n}\n/**\n * Async queue implementation,\n *\n * @memberof async\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\n\n\nfunction queue(worker, concurrency) {\n  if (concurrency == null) {\n    // eslint-disable-line no-eq-null,eqeqeq\n    concurrency = 1;\n  } else if (concurrency === 0) {\n    throw new Error('Concurrency must not be zero');\n  }\n\n  var workers = 0;\n  var q = {\n    _tasks: [],\n    concurrency: concurrency,\n    saturated: _noop,\n    unsaturated: _noop,\n    buffer: concurrency / 4,\n    empty: _noop,\n    drain: _noop,\n    error: _noop,\n    started: false,\n    paused: false,\n    push: function push(data, callback) {\n      _insert(data, false, callback);\n    },\n    kill: function kill() {\n      workers = 0;\n      q.drain = _noop;\n      q.started = false;\n      q._tasks = [];\n    },\n    unshift: function unshift(data, callback) {\n      _insert(data, true, callback);\n    },\n    process: function process() {\n      while (!q.paused && workers < q.concurrency && q._tasks.length) {\n        var task = q._tasks.shift();\n\n        if (q._tasks.length === 0) {\n          q.empty();\n        }\n\n        workers += 1;\n\n        if (workers === q.concurrency) {\n          q.saturated();\n        }\n\n        worker(task.data, onlyOnce(_next(task)));\n      }\n    },\n    length: function length() {\n      return q._tasks.length;\n    },\n    running: function running() {\n      return workers;\n    },\n    idle: function idle() {\n      return q._tasks.length + workers === 0;\n    },\n    pause: function pause() {\n      if (q.paused === true) {\n        return;\n      }\n\n      q.paused = true;\n    },\n    resume: function resume() {\n      if (q.paused === false) {\n        return;\n      }\n\n      q.paused = false; // Need to call q.process once per concurrent\n      // worker to preserve full concurrency after pause\n\n      for (var w = 1; w <= q.concurrency; w++) {\n        q.process();\n      }\n    }\n  };\n\n  function _insert(data, insertAtFront, callback) {\n    if (callback != null && typeof callback !== 'function') {\n      // eslint-disable-line no-eq-null,eqeqeq\n      throw new Error('task callback must be a function');\n    }\n\n    q.started = true;\n\n    if (data == null && q.idle()) {\n      // eslint-disable-line no-eq-null,eqeqeq\n      // call drain immediately if there are no tasks\n      setTimeout(function () {\n        return q.drain();\n      }, 1);\n      return;\n    }\n\n    var item = {\n      data: data,\n      callback: typeof callback === 'function' ? callback : _noop\n    };\n\n    if (insertAtFront) {\n      q._tasks.unshift(item);\n    } else {\n      q._tasks.push(item);\n    }\n\n    setTimeout(function () {\n      return q.process();\n    }, 1);\n  }\n\n  function _next(task) {\n    return function next() {\n      workers -= 1;\n      task.callback.apply(task, arguments);\n\n      if (arguments[0] != null) {\n        // eslint-disable-line no-eq-null,eqeqeq\n        q.error(arguments[0], task.data);\n      }\n\n      if (workers <= q.concurrency - q.buffer) {\n        q.unsaturated();\n      }\n\n      if (q.idle()) {\n        q.drain();\n      }\n\n      q.process();\n    };\n  }\n\n  return q;\n}","map":{"version":3,"sources":["../src/async.js"],"names":["eachSeries","i","len","array","err","callback","setTimeout","iterator","fn","callFn","queue","concurrency","workers","q","_tasks","saturated","unsaturated","buffer","empty","drain","error","started","paused","push","_insert","kill","unshift","process","task","worker","onlyOnce","_next","length","running","idle","pause","resume","w","data","item","_noop","arguments"],"mappings":"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","sourcesContent":["/**\n * Smaller version of the async library constructs.\n *\n * @namespace async\n */\n\n/**\n * Noop function\n *\n * @ignore\n * @function\n * @memberof async\n */\nfunction _noop() { /* empty */ }\n\n/**\n * Iterates an array in series.\n *\n * @memberof async\n * @param {Array.<*>} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n * @param {boolean} [deferNext=false] - Break synchronous each loop by calling next with a setTimeout of 1.\n */\nexport function eachSeries(array, iterator, callback, deferNext) {\n    let i = 0;\n    const len = array.length;\n\n    (function next(err) {\n        if (err || i === len) {\n            if (callback) {\n                callback(err);\n            }\n\n            return;\n        }\n\n        if (deferNext) {\n            setTimeout(() => {\n                iterator(array[i++], next);\n            }, 1);\n        }\n        else {\n            iterator(array[i++], next);\n        }\n    })();\n}\n\n/**\n * Ensures a function is only called once.\n *\n * @ignore\n * @memberof async\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\nfunction onlyOnce(fn) {\n    return function onceWrapper() {\n        if (fn === null) {\n            throw new Error('Callback was already called.');\n        }\n\n        const callFn = fn;\n\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\n/**\n * Async queue implementation,\n *\n * @memberof async\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\nexport function queue(worker, concurrency) {\n    if (concurrency == null) { // eslint-disable-line no-eq-null,eqeqeq\n        concurrency = 1;\n    }\n    else if (concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    let workers = 0;\n    const q = {\n        _tasks: [],\n        concurrency,\n        saturated: _noop,\n        unsaturated: _noop,\n        buffer: concurrency / 4,\n        empty: _noop,\n        drain: _noop,\n        error: _noop,\n        started: false,\n        paused: false,\n        push(data, callback) {\n            _insert(data, false, callback);\n        },\n        kill() {\n            workers = 0;\n            q.drain = _noop;\n            q.started = false;\n            q._tasks = [];\n        },\n        unshift(data, callback) {\n            _insert(data, true, callback);\n        },\n        process() {\n            while (!q.paused && workers < q.concurrency && q._tasks.length) {\n                const task = q._tasks.shift();\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n\n                workers += 1;\n\n                if (workers === q.concurrency) {\n                    q.saturated();\n                }\n\n                worker(task.data, onlyOnce(_next(task)));\n            }\n        },\n        length() {\n            return q._tasks.length;\n        },\n        running() {\n            return workers;\n        },\n        idle() {\n            return q._tasks.length + workers === 0;\n        },\n        pause() {\n            if (q.paused === true) {\n                return;\n            }\n\n            q.paused = true;\n        },\n        resume() {\n            if (q.paused === false) {\n                return;\n            }\n\n            q.paused = false;\n\n            // Need to call q.process once per concurrent\n            // worker to preserve full concurrency after pause\n            for (let w = 1; w <= q.concurrency; w++) {\n                q.process();\n            }\n        },\n    };\n\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') { // eslint-disable-line no-eq-null,eqeqeq\n            throw new Error('task callback must be a function');\n        }\n\n        q.started = true;\n\n        if (data == null && q.idle()) { // eslint-disable-line no-eq-null,eqeqeq\n            // call drain immediately if there are no tasks\n            setTimeout(() => q.drain(), 1);\n\n            return;\n        }\n\n        const item = {\n            data,\n            callback: typeof callback === 'function' ? callback : _noop,\n        };\n\n        if (insertAtFront) {\n            q._tasks.unshift(item);\n        }\n        else {\n            q._tasks.push(item);\n        }\n\n        setTimeout(() => q.process(), 1);\n    }\n\n    function _next(task) {\n        return function next() {\n            workers -= 1;\n\n            task.callback.apply(task, arguments);\n\n            if (arguments[0] != null) { // eslint-disable-line no-eq-null,eqeqeq\n                q.error(arguments[0], task.data);\n            }\n\n            if (workers <= (q.concurrency - q.buffer)) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n\n            q.process();\n        };\n    }\n\n    return q;\n}\n"]},"metadata":{},"sourceType":"script"}