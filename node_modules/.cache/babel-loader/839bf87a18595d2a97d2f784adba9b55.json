{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.default = buildRoundedRectangle;\n\nvar _earcut = require('earcut');\n\nvar _earcut2 = _interopRequireDefault(_earcut);\n\nvar _buildLine = require('./buildLine');\n\nvar _buildLine2 = _interopRequireDefault(_buildLine);\n\nvar _utils = require('../../../utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the webGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines\n */\n\n\nfunction buildRoundedRectangle(graphicsData, webGLData, webGLDataNativeLines) {\n  var rrectData = graphicsData.shape;\n  var x = rrectData.x;\n  var y = rrectData.y;\n  var width = rrectData.width;\n  var height = rrectData.height;\n  var radius = rrectData.radius;\n  var recPoints = [];\n  recPoints.push(x + radius, y);\n  quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, recPoints);\n  quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, recPoints);\n  quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, recPoints);\n  quadraticBezierCurve(x, y + radius, x, y, x + radius + 0.0000000001, y, recPoints); // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.\n  // TODO - fix this properly, this is not very elegant.. but it works for now.\n\n  if (graphicsData.fill) {\n    var color = (0, _utils.hex2rgb)(graphicsData.fillColor);\n    var alpha = graphicsData.fillAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n    var vecPos = verts.length / 6;\n    var triangles = (0, _earcut2.default)(recPoints, null, 2);\n\n    for (var i = 0, j = triangles.length; i < j; i += 3) {\n      indices.push(triangles[i] + vecPos);\n      indices.push(triangles[i] + vecPos);\n      indices.push(triangles[i + 1] + vecPos);\n      indices.push(triangles[i + 2] + vecPos);\n      indices.push(triangles[i + 2] + vecPos);\n    }\n\n    for (var _i = 0, _j = recPoints.length; _i < _j; _i++) {\n      verts.push(recPoints[_i], recPoints[++_i], r, g, b, alpha);\n    }\n  }\n\n  if (graphicsData.lineWidth) {\n    var tempPoints = graphicsData.points;\n    graphicsData.points = recPoints;\n    (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);\n    graphicsData.points = tempPoints;\n  }\n}\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\n\n\nfunction getPt(n1, n2, perc) {\n  var diff = n2 - n1;\n  return n1 + diff * perc;\n}\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\n\n\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY) {\n  var out = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n  var n = 20;\n  var points = out;\n  var xa = 0;\n  var ya = 0;\n  var xb = 0;\n  var yb = 0;\n  var x = 0;\n  var y = 0;\n\n  for (var i = 0, j = 0; i <= n; ++i) {\n    j = i / n; // The Green Line\n\n    xa = getPt(fromX, cpX, j);\n    ya = getPt(fromY, cpY, j);\n    xb = getPt(cpX, toX, j);\n    yb = getPt(cpY, toY, j); // The Black Dot\n\n    x = getPt(xa, xb, j);\n    y = getPt(ya, yb, j);\n    points.push(x, y);\n  }\n\n  return points;\n}","map":{"version":3,"sources":["../../../../../src/core/graphics/webgl/utils/buildRoundedRectangle.js"],"names":["buildRoundedRectangle","rrectData","graphicsData","x","y","width","height","radius","recPoints","quadraticBezierCurve","color","alpha","r","g","b","verts","webGLData","indices","vecPos","triangles","i","j","tempPoints","diff","n2","n1","out","n","points","xa","ya","xb","yb","getPt"],"mappings":"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","sourcesContent":["import earcut from 'earcut';\nimport buildLine from './buildLine';\nimport { hex2rgb } from '../../../utils';\n\n/**\n * Builds a rounded rectangle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the webGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines\n */\nexport default function buildRoundedRectangle(graphicsData, webGLData, webGLDataNativeLines)\n{\n    const rrectData = graphicsData.shape;\n    const x = rrectData.x;\n    const y = rrectData.y;\n    const width = rrectData.width;\n    const height = rrectData.height;\n\n    const radius = rrectData.radius;\n\n    const recPoints = [];\n\n    recPoints.push(x + radius, y);\n    quadraticBezierCurve(x + width - radius, y, x + width, y, x + width, y + radius, recPoints);\n    quadraticBezierCurve(x + width, y + height - radius, x + width, y + height, x + width - radius, y + height, recPoints);\n    quadraticBezierCurve(x + radius, y + height, x, y + height, x, y + height - radius, recPoints);\n    quadraticBezierCurve(x, y + radius, x, y, x + radius + 0.0000000001, y, recPoints);\n\n    // this tiny number deals with the issue that occurs when points overlap and earcut fails to triangulate the item.\n    // TODO - fix this properly, this is not very elegant.. but it works for now.\n\n    if (graphicsData.fill)\n    {\n        const color = hex2rgb(graphicsData.fillColor);\n        const alpha = graphicsData.fillAlpha;\n\n        const r = color[0] * alpha;\n        const g = color[1] * alpha;\n        const b = color[2] * alpha;\n\n        const verts = webGLData.points;\n        const indices = webGLData.indices;\n\n        const vecPos = verts.length / 6;\n\n        const triangles = earcut(recPoints, null, 2);\n\n        for (let i = 0, j = triangles.length; i < j; i += 3)\n        {\n            indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i] + vecPos);\n            indices.push(triangles[i + 1] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n            indices.push(triangles[i + 2] + vecPos);\n        }\n\n        for (let i = 0, j = recPoints.length; i < j; i++)\n        {\n            verts.push(recPoints[i], recPoints[++i], r, g, b, alpha);\n        }\n    }\n\n    if (graphicsData.lineWidth)\n    {\n        const tempPoints = graphicsData.points;\n\n        graphicsData.points = recPoints;\n\n        buildLine(graphicsData, webGLData, webGLDataNativeLines);\n\n        graphicsData.points = tempPoints;\n    }\n}\n\n/**\n * Calculate a single point for a quadratic bezier curve.\n * Utility function used by quadraticBezierCurve.\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} n1 - first number\n * @param {number} n2 - second number\n * @param {number} perc - percentage\n * @return {number} the result\n *\n */\nfunction getPt(n1, n2, perc)\n{\n    const diff = n2 - n1;\n\n    return n1 + (diff * perc);\n}\n\n/**\n * Calculate the points for a quadratic bezier curve. (helper function..)\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} fromX - Origin point x\n * @param {number} fromY - Origin point x\n * @param {number} cpX - Control point x\n * @param {number} cpY - Control point y\n * @param {number} toX - Destination point x\n * @param {number} toY - Destination point y\n * @param {number[]} [out=[]] - The output array to add points into. If not passed, a new array is created.\n * @return {number[]} an array of points\n */\nfunction quadraticBezierCurve(fromX, fromY, cpX, cpY, toX, toY, out = [])\n{\n    const n = 20;\n    const points = out;\n\n    let xa = 0;\n    let ya = 0;\n    let xb = 0;\n    let yb = 0;\n    let x = 0;\n    let y = 0;\n\n    for (let i = 0, j = 0; i <= n; ++i)\n    {\n        j = i / n;\n\n        // The Green Line\n        xa = getPt(fromX, cpX, j);\n        ya = getPt(fromY, cpY, j);\n        xb = getPt(cpX, toX, j);\n        yb = getPt(cpY, toY, j);\n\n        // The Black Dot\n        x = getPt(xa, xb, j);\n        y = getPt(ya, yb, j);\n\n        points.push(x, y);\n    }\n\n    return points;\n}\n"]},"metadata":{},"sourceType":"script"}