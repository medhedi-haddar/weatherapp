{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _Filter2 = require('../Filter');\n\nvar _Filter3 = _interopRequireDefault(_Filter2);\n\nvar _math = require('../../../../math');\n\nvar _path = require('path');\n\nvar _TextureMatrix = require('../../../../textures/TextureMatrix');\n\nvar _TextureMatrix2 = _interopRequireDefault(_TextureMatrix);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * The SpriteMaskFilter class\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI\n */\n\n\nvar SpriteMaskFilter = function (_Filter) {\n  _inherits(SpriteMaskFilter, _Filter);\n  /**\n   * @param {PIXI.Sprite} sprite - the target sprite\n   */\n\n\n  function SpriteMaskFilter(sprite) {\n    _classCallCheck(this, SpriteMaskFilter);\n\n    var maskMatrix = new _math.Matrix();\n\n    var _this = _possibleConstructorReturn(this, _Filter.call(this, 'attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 otherMatrix;\\n\\nvarying vec2 vMaskCoord;\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = aTextureCoord;\\n    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;\\n}\\n', 'varying vec2 vMaskCoord;\\nvarying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform sampler2D mask;\\nuniform float alpha;\\nuniform vec4 maskClamp;\\n\\nvoid main(void)\\n{\\n    float clip = step(3.5,\\n        step(maskClamp.x, vMaskCoord.x) +\\n        step(maskClamp.y, vMaskCoord.y) +\\n        step(vMaskCoord.x, maskClamp.z) +\\n        step(vMaskCoord.y, maskClamp.w));\\n\\n    vec4 original = texture2D(uSampler, vTextureCoord);\\n    vec4 masky = texture2D(mask, vMaskCoord);\\n\\n    original *= (masky.r * masky.a * alpha * clip);\\n\\n    gl_FragColor = original;\\n}\\n'));\n\n    sprite.renderable = false;\n    _this.maskSprite = sprite;\n    _this.maskMatrix = maskMatrix;\n    return _this;\n  }\n  /**\n   * Applies the filter\n   *\n   * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from\n   * @param {PIXI.RenderTarget} input - The input render target.\n   * @param {PIXI.RenderTarget} output - The target to output to.\n   * @param {boolean} clear - Should the output be cleared before rendering to it\n   */\n\n\n  SpriteMaskFilter.prototype.apply = function apply(filterManager, input, output, clear) {\n    var maskSprite = this.maskSprite;\n    var tex = this.maskSprite.texture;\n\n    if (!tex.valid) {\n      return;\n    }\n\n    if (!tex.transform) {\n      // margin = 0.0, let it bleed a bit, shader code becomes easier\n      // assuming that atlas textures were made with 1-pixel padding\n      tex.transform = new _TextureMatrix2.default(tex, 0.0);\n    }\n\n    tex.transform.update();\n    this.uniforms.mask = tex;\n    this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite).prepend(tex.transform.mapCoord);\n    this.uniforms.alpha = maskSprite.worldAlpha;\n    this.uniforms.maskClamp = tex.transform.uClampFrame;\n    filterManager.applyFilter(this, input, output, clear);\n  };\n\n  return SpriteMaskFilter;\n}(_Filter3.default);\n\nexports.default = SpriteMaskFilter;","map":{"version":3,"sources":["../../../../../../src/core/renderers/webgl/filters/spriteMask/SpriteMaskFilter.js"],"names":["SpriteMaskFilter","maskMatrix","sprite","apply","filterManager","input","output","clear","maskSprite","tex"],"mappings":";;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AAEA,IAAA,KAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AACA,IAAA,cAAA,GAAA,OAAA,CAAA,oCAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;IAOqBA,gB;;AAEjB;;;;;AAGA,WAAA,gBAAA,CAAA,MAAA,EACA;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,gBAAA,CAAA;;AACI,QAAMC,UAAAA,GAAa,IAAA,KAAA,CAAnB,MAAmB,EAAnB;;AADJ,QAAA,KAAA,GAAA,0BAAA,CAAA,IAAA,EAGI,OAAA,CAAA,IAAA,CAAA,IAAA,EAAA,iZAAA,EAHJ,kkBAGI,CAHJ,CAAA;;AAQIC,IAAAA,MAAAA,CAAAA,UAAAA,GAAAA,KAAAA;AAEA,IAAA,KAAA,CAAA,UAAA,GAAA,MAAA;AACA,IAAA,KAAA,CAAA,UAAA,GAAA,UAAA;AAXJ,WAAA,KAAA;AAYC;AAED;;;;;;;;;;6BAQAC,K,kBAAMC,a,EAAeC,K,EAAOC,M,EAAQC,K,EACpC;AACI,QAAMC,UAAAA,GAAa,KAAnB,UAAA;AACA,QAAMC,GAAAA,GAAM,KAAA,UAAA,CAAZ,OAAA;;AAEA,QAAI,CAACA,GAAAA,CAAL,KAAA,EACA;AACI;AACH;;AACD,QAAI,CAACA,GAAAA,CAAL,SAAA,EACA;AACI;AACA;AACAA,MAAAA,GAAAA,CAAAA,SAAAA,GAAgB,IAAA,eAAA,CAAA,OAAA,CAAA,GAAA,EAAhBA,GAAgB,CAAhBA;AACH;;AACDA,IAAAA,GAAAA,CAAAA,SAAAA,CAAAA,MAAAA;AAEA,SAAA,QAAA,CAAA,IAAA,GAAA,GAAA;AACA,SAAA,QAAA,CAAA,WAAA,GAA4BL,aAAAA,CAAAA,qBAAAA,CAAoC,KAApCA,UAAAA,EAAAA,UAAAA,EAAAA,OAAAA,CACfK,GAAAA,CAAAA,SAAAA,CADb,QAA4BL,CAA5B;AAEA,SAAA,QAAA,CAAA,KAAA,GAAsBI,UAAAA,CAAtB,UAAA;AACA,SAAA,QAAA,CAAA,SAAA,GAA0BC,GAAAA,CAAAA,SAAAA,CAA1B,WAAA;AAEAL,IAAAA,aAAAA,CAAAA,WAAAA,CAAAA,IAAAA,EAAAA,KAAAA,EAAAA,MAAAA,EAAAA,KAAAA;;;;;;kBAnDaJ,gB","sourcesContent":["import Filter from '../Filter';\nimport { Matrix } from '../../../../math';\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\nimport { default as TextureMatrix } from '../../../../textures/TextureMatrix';\n\n/**\n * The SpriteMaskFilter class\n *\n * @class\n * @extends PIXI.Filter\n * @memberof PIXI\n */\nexport default class SpriteMaskFilter extends Filter\n{\n    /**\n     * @param {PIXI.Sprite} sprite - the target sprite\n     */\n    constructor(sprite)\n    {\n        const maskMatrix = new Matrix();\n\n        super(\n            readFileSync(join(__dirname, './spriteMaskFilter.vert'), 'utf8'),\n            readFileSync(join(__dirname, './spriteMaskFilter.frag'), 'utf8')\n        );\n\n        sprite.renderable = false;\n\n        this.maskSprite = sprite;\n        this.maskMatrix = maskMatrix;\n    }\n\n    /**\n     * Applies the filter\n     *\n     * @param {PIXI.FilterManager} filterManager - The renderer to retrieve the filter from\n     * @param {PIXI.RenderTarget} input - The input render target.\n     * @param {PIXI.RenderTarget} output - The target to output to.\n     * @param {boolean} clear - Should the output be cleared before rendering to it\n     */\n    apply(filterManager, input, output, clear)\n    {\n        const maskSprite = this.maskSprite;\n        const tex = this.maskSprite.texture;\n\n        if (!tex.valid)\n        {\n            return;\n        }\n        if (!tex.transform)\n        {\n            // margin = 0.0, let it bleed a bit, shader code becomes easier\n            // assuming that atlas textures were made with 1-pixel padding\n            tex.transform = new TextureMatrix(tex, 0.0);\n        }\n        tex.transform.update();\n\n        this.uniforms.mask = tex;\n        this.uniforms.otherMatrix = filterManager.calculateSpriteMatrix(this.maskMatrix, maskSprite)\n            .prepend(tex.transform.mapCoord);\n        this.uniforms.alpha = maskSprite.worldAlpha;\n        this.uniforms.maskClamp = tex.transform.uClampFrame;\n\n        filterManager.applyFilter(this, input, output, clear);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}