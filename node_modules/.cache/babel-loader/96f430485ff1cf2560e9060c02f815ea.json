{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _core = require('../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _CountLimiter = require('./limiters/CountLimiter');\n\nvar _CountLimiter2 = _interopRequireDefault(_CountLimiter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar SharedTicker = core.ticker.shared;\n/**\n * Default number of uploads per frame using prepare plugin.\n *\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\n\ncore.settings.UPLOADS_PER_FRAME = 4;\n/**\n * The prepare manager provides functionality to upload content to the GPU. BasePrepare handles\n * basic queuing functionality and is extended by {@link PIXI.prepare.WebGLPrepare} and {@link PIXI.prepare.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n *\n * @example\n * // Create a sprite\n * const sprite = new PIXI.Sprite.fromImage('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *\n *     //Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n *\n * })\n *\n * @abstract\n * @class\n * @memberof PIXI.prepare\n */\n\nvar BasePrepare = function () {\n  /**\n   * @param {PIXI.SystemRenderer} renderer - A reference to the current renderer\n   */\n  function BasePrepare(renderer) {\n    var _this = this;\n\n    _classCallCheck(this, BasePrepare);\n    /**\n     * The limiter to be used to control how quickly items are prepared.\n     * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}\n     */\n\n\n    this.limiter = new _CountLimiter2.default(core.settings.UPLOADS_PER_FRAME);\n    /**\n     * Reference to the renderer.\n     * @type {PIXI.SystemRenderer}\n     * @protected\n     */\n\n    this.renderer = renderer;\n    /**\n     * The only real difference between CanvasPrepare and WebGLPrepare is what they pass\n     * to upload hooks. That different parameter is stored here.\n     * @type {PIXI.prepare.CanvasPrepare|PIXI.WebGLRenderer}\n     * @protected\n     */\n\n    this.uploadHookHelper = null;\n    /**\n     * Collection of items to uploads at once.\n     * @type {Array<*>}\n     * @private\n     */\n\n    this.queue = [];\n    /**\n     * Collection of additional hooks for finding assets.\n     * @type {Array<Function>}\n     * @private\n     */\n\n    this.addHooks = [];\n    /**\n     * Collection of additional hooks for processing assets.\n     * @type {Array<Function>}\n     * @private\n     */\n\n    this.uploadHooks = [];\n    /**\n     * Callback to call after completed.\n     * @type {Array<Function>}\n     * @private\n     */\n\n    this.completes = [];\n    /**\n     * If prepare is ticking (running).\n     * @type {boolean}\n     * @private\n     */\n\n    this.ticking = false;\n    /**\n     * 'bound' call for prepareItems().\n     * @type {Function}\n     * @private\n     */\n\n    this.delayedTick = function () {\n      // unlikely, but in case we were destroyed between tick() and delayedTick()\n      if (!_this.queue) {\n        return;\n      }\n\n      _this.prepareItems();\n    }; // hooks to find the correct texture\n\n\n    this.registerFindHook(findText);\n    this.registerFindHook(findTextStyle);\n    this.registerFindHook(findMultipleBaseTextures);\n    this.registerFindHook(findBaseTexture);\n    this.registerFindHook(findTexture); // upload hooks\n\n    this.registerUploadHook(drawText);\n    this.registerUploadHook(calculateTextStyle);\n  }\n  /**\n   * Upload all the textures and graphics to the GPU.\n   *\n   * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -\n   *        Either the container or display object to search for items to upload, the items to upload themselves,\n   *        or the callback function, if items have been added using `prepare.add`.\n   * @param {Function} [done] - Optional callback when all queued uploads have completed\n   */\n\n\n  BasePrepare.prototype.upload = function upload(item, done) {\n    if (typeof item === 'function') {\n      done = item;\n      item = null;\n    } // If a display object, search for items\n    // that we could upload\n\n\n    if (item) {\n      this.add(item);\n    } // Get the items for upload from the display\n\n\n    if (this.queue.length) {\n      if (done) {\n        this.completes.push(done);\n      }\n\n      if (!this.ticking) {\n        this.ticking = true;\n        SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);\n      }\n    } else if (done) {\n      done();\n    }\n  };\n  /**\n   * Handle tick update\n   *\n   * @private\n   */\n\n\n  BasePrepare.prototype.tick = function tick() {\n    setTimeout(this.delayedTick, 0);\n  };\n  /**\n   * Actually prepare items. This is handled outside of the tick because it will take a while\n   * and we do NOT want to block the current animation frame from rendering.\n   *\n   * @private\n   */\n\n\n  BasePrepare.prototype.prepareItems = function prepareItems() {\n    this.limiter.beginFrame(); // Upload the graphics\n\n    while (this.queue.length && this.limiter.allowedToUpload()) {\n      var item = this.queue[0];\n      var uploaded = false;\n\n      if (item && !item._destroyed) {\n        for (var i = 0, len = this.uploadHooks.length; i < len; i++) {\n          if (this.uploadHooks[i](this.uploadHookHelper, item)) {\n            this.queue.shift();\n            uploaded = true;\n            break;\n          }\n        }\n      }\n\n      if (!uploaded) {\n        this.queue.shift();\n      }\n    } // We're finished\n\n\n    if (!this.queue.length) {\n      this.ticking = false;\n      var completes = this.completes.slice(0);\n      this.completes.length = 0;\n\n      for (var _i = 0, _len = completes.length; _i < _len; _i++) {\n        completes[_i]();\n      }\n    } else {\n      // if we are not finished, on the next rAF do this again\n      SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);\n    }\n  };\n  /**\n   * Adds hooks for finding items.\n   *\n   * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n   *          function must return `true` if it was able to add item to the queue.\n   * @return {PIXI.BasePrepare} Instance of plugin for chaining.\n   */\n\n\n  BasePrepare.prototype.registerFindHook = function registerFindHook(addHook) {\n    if (addHook) {\n      this.addHooks.push(addHook);\n    }\n\n    return this;\n  };\n  /**\n   * Adds hooks for uploading items.\n   *\n   * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n   *          function must return `true` if it was able to handle upload of item.\n   * @return {PIXI.BasePrepare} Instance of plugin for chaining.\n   */\n\n\n  BasePrepare.prototype.registerUploadHook = function registerUploadHook(uploadHook) {\n    if (uploadHook) {\n      this.uploadHooks.push(uploadHook);\n    }\n\n    return this;\n  };\n  /**\n   * Manually add an item to the uploading queue.\n   *\n   * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n   *        add to the queue\n   * @return {PIXI.CanvasPrepare} Instance of plugin for chaining.\n   */\n\n\n  BasePrepare.prototype.add = function add(item) {\n    // Add additional hooks for finding elements on special\n    // types of objects that\n    for (var i = 0, len = this.addHooks.length; i < len; i++) {\n      if (this.addHooks[i](item, this.queue)) {\n        break;\n      }\n    } // Get childen recursively\n\n\n    if (item instanceof core.Container) {\n      for (var _i2 = item.children.length - 1; _i2 >= 0; _i2--) {\n        this.add(item.children[_i2]);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Destroys the plugin, don't use after this.\n   *\n   */\n\n\n  BasePrepare.prototype.destroy = function destroy() {\n    if (this.ticking) {\n      SharedTicker.remove(this.tick, this);\n    }\n\n    this.ticking = false;\n    this.addHooks = null;\n    this.uploadHooks = null;\n    this.renderer = null;\n    this.completes = null;\n    this.queue = null;\n    this.limiter = null;\n    this.uploadHookHelper = null;\n  };\n\n  return BasePrepare;\n}();\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\n\n\nexports.default = BasePrepare;\n\nfunction findMultipleBaseTextures(item, queue) {\n  var result = false; // Objects with mutliple textures\n\n  if (item && item._textures && item._textures.length) {\n    for (var i = 0; i < item._textures.length; i++) {\n      if (item._textures[i] instanceof core.Texture) {\n        var baseTexture = item._textures[i].baseTexture;\n\n        if (queue.indexOf(baseTexture) === -1) {\n          queue.push(baseTexture);\n          result = true;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * Built-in hook to find BaseTextures from Sprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\n\n\nfunction findBaseTexture(item, queue) {\n  // Objects with textures, like Sprites/Text\n  if (item instanceof core.BaseTexture) {\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Built-in hook to find textures from objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\n\n\nfunction findTexture(item, queue) {\n  if (item._texture && item._texture instanceof core.Texture) {\n    var texture = item._texture.baseTexture;\n\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n *\n * @private\n * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\n\n\nfunction drawText(helper, item) {\n  if (item instanceof core.Text) {\n    // updating text will return early if it is not dirty\n    item.updateText(true);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n *\n * @private\n * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\n\n\nfunction calculateTextStyle(helper, item) {\n  if (item instanceof core.TextStyle) {\n    var font = item.toFontString();\n    core.TextMetrics.measureFont(font);\n    return true;\n  }\n\n  return false;\n}\n/**\n * Built-in hook to find Text objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Text object was found.\n */\n\n\nfunction findText(item, queue) {\n  if (item instanceof core.Text) {\n    // push the text style to prepare it - this can be really expensive\n    if (queue.indexOf(item.style) === -1) {\n      queue.push(item.style);\n    } // also push the text object so that we can render it (to canvas/texture) if needed\n\n\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    } // also push the Text's texture for upload to GPU\n\n\n    var texture = item._texture.baseTexture;\n\n    if (queue.indexOf(texture) === -1) {\n      queue.push(texture);\n    }\n\n    return true;\n  }\n\n  return false;\n}\n/**\n * Built-in hook to find TextStyle objects.\n *\n * @private\n * @param {PIXI.TextStyle} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.TextStyle object was found.\n */\n\n\nfunction findTextStyle(item, queue) {\n  if (item instanceof core.TextStyle) {\n    if (queue.indexOf(item) === -1) {\n      queue.push(item);\n    }\n\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["../../src/prepare/BasePrepare.js"],"names":["core","SharedTicker","BasePrepare","upload","item","done","tick","setTimeout","prepareItems","uploaded","i","len","completes","registerFindHook","addHook","registerUploadHook","uploadHook","add","destroy","result","baseTexture","queue","texture","font"],"mappings":"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","sourcesContent":["import * as core from '../core';\nimport CountLimiter from './limiters/CountLimiter';\nconst SharedTicker = core.ticker.shared;\n\n/**\n * Default number of uploads per frame using prepare plugin.\n *\n * @static\n * @memberof PIXI.settings\n * @name UPLOADS_PER_FRAME\n * @type {number}\n * @default 4\n */\ncore.settings.UPLOADS_PER_FRAME = 4;\n\n/**\n * The prepare manager provides functionality to upload content to the GPU. BasePrepare handles\n * basic queuing functionality and is extended by {@link PIXI.prepare.WebGLPrepare} and {@link PIXI.prepare.CanvasPrepare}\n * to provide preparation capabilities specific to their respective renderers.\n *\n * @example\n * // Create a sprite\n * const sprite = new PIXI.Sprite.fromImage('something.png');\n *\n * // Load object into GPU\n * app.renderer.plugins.prepare.upload(sprite, () => {\n *\n *     //Texture(s) has been uploaded to GPU\n *     app.stage.addChild(sprite);\n *\n * })\n *\n * @abstract\n * @class\n * @memberof PIXI.prepare\n */\nexport default class BasePrepare\n{\n    /**\n     * @param {PIXI.SystemRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        /**\n         * The limiter to be used to control how quickly items are prepared.\n         * @type {PIXI.prepare.CountLimiter|PIXI.prepare.TimeLimiter}\n         */\n        this.limiter = new CountLimiter(core.settings.UPLOADS_PER_FRAME);\n\n        /**\n         * Reference to the renderer.\n         * @type {PIXI.SystemRenderer}\n         * @protected\n         */\n        this.renderer = renderer;\n\n        /**\n         * The only real difference between CanvasPrepare and WebGLPrepare is what they pass\n         * to upload hooks. That different parameter is stored here.\n         * @type {PIXI.prepare.CanvasPrepare|PIXI.WebGLRenderer}\n         * @protected\n         */\n        this.uploadHookHelper = null;\n\n        /**\n         * Collection of items to uploads at once.\n         * @type {Array<*>}\n         * @private\n         */\n        this.queue = [];\n\n        /**\n         * Collection of additional hooks for finding assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.addHooks = [];\n\n        /**\n         * Collection of additional hooks for processing assets.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.uploadHooks = [];\n\n        /**\n         * Callback to call after completed.\n         * @type {Array<Function>}\n         * @private\n         */\n        this.completes = [];\n\n        /**\n         * If prepare is ticking (running).\n         * @type {boolean}\n         * @private\n         */\n        this.ticking = false;\n\n        /**\n         * 'bound' call for prepareItems().\n         * @type {Function}\n         * @private\n         */\n        this.delayedTick = () =>\n        {\n            // unlikely, but in case we were destroyed between tick() and delayedTick()\n            if (!this.queue)\n            {\n                return;\n            }\n            this.prepareItems();\n        };\n\n        // hooks to find the correct texture\n        this.registerFindHook(findText);\n        this.registerFindHook(findTextStyle);\n        this.registerFindHook(findMultipleBaseTextures);\n        this.registerFindHook(findBaseTexture);\n        this.registerFindHook(findTexture);\n\n        // upload hooks\n        this.registerUploadHook(drawText);\n        this.registerUploadHook(calculateTextStyle);\n    }\n\n    /**\n     * Upload all the textures and graphics to the GPU.\n     *\n     * @param {Function|PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text} item -\n     *        Either the container or display object to search for items to upload, the items to upload themselves,\n     *        or the callback function, if items have been added using `prepare.add`.\n     * @param {Function} [done] - Optional callback when all queued uploads have completed\n     */\n    upload(item, done)\n    {\n        if (typeof item === 'function')\n        {\n            done = item;\n            item = null;\n        }\n\n        // If a display object, search for items\n        // that we could upload\n        if (item)\n        {\n            this.add(item);\n        }\n\n        // Get the items for upload from the display\n        if (this.queue.length)\n        {\n            if (done)\n            {\n                this.completes.push(done);\n            }\n\n            if (!this.ticking)\n            {\n                this.ticking = true;\n                SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);\n            }\n        }\n        else if (done)\n        {\n            done();\n        }\n    }\n\n    /**\n     * Handle tick update\n     *\n     * @private\n     */\n    tick()\n    {\n        setTimeout(this.delayedTick, 0);\n    }\n\n    /**\n     * Actually prepare items. This is handled outside of the tick because it will take a while\n     * and we do NOT want to block the current animation frame from rendering.\n     *\n     * @private\n     */\n    prepareItems()\n    {\n        this.limiter.beginFrame();\n        // Upload the graphics\n        while (this.queue.length && this.limiter.allowedToUpload())\n        {\n            const item = this.queue[0];\n            let uploaded = false;\n\n            if (item && !item._destroyed)\n            {\n                for (let i = 0, len = this.uploadHooks.length; i < len; i++)\n                {\n                    if (this.uploadHooks[i](this.uploadHookHelper, item))\n                    {\n                        this.queue.shift();\n                        uploaded = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!uploaded)\n            {\n                this.queue.shift();\n            }\n        }\n\n        // We're finished\n        if (!this.queue.length)\n        {\n            this.ticking = false;\n\n            const completes = this.completes.slice(0);\n\n            this.completes.length = 0;\n\n            for (let i = 0, len = completes.length; i < len; i++)\n            {\n                completes[i]();\n            }\n        }\n        else\n        {\n            // if we are not finished, on the next rAF do this again\n            SharedTicker.addOnce(this.tick, this, core.UPDATE_PRIORITY.UTILITY);\n        }\n    }\n\n    /**\n     * Adds hooks for finding items.\n     *\n     * @param {Function} addHook - Function call that takes two parameters: `item:*, queue:Array`\n     *          function must return `true` if it was able to add item to the queue.\n     * @return {PIXI.BasePrepare} Instance of plugin for chaining.\n     */\n    registerFindHook(addHook)\n    {\n        if (addHook)\n        {\n            this.addHooks.push(addHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds hooks for uploading items.\n     *\n     * @param {Function} uploadHook - Function call that takes two parameters: `prepare:CanvasPrepare, item:*` and\n     *          function must return `true` if it was able to handle upload of item.\n     * @return {PIXI.BasePrepare} Instance of plugin for chaining.\n     */\n    registerUploadHook(uploadHook)\n    {\n        if (uploadHook)\n        {\n            this.uploadHooks.push(uploadHook);\n        }\n\n        return this;\n    }\n\n    /**\n     * Manually add an item to the uploading queue.\n     *\n     * @param {PIXI.DisplayObject|PIXI.Container|PIXI.BaseTexture|PIXI.Texture|PIXI.Graphics|PIXI.Text|*} item - Object to\n     *        add to the queue\n     * @return {PIXI.CanvasPrepare} Instance of plugin for chaining.\n     */\n    add(item)\n    {\n        // Add additional hooks for finding elements on special\n        // types of objects that\n        for (let i = 0, len = this.addHooks.length; i < len; i++)\n        {\n            if (this.addHooks[i](item, this.queue))\n            {\n                break;\n            }\n        }\n\n        // Get childen recursively\n        if (item instanceof core.Container)\n        {\n            for (let i = item.children.length - 1; i >= 0; i--)\n            {\n                this.add(item.children[i]);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Destroys the plugin, don't use after this.\n     *\n     */\n    destroy()\n    {\n        if (this.ticking)\n        {\n            SharedTicker.remove(this.tick, this);\n        }\n        this.ticking = false;\n        this.addHooks = null;\n        this.uploadHooks = null;\n        this.renderer = null;\n        this.completes = null;\n        this.queue = null;\n        this.limiter = null;\n        this.uploadHookHelper = null;\n    }\n\n}\n\n/**\n * Built-in hook to find multiple textures from objects like AnimatedSprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findMultipleBaseTextures(item, queue)\n{\n    let result = false;\n\n    // Objects with mutliple textures\n    if (item && item._textures && item._textures.length)\n    {\n        for (let i = 0; i < item._textures.length; i++)\n        {\n            if (item._textures[i] instanceof core.Texture)\n            {\n                const baseTexture = item._textures[i].baseTexture;\n\n                if (queue.indexOf(baseTexture) === -1)\n                {\n                    queue.push(baseTexture);\n                    result = true;\n                }\n            }\n        }\n    }\n\n    return result;\n}\n\n/**\n * Built-in hook to find BaseTextures from Sprites.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findBaseTexture(item, queue)\n{\n    // Objects with textures, like Sprites/Text\n    if (item instanceof core.BaseTexture)\n    {\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find textures from objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Texture object was found.\n */\nfunction findTexture(item, queue)\n{\n    if (item._texture && item._texture instanceof core.Texture)\n    {\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to draw PIXI.Text to its texture.\n *\n * @private\n * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction drawText(helper, item)\n{\n    if (item instanceof core.Text)\n    {\n        // updating text will return early if it is not dirty\n        item.updateText(true);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to calculate a text style for a PIXI.Text object.\n *\n * @private\n * @param {PIXI.WebGLRenderer|PIXI.CanvasPrepare} helper - Not used by this upload handler\n * @param {PIXI.DisplayObject} item - Item to check\n * @return {boolean} If item was uploaded.\n */\nfunction calculateTextStyle(helper, item)\n{\n    if (item instanceof core.TextStyle)\n    {\n        const font = item.toFontString();\n\n        core.TextMetrics.measureFont(font);\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find Text objects.\n *\n * @private\n * @param {PIXI.DisplayObject} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.Text object was found.\n */\nfunction findText(item, queue)\n{\n    if (item instanceof core.Text)\n    {\n        // push the text style to prepare it - this can be really expensive\n        if (queue.indexOf(item.style) === -1)\n        {\n            queue.push(item.style);\n        }\n        // also push the text object so that we can render it (to canvas/texture) if needed\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n        // also push the Text's texture for upload to GPU\n        const texture = item._texture.baseTexture;\n\n        if (queue.indexOf(texture) === -1)\n        {\n            queue.push(texture);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Built-in hook to find TextStyle objects.\n *\n * @private\n * @param {PIXI.TextStyle} item - Display object to check\n * @param {Array<*>} queue - Collection of items to upload\n * @return {boolean} if a PIXI.TextStyle object was found.\n */\nfunction findTextStyle(item, queue)\n{\n    if (item instanceof core.TextStyle)\n    {\n        if (queue.indexOf(item) === -1)\n        {\n            queue.push(item);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n"]},"metadata":{},"sourceType":"script"}