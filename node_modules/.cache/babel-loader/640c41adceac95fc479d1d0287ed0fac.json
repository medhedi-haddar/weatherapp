{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _BaseTexture = require('./BaseTexture');\n\nvar _BaseTexture2 = _interopRequireDefault(_BaseTexture);\n\nvar _VideoBaseTexture = require('./VideoBaseTexture');\n\nvar _VideoBaseTexture2 = _interopRequireDefault(_VideoBaseTexture);\n\nvar _TextureUvs = require('./TextureUvs');\n\nvar _TextureUvs2 = _interopRequireDefault(_TextureUvs);\n\nvar _eventemitter = require('eventemitter3');\n\nvar _eventemitter2 = _interopRequireDefault(_eventemitter);\n\nvar _math = require('../math');\n\nvar _utils = require('../utils');\n\nvar _settings = require('../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided\n * then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * let texture = PIXI.Texture.fromImage('assets/image.png');\n * let sprite1 = new PIXI.Sprite(texture);\n * let sprite2 = new PIXI.Sprite(texture);\n * ```\n *\n * Textures made from SVGs, loaded or not, cannot be used before the file finishes processing.\n * You can check for this by checking the sprite's _textureID property.\n * ```js\n * var texture = PIXI.Texture.fromImage('assets/image.svg');\n * var sprite1 = new PIXI.Sprite(texture);\n * //sprite1._textureID should not be undefined if the texture has finished processing the SVG file\n * ```\n * You can use a ticker or rAF to ensure your sprites load the finished textures after processing. See issue #3068.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\n\n\nvar Texture = function (_EventEmitter) {\n  _inherits(Texture, _EventEmitter);\n  /**\n   * @param {PIXI.BaseTexture} baseTexture - The base texture source to create the texture from\n   * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show\n   * @param {PIXI.Rectangle} [orig] - The area of original texture\n   * @param {PIXI.Rectangle} [trim] - Trimmed rectangle of original texture\n   * @param {number} [rotate] - indicates how the texture was rotated by texture packer. See {@link PIXI.GroupD8}\n   * @param {PIXI.Point} [anchor] - Default anchor point used for sprite placement / rotation\n   */\n\n\n  function Texture(baseTexture, frame, orig, trim, rotate, anchor) {\n    _classCallCheck(this, Texture);\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * @member {boolean}\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _EventEmitter.call(this));\n\n    _this.noFrame = false;\n\n    if (!frame) {\n      _this.noFrame = true;\n      frame = new _math.Rectangle(0, 0, 1, 1);\n    }\n\n    if (baseTexture instanceof Texture) {\n      baseTexture = baseTexture.baseTexture;\n    }\n    /**\n     * The base texture that this texture uses.\n     *\n     * @member {PIXI.BaseTexture}\n     */\n\n\n    _this.baseTexture = baseTexture;\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     *\n     * @member {PIXI.Rectangle}\n     */\n\n    _this._frame = frame;\n    /**\n     * This is the trimmed area of original texture, before it was put in atlas\n     * Please call `_updateUvs()` after you change coordinates of `trim` manually.\n     *\n     * @member {PIXI.Rectangle}\n     */\n\n    _this.trim = trim;\n    /**\n     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n     *\n     * @member {boolean}\n     */\n\n    _this.valid = false;\n    /**\n     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)\n     *\n     * @member {boolean}\n     */\n\n    _this.requiresUpdate = false;\n    /**\n     * The WebGL UV data cache.\n     *\n     * @member {PIXI.TextureUvs}\n     * @private\n     */\n\n    _this._uvs = null;\n    /**\n     * This is the area of original texture, before it was put in atlas\n     *\n     * @member {PIXI.Rectangle}\n     */\n\n    _this.orig = orig || frame; // new Rectangle(0, 0, 1, 1);\n\n    _this._rotate = Number(rotate || 0);\n\n    if (rotate === true) {\n      // this is old texturepacker legacy, some games/libraries are passing \"true\" for rotated textures\n      _this._rotate = 2;\n    } else if (_this._rotate % 2 !== 0) {\n      throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');\n    }\n\n    if (baseTexture.hasLoaded) {\n      if (_this.noFrame) {\n        frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height); // if there is no frame we should monitor for any base texture changes..\n\n        baseTexture.on('update', _this.onBaseTextureUpdated, _this);\n      }\n\n      _this.frame = frame;\n    } else {\n      baseTexture.once('loaded', _this.onBaseTextureLoaded, _this);\n    }\n    /**\n     * Anchor point that is used as default if sprite is created with this texture.\n     * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n     * @member {PIXI.Point}\n     * @default {0,0}\n     */\n\n\n    _this.defaultAnchor = anchor ? new _math.Point(anchor.x, anchor.y) : new _math.Point(0, 0);\n    /**\n     * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.\n     *\n     * @event PIXI.Texture#update\n     * @protected\n     * @param {PIXI.Texture} texture - Instance of texture being updated.\n     */\n\n    _this._updateID = 0;\n    /**\n     * Contains data for uvs. May contain clamp settings and some matrices.\n     * Its a bit heavy, so by default that object is not created.\n     * @member {PIXI.TextureMatrix}\n     * @default null\n     */\n\n    _this.transform = null;\n    /**\n     * The ids under which this Texture has been added to the texture cache. This is\n     * automatically set as long as Texture.addToCache is used, but may not be set if a\n     * Texture is added directly to the TextureCache array.\n     *\n     * @member {string[]}\n     */\n\n    _this.textureCacheIds = [];\n    return _this;\n  }\n  /**\n   * Updates this texture on the gpu.\n   *\n   */\n\n\n  Texture.prototype.update = function update() {\n    this.baseTexture.update();\n  };\n  /**\n   * Called when the base texture is loaded\n   *\n   * @private\n   * @param {PIXI.BaseTexture} baseTexture - The base texture.\n   */\n\n\n  Texture.prototype.onBaseTextureLoaded = function onBaseTextureLoaded(baseTexture) {\n    this._updateID++; // TODO this code looks confusing.. boo to abusing getters and setters!\n\n    if (this.noFrame) {\n      this.frame = new _math.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n    } else {\n      this.frame = this._frame;\n    }\n\n    this.baseTexture.on('update', this.onBaseTextureUpdated, this);\n    this.emit('update', this);\n  };\n  /**\n   * Called when the base texture is updated\n   *\n   * @private\n   * @param {PIXI.BaseTexture} baseTexture - The base texture.\n   */\n\n\n  Texture.prototype.onBaseTextureUpdated = function onBaseTextureUpdated(baseTexture) {\n    this._updateID++;\n    this._frame.width = baseTexture.width;\n    this._frame.height = baseTexture.height;\n    this.emit('update', this);\n  };\n  /**\n   * Destroys this texture\n   *\n   * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n   */\n\n\n  Texture.prototype.destroy = function destroy(destroyBase) {\n    if (this.baseTexture) {\n      if (destroyBase) {\n        // delete the texture if it exists in the texture cache..\n        // this only needs to be removed if the base texture is actually destroyed too..\n        if (_utils.TextureCache[this.baseTexture.imageUrl]) {\n          Texture.removeFromCache(this.baseTexture.imageUrl);\n        }\n\n        this.baseTexture.destroy();\n      }\n\n      this.baseTexture.off('update', this.onBaseTextureUpdated, this);\n      this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);\n      this.baseTexture = null;\n    }\n\n    this._frame = null;\n    this._uvs = null;\n    this.trim = null;\n    this.orig = null;\n    this.valid = false;\n    Texture.removeFromCache(this);\n    this.textureCacheIds = null;\n  };\n  /**\n   * Creates a new texture object that acts the same as this one.\n   *\n   * @return {PIXI.Texture} The new texture\n   */\n\n\n  Texture.prototype.clone = function clone() {\n    return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);\n  };\n  /**\n   * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.\n   */\n\n\n  Texture.prototype._updateUvs = function _updateUvs() {\n    if (!this._uvs) {\n      this._uvs = new _TextureUvs2.default();\n    }\n\n    this._uvs.set(this._frame, this.baseTexture, this.rotate);\n\n    this._updateID++;\n  };\n  /**\n   * Helper function that creates a Texture object from the given image url.\n   * If the image is not in the texture cache it will be  created and loaded.\n   *\n   * @static\n   * @param {string} imageUrl - The image url of the texture\n   * @param {boolean} [crossorigin] - Whether requests should be treated as crossorigin\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {number} [sourceScale=(auto)] - Scale for the original image, used with SVG images.\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n\n  Texture.fromImage = function fromImage(imageUrl, crossorigin, scaleMode, sourceScale) {\n    var texture = _utils.TextureCache[imageUrl];\n\n    if (!texture) {\n      texture = new Texture(_BaseTexture2.default.fromImage(imageUrl, crossorigin, scaleMode, sourceScale));\n      Texture.addToCache(texture, imageUrl);\n    }\n\n    return texture;\n  };\n  /**\n   * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n   * The frame ids are created when a Texture packer file has been loaded\n   *\n   * @static\n   * @param {string} frameId - The frame Id of the texture in the cache\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n\n  Texture.fromFrame = function fromFrame(frameId) {\n    var texture = _utils.TextureCache[frameId];\n\n    if (!texture) {\n      throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache');\n    }\n\n    return texture;\n  };\n  /**\n   * Helper function that creates a new Texture based on the given canvas element.\n   *\n   * @static\n   * @param {HTMLCanvasElement} canvas - The canvas element source of the texture\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {string} [origin='canvas'] - A string origin of who created the base texture\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n\n  Texture.fromCanvas = function fromCanvas(canvas, scaleMode) {\n    var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'canvas';\n    return new Texture(_BaseTexture2.default.fromCanvas(canvas, scaleMode, origin));\n  };\n  /**\n   * Helper function that creates a new Texture based on the given video element.\n   *\n   * @static\n   * @param {HTMLVideoElement|string} video - The URL or actual element of the video\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n\n  Texture.fromVideo = function fromVideo(video, scaleMode, crossorigin, autoPlay) {\n    if (typeof video === 'string') {\n      return Texture.fromVideoUrl(video, scaleMode, crossorigin, autoPlay);\n    }\n\n    return new Texture(_VideoBaseTexture2.default.fromVideo(video, scaleMode, autoPlay));\n  };\n  /**\n   * Helper function that creates a new Texture based on the video url.\n   *\n   * @static\n   * @param {string} videoUrl - URL of the video\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n\n  Texture.fromVideoUrl = function fromVideoUrl(videoUrl, scaleMode, crossorigin, autoPlay) {\n    return new Texture(_VideoBaseTexture2.default.fromUrl(videoUrl, scaleMode, crossorigin, autoPlay));\n  };\n  /**\n   * Helper function that creates a new Texture based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   *\n   * @static\n   * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture}\n   *        source - Source to create texture from\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n\n  Texture.from = function from(source) {\n    // TODO auto detect cross origin..\n    // TODO pass in scale mode?\n    if (typeof source === 'string') {\n      var texture = _utils.TextureCache[source];\n\n      if (!texture) {\n        // check if its a video..\n        var isVideo = source.match(/\\.(mp4|webm|ogg|h264|avi|mov)$/) !== null;\n\n        if (isVideo) {\n          return Texture.fromVideoUrl(source);\n        }\n\n        return Texture.fromImage(source);\n      }\n\n      return texture;\n    } else if (source instanceof HTMLImageElement) {\n      return new Texture(_BaseTexture2.default.from(source));\n    } else if (source instanceof HTMLCanvasElement) {\n      return Texture.fromCanvas(source, _settings2.default.SCALE_MODE, 'HTMLCanvasElement');\n    } else if (source instanceof HTMLVideoElement) {\n      return Texture.fromVideo(source);\n    } else if (source instanceof _BaseTexture2.default) {\n      return new Texture(source);\n    } // lets assume its a texture!\n\n\n    return source;\n  };\n  /**\n   * Create a texture from a source and add to the cache.\n   *\n   * @static\n   * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.\n   * @param {String} imageUrl - File name of texture, for cache and resolving resolution.\n   * @param {String} [name] - Human readible name for the texture cache. If no name is\n   *        specified, only `imageUrl` will be used as the cache ID.\n   * @return {PIXI.Texture} Output texture\n   */\n\n\n  Texture.fromLoader = function fromLoader(source, imageUrl, name) {\n    var baseTexture = new _BaseTexture2.default(source, undefined, (0, _utils.getResolutionOfUrl)(imageUrl));\n    var texture = new Texture(baseTexture);\n    baseTexture.imageUrl = imageUrl; // No name, use imageUrl instead\n\n    if (!name) {\n      name = imageUrl;\n    } // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions\n\n\n    _BaseTexture2.default.addToCache(texture.baseTexture, name);\n\n    Texture.addToCache(texture, name); // also add references by url if they are different.\n\n    if (name !== imageUrl) {\n      _BaseTexture2.default.addToCache(texture.baseTexture, imageUrl);\n\n      Texture.addToCache(texture, imageUrl);\n    }\n\n    return texture;\n  };\n  /**\n   * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.\n   *\n   * @static\n   * @param {PIXI.Texture} texture - The Texture to add to the cache.\n   * @param {string} id - The id that the Texture will be stored against.\n   */\n\n\n  Texture.addToCache = function addToCache(texture, id) {\n    if (id) {\n      if (texture.textureCacheIds.indexOf(id) === -1) {\n        texture.textureCacheIds.push(id);\n      } // @if DEBUG\n\n      /* eslint-disable no-console */\n\n\n      if (_utils.TextureCache[id]) {\n        console.warn('Texture added to the cache with an id [' + id + '] that already had an entry');\n      }\n      /* eslint-enable no-console */\n      // @endif\n\n\n      _utils.TextureCache[id] = texture;\n    }\n  };\n  /**\n   * Remove a Texture from the global TextureCache.\n   *\n   * @static\n   * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself\n   * @return {PIXI.Texture|null} The Texture that was removed\n   */\n\n\n  Texture.removeFromCache = function removeFromCache(texture) {\n    if (typeof texture === 'string') {\n      var textureFromCache = _utils.TextureCache[texture];\n\n      if (textureFromCache) {\n        var index = textureFromCache.textureCacheIds.indexOf(texture);\n\n        if (index > -1) {\n          textureFromCache.textureCacheIds.splice(index, 1);\n        }\n\n        delete _utils.TextureCache[texture];\n        return textureFromCache;\n      }\n    } else if (texture && texture.textureCacheIds) {\n      for (var i = 0; i < texture.textureCacheIds.length; ++i) {\n        // Check that texture matches the one being passed in before deleting it from the cache.\n        if (_utils.TextureCache[texture.textureCacheIds[i]] === texture) {\n          delete _utils.TextureCache[texture.textureCacheIds[i]];\n        }\n      }\n\n      texture.textureCacheIds.length = 0;\n      return texture;\n    }\n\n    return null;\n  };\n  /**\n   * The frame specifies the region of the base texture that this texture uses.\n   * Please call `_updateUvs()` after you change coordinates of `frame` manually.\n   *\n   * @member {PIXI.Rectangle}\n   */\n\n\n  _createClass(Texture, [{\n    key: 'frame',\n    get: function get() {\n      return this._frame;\n    },\n    set: function set(frame) // eslint-disable-line require-jsdoc\n    {\n      this._frame = frame;\n      this.noFrame = false;\n      var x = frame.x,\n          y = frame.y,\n          width = frame.width,\n          height = frame.height;\n      var xNotFit = x + width > this.baseTexture.width;\n      var yNotFit = y + height > this.baseTexture.height;\n\n      if (xNotFit || yNotFit) {\n        var relationship = xNotFit && yNotFit ? 'and' : 'or';\n        var errorX = 'X: ' + x + ' + ' + width + ' = ' + (x + width) + ' > ' + this.baseTexture.width;\n        var errorY = 'Y: ' + y + ' + ' + height + ' = ' + (y + height) + ' > ' + this.baseTexture.height;\n        throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: ' + (errorX + ' ' + relationship + ' ' + errorY));\n      } // this.valid = width && height && this.baseTexture.source && this.baseTexture.hasLoaded;\n\n\n      this.valid = width && height && this.baseTexture.hasLoaded;\n\n      if (!this.trim && !this.rotate) {\n        this.orig = frame;\n      }\n\n      if (this.valid) {\n        this._updateUvs();\n      }\n    }\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link PIXI.GroupD8} for explanation\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: 'rotate',\n    get: function get() {\n      return this._rotate;\n    },\n    set: function set(rotate) // eslint-disable-line require-jsdoc\n    {\n      this._rotate = rotate;\n\n      if (this.valid) {\n        this._updateUvs();\n      }\n    }\n    /**\n     * The width of the Texture in pixels.\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: 'width',\n    get: function get() {\n      return this.orig.width;\n    }\n    /**\n     * The height of the Texture in pixels.\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: 'height',\n    get: function get() {\n      return this.orig.height;\n    }\n  }]);\n\n  return Texture;\n}(_eventemitter2.default);\n\nexports.default = Texture;\n\nfunction createWhiteTexture() {\n  var canvas = document.createElement('canvas');\n  canvas.width = 10;\n  canvas.height = 10;\n  var context = canvas.getContext('2d');\n  context.fillStyle = 'white';\n  context.fillRect(0, 0, 10, 10);\n  return new Texture(new _BaseTexture2.default(canvas));\n}\n\nfunction removeAllHandlers(tex) {\n  tex.destroy = function _emptyDestroy() {\n    /* empty */\n  };\n\n  tex.on = function _emptyOn() {\n    /* empty */\n  };\n\n  tex.once = function _emptyOnce() {\n    /* empty */\n  };\n\n  tex.emit = function _emptyEmit() {\n    /* empty */\n  };\n}\n/**\n * An empty texture, used often to not have to create multiple empty textures.\n * Can not be destroyed.\n *\n * @static\n * @constant\n */\n\n\nTexture.EMPTY = new Texture(new _BaseTexture2.default());\nremoveAllHandlers(Texture.EMPTY);\nremoveAllHandlers(Texture.EMPTY.baseTexture);\n/**\n * A white texture of 10x10 size, used for graphics and other things\n * Can not be destroyed.\n *\n * @static\n * @constant\n */\n\nTexture.WHITE = createWhiteTexture();\nremoveAllHandlers(Texture.WHITE);\nremoveAllHandlers(Texture.WHITE.baseTexture);","map":{"version":3,"sources":["../../../src/core/textures/Texture.js"],"names":["Texture","frame","baseTexture","orig","Number","rotate","anchor","update","onBaseTextureLoaded","onBaseTextureUpdated","destroy","destroyBase","clone","_updateUvs","fromImage","imageUrl","crossorigin","scaleMode","sourceScale","texture","fromFrame","frameId","fromCanvas","canvas","origin","fromVideo","video","autoPlay","fromVideoUrl","videoUrl","from","source","isVideo","fromLoader","name","addToCache","id","console","removeFromCache","textureFromCache","index","i","x","y","width","height","xNotFit","yNotFit","relationship","errorX","errorY","document","context","tex","removeAllHandlers","createWhiteTexture"],"mappings":"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","sourcesContent":["import BaseTexture from './BaseTexture';\nimport VideoBaseTexture from './VideoBaseTexture';\nimport TextureUvs from './TextureUvs';\nimport EventEmitter from 'eventemitter3';\nimport { Rectangle, Point } from '../math';\nimport { TextureCache, getResolutionOfUrl } from '../utils';\nimport settings from '../settings';\n\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided\n * then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * let texture = PIXI.Texture.fromImage('assets/image.png');\n * let sprite1 = new PIXI.Sprite(texture);\n * let sprite2 = new PIXI.Sprite(texture);\n * ```\n *\n * Textures made from SVGs, loaded or not, cannot be used before the file finishes processing.\n * You can check for this by checking the sprite's _textureID property.\n * ```js\n * var texture = PIXI.Texture.fromImage('assets/image.svg');\n * var sprite1 = new PIXI.Sprite(texture);\n * //sprite1._textureID should not be undefined if the texture has finished processing the SVG file\n * ```\n * You can use a ticker or rAF to ensure your sprites load the finished textures after processing. See issue #3068.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\nexport default class Texture extends EventEmitter\n{\n    /**\n     * @param {PIXI.BaseTexture} baseTexture - The base texture source to create the texture from\n     * @param {PIXI.Rectangle} [frame] - The rectangle frame of the texture to show\n     * @param {PIXI.Rectangle} [orig] - The area of original texture\n     * @param {PIXI.Rectangle} [trim] - Trimmed rectangle of original texture\n     * @param {number} [rotate] - indicates how the texture was rotated by texture packer. See {@link PIXI.GroupD8}\n     * @param {PIXI.Point} [anchor] - Default anchor point used for sprite placement / rotation\n     */\n    constructor(baseTexture, frame, orig, trim, rotate, anchor)\n    {\n        super();\n\n        /**\n         * Does this Texture have any frame data assigned to it?\n         *\n         * @member {boolean}\n         */\n        this.noFrame = false;\n\n        if (!frame)\n        {\n            this.noFrame = true;\n            frame = new Rectangle(0, 0, 1, 1);\n        }\n\n        if (baseTexture instanceof Texture)\n        {\n            baseTexture = baseTexture.baseTexture;\n        }\n\n        /**\n         * The base texture that this texture uses.\n         *\n         * @member {PIXI.BaseTexture}\n         */\n        this.baseTexture = baseTexture;\n\n        /**\n         * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n         * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this._frame = frame;\n\n        /**\n         * This is the trimmed area of original texture, before it was put in atlas\n         * Please call `_updateUvs()` after you change coordinates of `trim` manually.\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.trim = trim;\n\n        /**\n         * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n         *\n         * @member {boolean}\n         */\n        this.valid = false;\n\n        /**\n         * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)\n         *\n         * @member {boolean}\n         */\n        this.requiresUpdate = false;\n\n        /**\n         * The WebGL UV data cache.\n         *\n         * @member {PIXI.TextureUvs}\n         * @private\n         */\n        this._uvs = null;\n\n        /**\n         * This is the area of original texture, before it was put in atlas\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.orig = orig || frame;// new Rectangle(0, 0, 1, 1);\n\n        this._rotate = Number(rotate || 0);\n\n        if (rotate === true)\n        {\n            // this is old texturepacker legacy, some games/libraries are passing \"true\" for rotated textures\n            this._rotate = 2;\n        }\n        else if (this._rotate % 2 !== 0)\n        {\n            throw new Error('attempt to use diamond-shaped UVs. If you are sure, set rotation manually');\n        }\n\n        if (baseTexture.hasLoaded)\n        {\n            if (this.noFrame)\n            {\n                frame = new Rectangle(0, 0, baseTexture.width, baseTexture.height);\n\n                // if there is no frame we should monitor for any base texture changes..\n                baseTexture.on('update', this.onBaseTextureUpdated, this);\n            }\n            this.frame = frame;\n        }\n        else\n        {\n            baseTexture.once('loaded', this.onBaseTextureLoaded, this);\n        }\n\n        /**\n         * Anchor point that is used as default if sprite is created with this texture.\n         * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n         * @member {PIXI.Point}\n         * @default {0,0}\n         */\n        this.defaultAnchor = anchor ? new Point(anchor.x, anchor.y) : new Point(0, 0);\n\n        /**\n         * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.\n         *\n         * @event PIXI.Texture#update\n         * @protected\n         * @param {PIXI.Texture} texture - Instance of texture being updated.\n         */\n\n        this._updateID = 0;\n\n        /**\n         * Contains data for uvs. May contain clamp settings and some matrices.\n         * Its a bit heavy, so by default that object is not created.\n         * @member {PIXI.TextureMatrix}\n         * @default null\n         */\n        this.transform = null;\n\n        /**\n         * The ids under which this Texture has been added to the texture cache. This is\n         * automatically set as long as Texture.addToCache is used, but may not be set if a\n         * Texture is added directly to the TextureCache array.\n         *\n         * @member {string[]}\n         */\n        this.textureCacheIds = [];\n    }\n\n    /**\n     * Updates this texture on the gpu.\n     *\n     */\n    update()\n    {\n        this.baseTexture.update();\n    }\n\n    /**\n     * Called when the base texture is loaded\n     *\n     * @private\n     * @param {PIXI.BaseTexture} baseTexture - The base texture.\n     */\n    onBaseTextureLoaded(baseTexture)\n    {\n        this._updateID++;\n\n        // TODO this code looks confusing.. boo to abusing getters and setters!\n        if (this.noFrame)\n        {\n            this.frame = new Rectangle(0, 0, baseTexture.width, baseTexture.height);\n        }\n        else\n        {\n            this.frame = this._frame;\n        }\n\n        this.baseTexture.on('update', this.onBaseTextureUpdated, this);\n        this.emit('update', this);\n    }\n\n    /**\n     * Called when the base texture is updated\n     *\n     * @private\n     * @param {PIXI.BaseTexture} baseTexture - The base texture.\n     */\n    onBaseTextureUpdated(baseTexture)\n    {\n        this._updateID++;\n\n        this._frame.width = baseTexture.width;\n        this._frame.height = baseTexture.height;\n\n        this.emit('update', this);\n    }\n\n    /**\n     * Destroys this texture\n     *\n     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n     */\n    destroy(destroyBase)\n    {\n        if (this.baseTexture)\n        {\n            if (destroyBase)\n            {\n                // delete the texture if it exists in the texture cache..\n                // this only needs to be removed if the base texture is actually destroyed too..\n                if (TextureCache[this.baseTexture.imageUrl])\n                {\n                    Texture.removeFromCache(this.baseTexture.imageUrl);\n                }\n\n                this.baseTexture.destroy();\n            }\n\n            this.baseTexture.off('update', this.onBaseTextureUpdated, this);\n            this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);\n\n            this.baseTexture = null;\n        }\n\n        this._frame = null;\n        this._uvs = null;\n        this.trim = null;\n        this.orig = null;\n\n        this.valid = false;\n\n        Texture.removeFromCache(this);\n        this.textureCacheIds = null;\n    }\n\n    /**\n     * Creates a new texture object that acts the same as this one.\n     *\n     * @return {PIXI.Texture} The new texture\n     */\n    clone()\n    {\n        return new Texture(this.baseTexture, this.frame, this.orig, this.trim, this.rotate, this.defaultAnchor);\n    }\n\n    /**\n     * Updates the internal WebGL UV cache. Use it after you change `frame` or `trim` of the texture.\n     */\n    _updateUvs()\n    {\n        if (!this._uvs)\n        {\n            this._uvs = new TextureUvs();\n        }\n\n        this._uvs.set(this._frame, this.baseTexture, this.rotate);\n\n        this._updateID++;\n    }\n\n    /**\n     * Helper function that creates a Texture object from the given image url.\n     * If the image is not in the texture cache it will be  created and loaded.\n     *\n     * @static\n     * @param {string} imageUrl - The image url of the texture\n     * @param {boolean} [crossorigin] - Whether requests should be treated as crossorigin\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [sourceScale=(auto)] - Scale for the original image, used with SVG images.\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromImage(imageUrl, crossorigin, scaleMode, sourceScale)\n    {\n        let texture = TextureCache[imageUrl];\n\n        if (!texture)\n        {\n            texture = new Texture(BaseTexture.fromImage(imageUrl, crossorigin, scaleMode, sourceScale));\n            Texture.addToCache(texture, imageUrl);\n        }\n\n        return texture;\n    }\n\n    /**\n     * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n     * The frame ids are created when a Texture packer file has been loaded\n     *\n     * @static\n     * @param {string} frameId - The frame Id of the texture in the cache\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromFrame(frameId)\n    {\n        const texture = TextureCache[frameId];\n\n        if (!texture)\n        {\n            throw new Error(`The frameId \"${frameId}\" does not exist in the texture cache`);\n        }\n\n        return texture;\n    }\n\n    /**\n     * Helper function that creates a new Texture based on the given canvas element.\n     *\n     * @static\n     * @param {HTMLCanvasElement} canvas - The canvas element source of the texture\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {string} [origin='canvas'] - A string origin of who created the base texture\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromCanvas(canvas, scaleMode, origin = 'canvas')\n    {\n        return new Texture(BaseTexture.fromCanvas(canvas, scaleMode, origin));\n    }\n\n    /**\n     * Helper function that creates a new Texture based on the given video element.\n     *\n     * @static\n     * @param {HTMLVideoElement|string} video - The URL or actual element of the video\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromVideo(video, scaleMode, crossorigin, autoPlay)\n    {\n        if (typeof video === 'string')\n        {\n            return Texture.fromVideoUrl(video, scaleMode, crossorigin, autoPlay);\n        }\n\n        return new Texture(VideoBaseTexture.fromVideo(video, scaleMode, autoPlay));\n    }\n\n    /**\n     * Helper function that creates a new Texture based on the video url.\n     *\n     * @static\n     * @param {string} videoUrl - URL of the video\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static fromVideoUrl(videoUrl, scaleMode, crossorigin, autoPlay)\n    {\n        return new Texture(VideoBaseTexture.fromUrl(videoUrl, scaleMode, crossorigin, autoPlay));\n    }\n\n    /**\n     * Helper function that creates a new Texture based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {number|string|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement|PIXI.BaseTexture}\n     *        source - Source to create texture from\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static from(source)\n    {\n        // TODO auto detect cross origin..\n        // TODO pass in scale mode?\n        if (typeof source === 'string')\n        {\n            const texture = TextureCache[source];\n\n            if (!texture)\n            {\n                // check if its a video..\n                const isVideo = source.match(/\\.(mp4|webm|ogg|h264|avi|mov)$/) !== null;\n\n                if (isVideo)\n                {\n                    return Texture.fromVideoUrl(source);\n                }\n\n                return Texture.fromImage(source);\n            }\n\n            return texture;\n        }\n        else if (source instanceof HTMLImageElement)\n        {\n            return new Texture(BaseTexture.from(source));\n        }\n        else if (source instanceof HTMLCanvasElement)\n        {\n            return Texture.fromCanvas(source, settings.SCALE_MODE, 'HTMLCanvasElement');\n        }\n        else if (source instanceof HTMLVideoElement)\n        {\n            return Texture.fromVideo(source);\n        }\n        else if (source instanceof BaseTexture)\n        {\n            return new Texture(source);\n        }\n\n        // lets assume its a texture!\n        return source;\n    }\n\n    /**\n     * Create a texture from a source and add to the cache.\n     *\n     * @static\n     * @param {HTMLImageElement|HTMLCanvasElement} source - The input source.\n     * @param {String} imageUrl - File name of texture, for cache and resolving resolution.\n     * @param {String} [name] - Human readible name for the texture cache. If no name is\n     *        specified, only `imageUrl` will be used as the cache ID.\n     * @return {PIXI.Texture} Output texture\n     */\n    static fromLoader(source, imageUrl, name)\n    {\n        const baseTexture = new BaseTexture(source, undefined, getResolutionOfUrl(imageUrl));\n        const texture = new Texture(baseTexture);\n\n        baseTexture.imageUrl = imageUrl;\n\n        // No name, use imageUrl instead\n        if (!name)\n        {\n            name = imageUrl;\n        }\n\n        // lets also add the frame to pixi's global cache for fromFrame and fromImage fucntions\n        BaseTexture.addToCache(texture.baseTexture, name);\n        Texture.addToCache(texture, name);\n\n        // also add references by url if they are different.\n        if (name !== imageUrl)\n        {\n            BaseTexture.addToCache(texture.baseTexture, imageUrl);\n            Texture.addToCache(texture, imageUrl);\n        }\n\n        return texture;\n    }\n\n    /**\n     * Adds a Texture to the global TextureCache. This cache is shared across the whole PIXI object.\n     *\n     * @static\n     * @param {PIXI.Texture} texture - The Texture to add to the cache.\n     * @param {string} id - The id that the Texture will be stored against.\n     */\n    static addToCache(texture, id)\n    {\n        if (id)\n        {\n            if (texture.textureCacheIds.indexOf(id) === -1)\n            {\n                texture.textureCacheIds.push(id);\n            }\n\n            // @if DEBUG\n            /* eslint-disable no-console */\n            if (TextureCache[id])\n            {\n                console.warn(`Texture added to the cache with an id [${id}] that already had an entry`);\n            }\n            /* eslint-enable no-console */\n            // @endif\n\n            TextureCache[id] = texture;\n        }\n    }\n\n    /**\n     * Remove a Texture from the global TextureCache.\n     *\n     * @static\n     * @param {string|PIXI.Texture} texture - id of a Texture to be removed, or a Texture instance itself\n     * @return {PIXI.Texture|null} The Texture that was removed\n     */\n    static removeFromCache(texture)\n    {\n        if (typeof texture === 'string')\n        {\n            const textureFromCache = TextureCache[texture];\n\n            if (textureFromCache)\n            {\n                const index = textureFromCache.textureCacheIds.indexOf(texture);\n\n                if (index > -1)\n                {\n                    textureFromCache.textureCacheIds.splice(index, 1);\n                }\n\n                delete TextureCache[texture];\n\n                return textureFromCache;\n            }\n        }\n        else if (texture && texture.textureCacheIds)\n        {\n            for (let i = 0; i < texture.textureCacheIds.length; ++i)\n            {\n                // Check that texture matches the one being passed in before deleting it from the cache.\n                if (TextureCache[texture.textureCacheIds[i]] === texture)\n                {\n                    delete TextureCache[texture.textureCacheIds[i]];\n                }\n            }\n\n            texture.textureCacheIds.length = 0;\n\n            return texture;\n        }\n\n        return null;\n    }\n\n    /**\n     * The frame specifies the region of the base texture that this texture uses.\n     * Please call `_updateUvs()` after you change coordinates of `frame` manually.\n     *\n     * @member {PIXI.Rectangle}\n     */\n    get frame()\n    {\n        return this._frame;\n    }\n\n    set frame(frame) // eslint-disable-line require-jsdoc\n    {\n        this._frame = frame;\n\n        this.noFrame = false;\n\n        const { x, y, width, height } = frame;\n        const xNotFit = x + width > this.baseTexture.width;\n        const yNotFit = y + height > this.baseTexture.height;\n\n        if (xNotFit || yNotFit)\n        {\n            const relationship = xNotFit && yNotFit ? 'and' : 'or';\n            const errorX = `X: ${x} + ${width} = ${x + width} > ${this.baseTexture.width}`;\n            const errorY = `Y: ${y} + ${height} = ${y + height} > ${this.baseTexture.height}`;\n\n            throw new Error('Texture Error: frame does not fit inside the base Texture dimensions: '\n                + `${errorX} ${relationship} ${errorY}`);\n        }\n\n        // this.valid = width && height && this.baseTexture.source && this.baseTexture.hasLoaded;\n        this.valid = width && height && this.baseTexture.hasLoaded;\n\n        if (!this.trim && !this.rotate)\n        {\n            this.orig = frame;\n        }\n\n        if (this.valid)\n        {\n            this._updateUvs();\n        }\n    }\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link PIXI.GroupD8} for explanation\n     *\n     * @member {number}\n     */\n    get rotate()\n    {\n        return this._rotate;\n    }\n\n    set rotate(rotate) // eslint-disable-line require-jsdoc\n    {\n        this._rotate = rotate;\n        if (this.valid)\n        {\n            this._updateUvs();\n        }\n    }\n\n    /**\n     * The width of the Texture in pixels.\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this.orig.width;\n    }\n\n    /**\n     * The height of the Texture in pixels.\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this.orig.height;\n    }\n}\n\nfunction createWhiteTexture()\n{\n    const canvas = document.createElement('canvas');\n\n    canvas.width = 10;\n    canvas.height = 10;\n\n    const context = canvas.getContext('2d');\n\n    context.fillStyle = 'white';\n    context.fillRect(0, 0, 10, 10);\n\n    return new Texture(new BaseTexture(canvas));\n}\n\nfunction removeAllHandlers(tex)\n{\n    tex.destroy = function _emptyDestroy() { /* empty */ };\n    tex.on = function _emptyOn() { /* empty */ };\n    tex.once = function _emptyOnce() { /* empty */ };\n    tex.emit = function _emptyEmit() { /* empty */ };\n}\n\n/**\n * An empty texture, used often to not have to create multiple empty textures.\n * Can not be destroyed.\n *\n * @static\n * @constant\n */\nTexture.EMPTY = new Texture(new BaseTexture());\nremoveAllHandlers(Texture.EMPTY);\nremoveAllHandlers(Texture.EMPTY.baseTexture);\n\n/**\n * A white texture of 10x10 size, used for graphics and other things\n * Can not be destroyed.\n *\n * @static\n * @constant\n */\nTexture.WHITE = createWhiteTexture();\nremoveAllHandlers(Texture.WHITE);\nremoveAllHandlers(Texture.WHITE.baseTexture);\n"]},"metadata":{},"sourceType":"script"}