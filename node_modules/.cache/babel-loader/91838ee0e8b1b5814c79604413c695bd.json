{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _const = require('../../../const');\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * A set of functions used to handle masking.\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar CanvasMaskManager = function () {\n  /**\n   * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n   */\n  function CanvasMaskManager(renderer) {\n    _classCallCheck(this, CanvasMaskManager);\n\n    this.renderer = renderer;\n  }\n  /**\n   * This method adds it to the current stack of masks.\n   *\n   * @param {object} maskData - the maskData that will be pushed\n   */\n\n\n  CanvasMaskManager.prototype.pushMask = function pushMask(maskData) {\n    var renderer = this.renderer;\n    renderer.context.save();\n    var cacheAlpha = maskData.alpha;\n    var transform = maskData.transform.worldTransform;\n    var resolution = renderer.resolution;\n    renderer.context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution); // TODO suport sprite alpha masks??\n    // lots of effort required. If demand is great enough..\n\n    if (!maskData._texture) {\n      this.renderGraphicsShape(maskData);\n      renderer.context.clip();\n    }\n\n    maskData.worldAlpha = cacheAlpha;\n  };\n  /**\n   * Renders a PIXI.Graphics shape.\n   *\n   * @param {PIXI.Graphics} graphics - The object to render.\n   */\n\n\n  CanvasMaskManager.prototype.renderGraphicsShape = function renderGraphicsShape(graphics) {\n    var context = this.renderer.context;\n    var len = graphics.graphicsData.length;\n\n    if (len === 0) {\n      return;\n    }\n\n    context.beginPath();\n\n    for (var i = 0; i < len; i++) {\n      var data = graphics.graphicsData[i];\n      var shape = data.shape;\n\n      if (data.type === _const.SHAPES.POLY) {\n        var points = shape.points;\n        var holes = data.holes;\n        var outerArea = void 0;\n        var innerArea = void 0;\n        context.moveTo(points[0], points[1]);\n\n        for (var j = 2; j < points.length; j += 2) {\n          context.lineTo(points[j], points[j + 1]);\n        } // if the first and last point are the same close the path - much neater :)\n\n\n        if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1]) {\n          context.closePath();\n        }\n\n        if (holes.length > 0) {\n          outerArea = 0;\n\n          for (var _j = 0; _j < points.length; _j += 2) {\n            outerArea += points[_j] * points[_j + 3] - points[_j + 1] * points[_j + 2];\n          }\n\n          for (var k = 0; k < holes.length; k++) {\n            points = holes[k].points;\n            innerArea = 0;\n\n            for (var _j2 = 0; _j2 < points.length; _j2 += 2) {\n              innerArea += points[_j2] * points[_j2 + 3] - points[_j2 + 1] * points[_j2 + 2];\n            }\n\n            context.moveTo(points[0], points[1]);\n\n            if (innerArea * outerArea < 0) {\n              for (var _j3 = 2; _j3 < points.length; _j3 += 2) {\n                context.lineTo(points[_j3], points[_j3 + 1]);\n              }\n            } else {\n              for (var _j4 = points.length - 2; _j4 >= 2; _j4 -= 2) {\n                context.lineTo(points[_j4], points[_j4 + 1]);\n              }\n            }\n          }\n        }\n      } else if (data.type === _const.SHAPES.RECT) {\n        context.rect(shape.x, shape.y, shape.width, shape.height);\n        context.closePath();\n      } else if (data.type === _const.SHAPES.CIRC) {\n        // TODO - need to be Undefined!\n        context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n        context.closePath();\n      } else if (data.type === _const.SHAPES.ELIP) {\n        // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n        var w = shape.width * 2;\n        var h = shape.height * 2;\n        var x = shape.x - w / 2;\n        var y = shape.y - h / 2;\n        var kappa = 0.5522848;\n        var ox = w / 2 * kappa; // control point offset horizontal\n\n        var oy = h / 2 * kappa; // control point offset vertical\n\n        var xe = x + w; // x-end\n\n        var ye = y + h; // y-end\n\n        var xm = x + w / 2; // x-middle\n\n        var ym = y + h / 2; // y-middle\n\n        context.moveTo(x, ym);\n        context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n        context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n        context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n        context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n        context.closePath();\n      } else if (data.type === _const.SHAPES.RREC) {\n        var rx = shape.x;\n        var ry = shape.y;\n        var width = shape.width;\n        var height = shape.height;\n        var radius = shape.radius;\n        var maxRadius = Math.min(width, height) / 2 | 0;\n        radius = radius > maxRadius ? maxRadius : radius;\n        context.moveTo(rx, ry + radius);\n        context.lineTo(rx, ry + height - radius);\n        context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n        context.lineTo(rx + width - radius, ry + height);\n        context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n        context.lineTo(rx + width, ry + radius);\n        context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n        context.lineTo(rx + radius, ry);\n        context.quadraticCurveTo(rx, ry, rx, ry + radius);\n        context.closePath();\n      }\n    }\n  };\n  /**\n   * Restores the current drawing context to the state it was before the mask was applied.\n   *\n   * @param {PIXI.CanvasRenderer} renderer - The renderer context to use.\n   */\n\n\n  CanvasMaskManager.prototype.popMask = function popMask(renderer) {\n    renderer.context.restore();\n    renderer.invalidateBlendMode();\n  };\n  /**\n   * Destroys this canvas mask manager.\n   *\n   */\n\n\n  CanvasMaskManager.prototype.destroy = function destroy() {\n    /* empty */\n  };\n\n  return CanvasMaskManager;\n}();\n\nexports.default = CanvasMaskManager;","map":{"version":3,"sources":["../../../../../src/core/renderers/canvas/utils/CanvasMaskManager.js"],"names":["CanvasMaskManager","pushMask","maskData","renderer","cacheAlpha","transform","resolution","renderGraphicsShape","graphics","context","len","i","data","shape","points","holes","outerArea","innerArea","j","k","Math","w","h","x","y","kappa","ox","oy","xe","ye","xm","ym","rx","ry","width","height","radius","maxRadius","popMask","destroy"],"mappings":"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","sourcesContent":["import { SHAPES } from '../../../const';\n\n/**\n * A set of functions used to handle masking.\n *\n * @class\n * @memberof PIXI\n */\nexport default class CanvasMaskManager\n{\n    /**\n     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    /**\n     * This method adds it to the current stack of masks.\n     *\n     * @param {object} maskData - the maskData that will be pushed\n     */\n    pushMask(maskData)\n    {\n        const renderer = this.renderer;\n\n        renderer.context.save();\n\n        const cacheAlpha = maskData.alpha;\n        const transform = maskData.transform.worldTransform;\n        const resolution = renderer.resolution;\n\n        renderer.context.setTransform(\n            transform.a * resolution,\n            transform.b * resolution,\n            transform.c * resolution,\n            transform.d * resolution,\n            transform.tx * resolution,\n            transform.ty * resolution\n        );\n\n        // TODO suport sprite alpha masks??\n        // lots of effort required. If demand is great enough..\n        if (!maskData._texture)\n        {\n            this.renderGraphicsShape(maskData);\n            renderer.context.clip();\n        }\n\n        maskData.worldAlpha = cacheAlpha;\n    }\n\n    /**\n     * Renders a PIXI.Graphics shape.\n     *\n     * @param {PIXI.Graphics} graphics - The object to render.\n     */\n    renderGraphicsShape(graphics)\n    {\n        const context = this.renderer.context;\n        const len = graphics.graphicsData.length;\n\n        if (len === 0)\n        {\n            return;\n        }\n\n        context.beginPath();\n\n        for (let i = 0; i < len; i++)\n        {\n            const data = graphics.graphicsData[i];\n            const shape = data.shape;\n\n            if (data.type === SHAPES.POLY)\n            {\n                let points = shape.points;\n                const holes = data.holes;\n                let outerArea;\n                let innerArea;\n\n                context.moveTo(points[0], points[1]);\n\n                for (let j = 2; j < points.length; j += 2)\n                {\n                    context.lineTo(points[j], points[j + 1]);\n                }\n\n                // if the first and last point are the same close the path - much neater :)\n                if (points[0] === points[points.length - 2] && points[1] === points[points.length - 1])\n                {\n                    context.closePath();\n                }\n\n                if (holes.length > 0)\n                {\n                    outerArea = 0;\n                    for (let j = 0; j < points.length; j += 2)\n                    {\n                        outerArea += (points[j] * points[j + 3]) - (points[j + 1] * points[j + 2]);\n                    }\n\n                    for (let k = 0; k < holes.length; k++)\n                    {\n                        points = holes[k].points;\n\n                        innerArea = 0;\n                        for (let j = 0; j < points.length; j += 2)\n                        {\n                            innerArea += (points[j] * points[j + 3]) - (points[j + 1] * points[j + 2]);\n                        }\n\n                        context.moveTo(points[0], points[1]);\n\n                        if (innerArea * outerArea < 0)\n                        {\n                            for (let j = 2; j < points.length; j += 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                        else\n                        {\n                            for (let j = points.length - 2; j >= 2; j -= 2)\n                            {\n                                context.lineTo(points[j], points[j + 1]);\n                            }\n                        }\n                    }\n                }\n            }\n            else if (data.type === SHAPES.RECT)\n            {\n                context.rect(shape.x, shape.y, shape.width, shape.height);\n                context.closePath();\n            }\n            else if (data.type === SHAPES.CIRC)\n            {\n                // TODO - need to be Undefined!\n                context.arc(shape.x, shape.y, shape.radius, 0, 2 * Math.PI);\n                context.closePath();\n            }\n            else if (data.type === SHAPES.ELIP)\n            {\n                // ellipse code taken from: http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas\n\n                const w = shape.width * 2;\n                const h = shape.height * 2;\n\n                const x = shape.x - (w / 2);\n                const y = shape.y - (h / 2);\n\n                const kappa = 0.5522848;\n                const ox = (w / 2) * kappa; // control point offset horizontal\n                const oy = (h / 2) * kappa; // control point offset vertical\n                const xe = x + w;           // x-end\n                const ye = y + h;           // y-end\n                const xm = x + (w / 2);       // x-middle\n                const ym = y + (h / 2);       // y-middle\n\n                context.moveTo(x, ym);\n                context.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n                context.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n                context.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n                context.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n                context.closePath();\n            }\n            else if (data.type === SHAPES.RREC)\n            {\n                const rx = shape.x;\n                const ry = shape.y;\n                const width = shape.width;\n                const height = shape.height;\n                let radius = shape.radius;\n\n                const maxRadius = Math.min(width, height) / 2 | 0;\n\n                radius = radius > maxRadius ? maxRadius : radius;\n\n                context.moveTo(rx, ry + radius);\n                context.lineTo(rx, ry + height - radius);\n                context.quadraticCurveTo(rx, ry + height, rx + radius, ry + height);\n                context.lineTo(rx + width - radius, ry + height);\n                context.quadraticCurveTo(rx + width, ry + height, rx + width, ry + height - radius);\n                context.lineTo(rx + width, ry + radius);\n                context.quadraticCurveTo(rx + width, ry, rx + width - radius, ry);\n                context.lineTo(rx + radius, ry);\n                context.quadraticCurveTo(rx, ry, rx, ry + radius);\n                context.closePath();\n            }\n        }\n    }\n\n    /**\n     * Restores the current drawing context to the state it was before the mask was applied.\n     *\n     * @param {PIXI.CanvasRenderer} renderer - The renderer context to use.\n     */\n    popMask(renderer)\n    {\n        renderer.context.restore();\n        renderer.invalidateBlendMode();\n    }\n\n    /**\n     * Destroys this canvas mask manager.\n     *\n     */\n    destroy()\n    {\n        /* empty */\n    }\n}\n"]},"metadata":{},"sourceType":"script"}