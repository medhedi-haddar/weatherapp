{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _core = require('../../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _const = require('../../core/const');\n\nvar _path = require('path');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar tempMat = new core.Matrix();\n/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI.extras\n * @extends PIXI.ObjectRenderer\n */\n\nvar TilingSpriteRenderer = function (_core$ObjectRenderer) {\n  _inherits(TilingSpriteRenderer, _core$ObjectRenderer);\n  /**\n   * constructor for renderer\n   *\n   * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.\n   */\n\n\n  function TilingSpriteRenderer(renderer) {\n    _classCallCheck(this, TilingSpriteRenderer);\n\n    var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));\n\n    _this.shader = null;\n    _this.simpleShader = null;\n    _this.quad = null;\n    return _this;\n  }\n  /**\n   * Sets up the renderer context and necessary buffers.\n   *\n   * @private\n   */\n\n\n  TilingSpriteRenderer.prototype.onContextChange = function onContextChange() {\n    var gl = this.renderer.gl;\n    this.shader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n', 'varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = mod(vTextureCoord - uClampOffset, vec2(1.0, 1.0)) + uClampOffset;\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    vec4 sample = texture2D(uSampler, coord);\\n    gl_FragColor = sample * uColor;\\n}\\n');\n    this.simpleShader = new core.Shader(gl, 'attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n', 'varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec4 sample = texture2D(uSampler, vTextureCoord);\\n    gl_FragColor = sample * uColor;\\n}\\n');\n    this.renderer.bindVao(null);\n    this.quad = new core.Quad(gl, this.renderer.state.attribState);\n    this.quad.initVao(this.shader);\n  };\n  /**\n   *\n   * @param {PIXI.extras.TilingSprite} ts tilingSprite to be rendered\n   */\n\n\n  TilingSpriteRenderer.prototype.render = function render(ts) {\n    var renderer = this.renderer;\n    var quad = this.quad;\n    renderer.bindVao(quad.vao);\n    var vertices = quad.vertices;\n    vertices[0] = vertices[6] = ts._width * -ts.anchor.x;\n    vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n    vertices[2] = vertices[4] = ts._width * (1.0 - ts.anchor.x);\n    vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n\n    if (ts.uvRespectAnchor) {\n      vertices = quad.uvs;\n      vertices[0] = vertices[6] = -ts.anchor.x;\n      vertices[1] = vertices[3] = -ts.anchor.y;\n      vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\n      vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\n    }\n\n    quad.upload();\n    var tex = ts._texture;\n    var baseTex = tex.baseTexture;\n    var lt = ts.tileTransform.localTransform;\n    var uv = ts.uvTransform;\n    var isSimple = baseTex.isPowerOfTwo && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height; // auto, force repeat wrapMode for big tiling textures\n\n    if (isSimple) {\n      if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n        if (baseTex.wrapMode === _const.WRAP_MODES.CLAMP) {\n          baseTex.wrapMode = _const.WRAP_MODES.REPEAT;\n        }\n      } else {\n        isSimple = baseTex.wrapMode !== _const.WRAP_MODES.CLAMP;\n      }\n    }\n\n    var shader = isSimple ? this.simpleShader : this.shader;\n    renderer.bindShader(shader);\n    var w = tex.width;\n    var h = tex.height;\n    var W = ts._width;\n    var H = ts._height;\n    tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H); // that part is the same as above:\n    // tempMat.identity();\n    // tempMat.scale(tex.width, tex.height);\n    // tempMat.prepend(lt);\n    // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n    tempMat.invert();\n\n    if (isSimple) {\n      tempMat.prepend(uv.mapCoord);\n    } else {\n      shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n      shader.uniforms.uClampFrame = uv.uClampFrame;\n      shader.uniforms.uClampOffset = uv.uClampOffset;\n    }\n\n    shader.uniforms.uTransform = tempMat.toArray(true);\n    shader.uniforms.uColor = core.utils.premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.premultipliedAlpha);\n    shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n    shader.uniforms.uSampler = renderer.bindTexture(tex);\n    renderer.setBlendMode(core.utils.correctBlendMode(ts.blendMode, baseTex.premultipliedAlpha));\n    quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n  };\n\n  return TilingSpriteRenderer;\n}(core.ObjectRenderer);\n\nexports.default = TilingSpriteRenderer;\ncore.WebGLRenderer.registerPlugin('tilingSprite', TilingSpriteRenderer);","map":{"version":3,"sources":["../../../src/extras/webgl/TilingSpriteRenderer.js"],"names":["core","tempMat","TilingSpriteRenderer","ObjectRenderer","onContextChange","gl","render","ts","renderer","quad","vertices","tex","baseTex","lt","uv","isSimple","shader","w","h","W","H"],"mappings":"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","sourcesContent":["import * as core from '../../core';\nimport { WRAP_MODES } from '../../core/const';\nimport { readFileSync } from 'fs';\nimport { join } from 'path';\n\nconst tempMat = new core.Matrix();\n\n/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI.extras\n * @extends PIXI.ObjectRenderer\n */\nexport default class TilingSpriteRenderer extends core.ObjectRenderer\n{\n\n    /**\n     * constructor for renderer\n     *\n     * @param {WebGLRenderer} renderer The renderer this tiling awesomeness works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.shader = null;\n        this.simpleShader = null;\n        this.quad = null;\n    }\n\n    /**\n     * Sets up the renderer context and necessary buffers.\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        this.shader = new core.Shader(gl,\n            readFileSync(join(__dirname, './tilingSprite.vert'), 'utf8'),\n            readFileSync(join(__dirname, './tilingSprite.frag'), 'utf8'));\n        this.simpleShader = new core.Shader(gl,\n            readFileSync(join(__dirname, './tilingSprite.vert'), 'utf8'),\n            readFileSync(join(__dirname, './tilingSprite_simple.frag'), 'utf8'));\n\n        this.renderer.bindVao(null);\n        this.quad = new core.Quad(gl, this.renderer.state.attribState);\n        this.quad.initVao(this.shader);\n    }\n\n    /**\n     *\n     * @param {PIXI.extras.TilingSprite} ts tilingSprite to be rendered\n     */\n    render(ts)\n    {\n        const renderer = this.renderer;\n        const quad = this.quad;\n\n        renderer.bindVao(quad.vao);\n\n        let vertices = quad.vertices;\n\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n\n        if (ts.uvRespectAnchor)\n        {\n            vertices = quad.uvs;\n\n            vertices[0] = vertices[6] = -ts.anchor.x;\n            vertices[1] = vertices[3] = -ts.anchor.y;\n\n            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\n            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\n        }\n\n        quad.upload();\n\n        const tex = ts._texture;\n        const baseTex = tex.baseTexture;\n        const lt = ts.tileTransform.localTransform;\n        const uv = ts.uvTransform;\n        let isSimple = baseTex.isPowerOfTwo\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n\n        // auto, force repeat wrapMode for big tiling textures\n        if (isSimple)\n        {\n            if (!baseTex._glTextures[renderer.CONTEXT_UID])\n            {\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\n                }\n            }\n            else\n            {\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n            }\n        }\n\n        const shader = isSimple ? this.simpleShader : this.shader;\n\n        renderer.bindShader(shader);\n\n        const w = tex.width;\n        const h = tex.height;\n        const W = ts._width;\n        const H = ts._height;\n\n        tempMat.set(lt.a * w / W,\n            lt.b * w / H,\n            lt.c * h / W,\n            lt.d * h / H,\n            lt.tx / W,\n            lt.ty / H);\n\n        // that part is the same as above:\n        // tempMat.identity();\n        // tempMat.scale(tex.width, tex.height);\n        // tempMat.prepend(lt);\n        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n\n        tempMat.invert();\n        if (isSimple)\n        {\n            tempMat.prepend(uv.mapCoord);\n        }\n        else\n        {\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n            shader.uniforms.uClampFrame = uv.uClampFrame;\n            shader.uniforms.uClampOffset = uv.uClampOffset;\n        }\n\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        shader.uniforms.uColor = core.utils.premultiplyTintToRgba(ts.tint, ts.worldAlpha,\n            shader.uniforms.uColor, baseTex.premultipliedAlpha);\n        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n\n        shader.uniforms.uSampler = renderer.bindTexture(tex);\n\n        renderer.setBlendMode(core.utils.correctBlendMode(ts.blendMode, baseTex.premultipliedAlpha));\n\n        quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    }\n}\n\ncore.WebGLRenderer.registerPlugin('tilingSprite', TilingSpriteRenderer);\n"]},"metadata":{},"sourceType":"script"}