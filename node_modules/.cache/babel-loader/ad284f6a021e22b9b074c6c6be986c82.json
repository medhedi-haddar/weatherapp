{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _math = require('../math');\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Generic class to deal with traditional 2D matrix transforms\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar TransformBase = function () {\n  /**\n   *\n   */\n  function TransformBase() {\n    _classCallCheck(this, TransformBase);\n    /**\n     * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()\n     *\n     * @member {PIXI.Matrix}\n     */\n\n\n    this.worldTransform = new _math.Matrix();\n    /**\n     * The local matrix transform\n     *\n     * @member {PIXI.Matrix}\n     */\n\n    this.localTransform = new _math.Matrix();\n    this._worldID = 0;\n    this._parentID = 0;\n  }\n  /**\n   * TransformBase does not have decomposition, so this function wont do anything\n   */\n\n\n  TransformBase.prototype.updateLocalTransform = function updateLocalTransform() {} // empty\n\n  /**\n   * Updates the values of the object and applies the parent's transform.\n   *\n   * @param {PIXI.TransformBase} parentTransform - The transform of the parent of this object\n   */\n  ;\n\n  TransformBase.prototype.updateTransform = function updateTransform(parentTransform) {\n    var pt = parentTransform.worldTransform;\n    var wt = this.worldTransform;\n    var lt = this.localTransform; // concat the parent matrix with the objects transform.\n\n    wt.a = lt.a * pt.a + lt.b * pt.c;\n    wt.b = lt.a * pt.b + lt.b * pt.d;\n    wt.c = lt.c * pt.a + lt.d * pt.c;\n    wt.d = lt.c * pt.b + lt.d * pt.d;\n    wt.tx = lt.tx * pt.a + lt.ty * pt.c + pt.tx;\n    wt.ty = lt.tx * pt.b + lt.ty * pt.d + pt.ty;\n    this._worldID++;\n  };\n\n  return TransformBase;\n}();\n/**\n * Updates the values of the object and applies the parent's transform.\n * @param  parentTransform {PIXI.Transform} The transform of the parent of this object\n *\n */\n\n\nexports.default = TransformBase;\nTransformBase.prototype.updateWorldTransform = TransformBase.prototype.updateTransform;\nTransformBase.IDENTITY = new TransformBase();","map":{"version":3,"sources":["../../../src/core/display/TransformBase.js"],"names":["TransformBase","updateLocalTransform","updateTransform","parentTransform","pt","wt","lt"],"mappings":";;;;AAAA,IAAA,KAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;;;;;;AAEA;;;;;;;;IAMqBA,a;AAEjB;;;AAGA,WAAA,aAAA,GACA;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,aAAA,CAAA;AACI;;;;;;;AAKA,SAAA,cAAA,GAAsB,IAAA,KAAA,CAAtB,MAAsB,EAAtB;AAEA;;;;;;AAKA,SAAA,cAAA,GAAsB,IAAA,KAAA,CAAtB,MAAsB,EAAtB;AAEA,SAAA,QAAA,GAAA,CAAA;AACA,SAAA,SAAA,GAAA,CAAA;AACH;AAED;;;;;0BAGAC,oB,mCACA,CAEC,C,CADG;;AAGJ;;;;;;;0BAKAC,e,4BAAgBC,e,EAChB;AACI,QAAMC,EAAAA,GAAKD,eAAAA,CAAX,cAAA;AACA,QAAME,EAAAA,GAAK,KAAX,cAAA;AACA,QAAMC,EAAAA,GAAK,KAAX,cAAA,CAHJ,CAKI;;AACAD,IAAAA,EAAAA,CAAAA,CAAAA,GAAQC,EAAAA,CAAAA,CAAAA,GAAOF,EAAAA,CAAR,CAACE,GAAgBA,EAAAA,CAAAA,CAAAA,GAAOF,EAAAA,CAA/BC,CAAAA;AACAA,IAAAA,EAAAA,CAAAA,CAAAA,GAAQC,EAAAA,CAAAA,CAAAA,GAAOF,EAAAA,CAAR,CAACE,GAAgBA,EAAAA,CAAAA,CAAAA,GAAOF,EAAAA,CAA/BC,CAAAA;AACAA,IAAAA,EAAAA,CAAAA,CAAAA,GAAQC,EAAAA,CAAAA,CAAAA,GAAOF,EAAAA,CAAR,CAACE,GAAgBA,EAAAA,CAAAA,CAAAA,GAAOF,EAAAA,CAA/BC,CAAAA;AACAA,IAAAA,EAAAA,CAAAA,CAAAA,GAAQC,EAAAA,CAAAA,CAAAA,GAAOF,EAAAA,CAAR,CAACE,GAAgBA,EAAAA,CAAAA,CAAAA,GAAOF,EAAAA,CAA/BC,CAAAA;AACAA,IAAAA,EAAAA,CAAAA,EAAAA,GAASC,EAAAA,CAAAA,EAAAA,GAAQF,EAAAA,CAAT,CAACE,GAAiBA,EAAAA,CAAAA,EAAAA,GAAQF,EAAAA,CAA1B,CAACE,GAAiCF,EAAAA,CAA1CC,EAAAA;AACAA,IAAAA,EAAAA,CAAAA,EAAAA,GAASC,EAAAA,CAAAA,EAAAA,GAAQF,EAAAA,CAAT,CAACE,GAAiBA,EAAAA,CAAAA,EAAAA,GAAQF,EAAAA,CAA1B,CAACE,GAAiCF,EAAAA,CAA1CC,EAAAA;AAEA,SAAA,QAAA;;;;;AAKR;;;;;;;kBAzDqBL,a;AA8DrBA,aAAAA,CAAAA,SAAAA,CAAAA,oBAAAA,GAA+CA,aAAAA,CAAAA,SAAAA,CAA/CA,eAAAA;AAEAA,aAAAA,CAAAA,QAAAA,GAAyB,IAAzBA,aAAyB,EAAzBA","sourcesContent":["import { Matrix } from '../math';\n\n/**\n * Generic class to deal with traditional 2D matrix transforms\n *\n * @class\n * @memberof PIXI\n */\nexport default class TransformBase\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        /**\n         * The global matrix transform. It can be swapped temporarily by some functions like getLocalBounds()\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.worldTransform = new Matrix();\n\n        /**\n         * The local matrix transform\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.localTransform = new Matrix();\n\n        this._worldID = 0;\n        this._parentID = 0;\n    }\n\n    /**\n     * TransformBase does not have decomposition, so this function wont do anything\n     */\n    updateLocalTransform()\n    {\n        // empty\n    }\n\n    /**\n     * Updates the values of the object and applies the parent's transform.\n     *\n     * @param {PIXI.TransformBase} parentTransform - The transform of the parent of this object\n     */\n    updateTransform(parentTransform)\n    {\n        const pt = parentTransform.worldTransform;\n        const wt = this.worldTransform;\n        const lt = this.localTransform;\n\n        // concat the parent matrix with the objects transform.\n        wt.a = (lt.a * pt.a) + (lt.b * pt.c);\n        wt.b = (lt.a * pt.b) + (lt.b * pt.d);\n        wt.c = (lt.c * pt.a) + (lt.d * pt.c);\n        wt.d = (lt.c * pt.b) + (lt.d * pt.d);\n        wt.tx = (lt.tx * pt.a) + (lt.ty * pt.c) + pt.tx;\n        wt.ty = (lt.tx * pt.b) + (lt.ty * pt.d) + pt.ty;\n\n        this._worldID ++;\n    }\n\n}\n\n/**\n * Updates the values of the object and applies the parent's transform.\n * @param  parentTransform {PIXI.Transform} The transform of the parent of this object\n *\n */\nTransformBase.prototype.updateWorldTransform = TransformBase.prototype.updateTransform;\n\nTransformBase.IDENTITY = new TransformBase();\n"]},"metadata":{},"sourceType":"script"}