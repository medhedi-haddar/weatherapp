{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.default = buildCircle;\n\nvar _buildLine = require('./buildLine');\n\nvar _buildLine2 = _interopRequireDefault(_buildLine);\n\nvar _const = require('../../../const');\n\nvar _utils = require('../../../utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the webGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines\n */\n\n\nfunction buildCircle(graphicsData, webGLData, webGLDataNativeLines) {\n  // need to convert points to a nice regular data\n  var circleData = graphicsData.shape;\n  var x = circleData.x;\n  var y = circleData.y;\n  var width = void 0;\n  var height = void 0; // TODO - bit hacky??\n\n  if (graphicsData.type === _const.SHAPES.CIRC) {\n    width = circleData.radius;\n    height = circleData.radius;\n  } else {\n    width = circleData.width;\n    height = circleData.height;\n  }\n\n  if (width === 0 || height === 0) {\n    return;\n  }\n\n  var totalSegs = Math.floor(30 * Math.sqrt(circleData.radius)) || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));\n  var seg = Math.PI * 2 / totalSegs;\n\n  if (graphicsData.fill) {\n    var color = (0, _utils.hex2rgb)(graphicsData.fillColor);\n    var alpha = graphicsData.fillAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n    var vecPos = verts.length / 6;\n    indices.push(vecPos);\n\n    for (var i = 0; i < totalSegs + 1; i++) {\n      verts.push(x, y, r, g, b, alpha);\n      verts.push(x + Math.sin(seg * i) * width, y + Math.cos(seg * i) * height, r, g, b, alpha);\n      indices.push(vecPos++, vecPos++);\n    }\n\n    indices.push(vecPos - 1);\n  }\n\n  if (graphicsData.lineWidth) {\n    var tempPoints = graphicsData.points;\n    graphicsData.points = [];\n\n    for (var _i = 0; _i < totalSegs; _i++) {\n      graphicsData.points.push(x + Math.sin(seg * -_i) * width, y + Math.cos(seg * -_i) * height);\n    }\n\n    graphicsData.points.push(graphicsData.points[0], graphicsData.points[1]);\n    (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);\n    graphicsData.points = tempPoints;\n  }\n}","map":{"version":3,"sources":["../../../../../src/core/graphics/webgl/utils/buildCircle.js"],"names":["buildCircle","circleData","graphicsData","x","y","width","height","totalSegs","Math","seg","color","alpha","r","g","b","verts","webGLData","indices","vecPos","i","tempPoints"],"mappings":";;;kBAewBA,W;;AAfxB,IAAA,UAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;;;;;;AAEA;;;;;;;;;;;;;AAWe,SAAA,WAAA,CAAA,YAAA,EAAA,SAAA,EAAA,oBAAA,EACf;AACI;AACA,MAAMC,UAAAA,GAAaC,YAAAA,CAAnB,KAAA;AACA,MAAMC,CAAAA,GAAIF,UAAAA,CAAV,CAAA;AACA,MAAMG,CAAAA,GAAIH,UAAAA,CAAV,CAAA;AACA,MAAII,KAAAA,GAAAA,KAAJ,CAAA;AACA,MAAIC,MAAAA,GAAAA,KAAJ,CAAA,CANJ,CAQI;;AACA,MAAIJ,YAAAA,CAAAA,IAAAA,KAAsB,MAAA,CAAA,MAAA,CAA1B,IAAA,EACA;AACIG,IAAAA,KAAAA,GAAQJ,UAAAA,CAARI,MAAAA;AACAC,IAAAA,MAAAA,GAASL,UAAAA,CAATK,MAAAA;AAHJ,GAAA,MAMA;AACID,IAAAA,KAAAA,GAAQJ,UAAAA,CAARI,KAAAA;AACAC,IAAAA,MAAAA,GAASL,UAAAA,CAATK,MAAAA;AACH;;AAED,MAAID,KAAAA,KAAAA,CAAAA,IAAeC,MAAAA,KAAnB,CAAA,EACA;AACI;AACH;;AAED,MAAMC,SAAAA,GAAYC,IAAAA,CAAAA,KAAAA,CAAW,KAAKA,IAAAA,CAAAA,IAAAA,CAAUP,UAAAA,CAA1BO,MAAgBA,CAAhBA,KACXA,IAAAA,CAAAA,KAAAA,CAAW,KAAKA,IAAAA,CAAAA,IAAAA,CAAUP,UAAAA,CAAAA,KAAAA,GAAmBA,UAAAA,CADpD,MACuBO,CAAhBA,CADP;AAGA,MAAMC,GAAAA,GAAOD,IAAAA,CAAAA,EAAAA,GAAD,CAACA,GAAb,SAAA;;AAEA,MAAIN,YAAAA,CAAJ,IAAA,EACA;AACI,QAAMQ,KAAAA,GAAQ,CAAA,GAAA,MAAA,CAAA,OAAA,EAAQR,YAAAA,CAAtB,SAAc,CAAd;AACA,QAAMS,KAAAA,GAAQT,YAAAA,CAAd,SAAA;AAEA,QAAMU,CAAAA,GAAIF,KAAAA,CAAAA,CAAAA,CAAAA,GAAV,KAAA;AACA,QAAMG,CAAAA,GAAIH,KAAAA,CAAAA,CAAAA,CAAAA,GAAV,KAAA;AACA,QAAMI,CAAAA,GAAIJ,KAAAA,CAAAA,CAAAA,CAAAA,GAAV,KAAA;AAEA,QAAMK,KAAAA,GAAQC,SAAAA,CAAd,MAAA;AACA,QAAMC,OAAAA,GAAUD,SAAAA,CAAhB,OAAA;AAEA,QAAIE,MAAAA,GAASH,KAAAA,CAAAA,MAAAA,GAAb,CAAA;AAEAE,IAAAA,OAAAA,CAAAA,IAAAA,CAAAA,MAAAA;;AAEA,SAAK,IAAIE,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAIZ,SAAAA,GAApB,CAAA,EAAmCY,CAAnC,EAAA,EACA;AACIJ,MAAAA,KAAAA,CAAAA,IAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,KAAAA;AAEAA,MAAAA,KAAAA,CAAAA,IAAAA,CACIZ,CAAAA,GAAKK,IAAAA,CAAAA,GAAAA,CAASC,GAAAA,GAATD,CAAAA,IADTO,KAAAA,EAEIX,CAAAA,GAAKI,IAAAA,CAAAA,GAAAA,CAASC,GAAAA,GAATD,CAAAA,IAFTO,MAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA,KAAAA;AAMAE,MAAAA,OAAAA,CAAAA,IAAAA,CAAaC,MAAbD,EAAAA,EAAuBC,MAAvBD,EAAAA;AACH;;AAEDA,IAAAA,OAAAA,CAAAA,IAAAA,CAAaC,MAAAA,GAAbD,CAAAA;AACH;;AAED,MAAIf,YAAAA,CAAJ,SAAA,EACA;AACI,QAAMkB,UAAAA,GAAalB,YAAAA,CAAnB,MAAA;AAEAA,IAAAA,YAAAA,CAAAA,MAAAA,GAAAA,EAAAA;;AAEA,SAAK,IAAIiB,EAAAA,GAAT,CAAA,EAAgBA,EAAAA,GAAhB,SAAA,EAA+BA,EAA/B,EAAA,EACA;AACIjB,MAAAA,YAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CACIC,CAAAA,GAAKK,IAAAA,CAAAA,GAAAA,CAASC,GAAAA,GAAM,CAAfD,EAAAA,IADTN,KAAAA,EAEIE,CAAAA,GAAKI,IAAAA,CAAAA,GAAAA,CAASC,GAAAA,GAAM,CAAfD,EAAAA,IAFTN,MAAAA;AAIH;;AAEDA,IAAAA,YAAAA,CAAAA,MAAAA,CAAAA,IAAAA,CACIA,YAAAA,CAAAA,MAAAA,CADJA,CACIA,CADJA,EAEIA,YAAAA,CAAAA,MAAAA,CAFJA,CAEIA,CAFJA;AAKA,KAAA,GAAA,WAAA,CAAA,OAAA,EAAA,YAAA,EAAA,SAAA,EAAA,oBAAA;AAEAA,IAAAA,YAAAA,CAAAA,MAAAA,GAAAA,UAAAA;AACH;AACJ","sourcesContent":["import buildLine from './buildLine';\nimport { SHAPES } from '../../../const';\nimport { hex2rgb } from '../../../utils';\n\n/**\n * Builds a circle to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object to draw\n * @param {object} webGLData - an object containing all the webGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines\n */\nexport default function buildCircle(graphicsData, webGLData, webGLDataNativeLines)\n{\n    // need to convert points to a nice regular data\n    const circleData = graphicsData.shape;\n    const x = circleData.x;\n    const y = circleData.y;\n    let width;\n    let height;\n\n    // TODO - bit hacky??\n    if (graphicsData.type === SHAPES.CIRC)\n    {\n        width = circleData.radius;\n        height = circleData.radius;\n    }\n    else\n    {\n        width = circleData.width;\n        height = circleData.height;\n    }\n\n    if (width === 0 || height === 0)\n    {\n        return;\n    }\n\n    const totalSegs = Math.floor(30 * Math.sqrt(circleData.radius))\n        || Math.floor(15 * Math.sqrt(circleData.width + circleData.height));\n\n    const seg = (Math.PI * 2) / totalSegs;\n\n    if (graphicsData.fill)\n    {\n        const color = hex2rgb(graphicsData.fillColor);\n        const alpha = graphicsData.fillAlpha;\n\n        const r = color[0] * alpha;\n        const g = color[1] * alpha;\n        const b = color[2] * alpha;\n\n        const verts = webGLData.points;\n        const indices = webGLData.indices;\n\n        let vecPos = verts.length / 6;\n\n        indices.push(vecPos);\n\n        for (let i = 0; i < totalSegs + 1; i++)\n        {\n            verts.push(x, y, r, g, b, alpha);\n\n            verts.push(\n                x + (Math.sin(seg * i) * width),\n                y + (Math.cos(seg * i) * height),\n                r, g, b, alpha\n            );\n\n            indices.push(vecPos++, vecPos++);\n        }\n\n        indices.push(vecPos - 1);\n    }\n\n    if (graphicsData.lineWidth)\n    {\n        const tempPoints = graphicsData.points;\n\n        graphicsData.points = [];\n\n        for (let i = 0; i < totalSegs; i++)\n        {\n            graphicsData.points.push(\n                x + (Math.sin(seg * -i) * width),\n                y + (Math.cos(seg * -i) * height)\n            );\n        }\n\n        graphicsData.points.push(\n            graphicsData.points[0],\n            graphicsData.points[1]\n        );\n\n        buildLine(graphicsData, webGLData, webGLDataNativeLines);\n\n        graphicsData.points = tempPoints;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}