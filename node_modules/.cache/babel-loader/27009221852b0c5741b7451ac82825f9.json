{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _pixiGlCore = require('pixi-gl-core');\n\nvar _const = require('../../const');\n\nvar _RenderTarget = require('./utils/RenderTarget');\n\nvar _RenderTarget2 = _interopRequireDefault(_RenderTarget);\n\nvar _utils = require('../../utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Helper class to create a webGL Texture\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar TextureManager = function () {\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer\n   */\n  function TextureManager(renderer) {\n    _classCallCheck(this, TextureManager);\n    /**\n     * A reference to the current renderer\n     *\n     * @member {PIXI.WebGLRenderer}\n     */\n\n\n    this.renderer = renderer;\n    /**\n     * The current WebGL rendering context\n     *\n     * @member {WebGLRenderingContext}\n     */\n\n    this.gl = renderer.gl;\n    /**\n     * Track textures in the renderer so we can no longer listen to them on destruction.\n     *\n     * @member {Array<*>}\n     * @private\n     */\n\n    this._managedTextures = [];\n  }\n  /**\n   * Binds a texture.\n   *\n   */\n\n\n  TextureManager.prototype.bindTexture = function bindTexture() {} // empty\n\n  /**\n   * Gets a texture.\n   *\n   */\n  ;\n\n  TextureManager.prototype.getTexture = function getTexture() {} // empty\n\n  /**\n   * Updates and/or Creates a WebGL texture for the renderer's context.\n   *\n   * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to update\n   * @param {number} location - the location the texture will be bound to.\n   * @return {GLTexture} The gl texture.\n   */\n  ;\n\n  TextureManager.prototype.updateTexture = function updateTexture(texture, location) {\n    // assume it good!\n    // texture = texture.baseTexture || texture;\n    var gl = this.gl;\n    var isRenderTexture = !!texture._glRenderTargets;\n\n    if (!texture.hasLoaded) {\n      return null;\n    }\n\n    var boundTextures = this.renderer.boundTextures; // if the location is undefined then this may have been called by n event.\n    // this being the case the texture may already be bound to a slot. As a texture can only be bound once\n    // we need to find its current location if it exists.\n\n    if (location === undefined) {\n      location = 0; // TODO maybe we can use texture bound ids later on...\n      // check if texture is already bound..\n\n      for (var i = 0; i < boundTextures.length; ++i) {\n        if (boundTextures[i] === texture) {\n          location = i;\n          break;\n        }\n      }\n    }\n\n    boundTextures[location] = texture;\n    gl.activeTexture(gl.TEXTURE0 + location);\n    var glTexture = texture._glTextures[this.renderer.CONTEXT_UID];\n\n    if (!glTexture) {\n      if (isRenderTexture) {\n        var renderTarget = new _RenderTarget2.default(this.gl, texture.width, texture.height, texture.scaleMode, texture.resolution);\n        renderTarget.resize(texture.width, texture.height);\n        texture._glRenderTargets[this.renderer.CONTEXT_UID] = renderTarget;\n        glTexture = renderTarget.texture; // framebuffer constructor disactivates current framebuffer\n\n        if (!this.renderer._activeRenderTarget.root) {\n          this.renderer._activeRenderTarget.frameBuffer.bind();\n        }\n      } else {\n        glTexture = new _pixiGlCore.GLTexture(this.gl, null, null, null, null);\n        glTexture.bind(location);\n        glTexture.premultiplyAlpha = true;\n        glTexture.upload(texture.source);\n      }\n\n      texture._glTextures[this.renderer.CONTEXT_UID] = glTexture;\n      texture.on('update', this.updateTexture, this);\n      texture.on('dispose', this.destroyTexture, this);\n\n      this._managedTextures.push(texture);\n\n      if (texture.isPowerOfTwo) {\n        if (texture.mipmap) {\n          glTexture.enableMipmap();\n        }\n\n        if (texture.wrapMode === _const.WRAP_MODES.CLAMP) {\n          glTexture.enableWrapClamp();\n        } else if (texture.wrapMode === _const.WRAP_MODES.REPEAT) {\n          glTexture.enableWrapRepeat();\n        } else {\n          glTexture.enableWrapMirrorRepeat();\n        }\n      } else {\n        glTexture.enableWrapClamp();\n      }\n\n      if (texture.scaleMode === _const.SCALE_MODES.NEAREST) {\n        glTexture.enableNearestScaling();\n      } else {\n        glTexture.enableLinearScaling();\n      }\n    } // the texture already exists so we only need to update it..\n    else if (isRenderTexture) {\n      texture._glRenderTargets[this.renderer.CONTEXT_UID].resize(texture.width, texture.height);\n    } else {\n      glTexture.upload(texture.source);\n    }\n\n    return glTexture;\n  };\n  /**\n   * Deletes the texture from WebGL\n   *\n   * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy\n   * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.\n   */\n\n\n  TextureManager.prototype.destroyTexture = function destroyTexture(texture, skipRemove) {\n    texture = texture.baseTexture || texture;\n\n    if (!texture.hasLoaded) {\n      return;\n    }\n\n    var renderer = this.renderer;\n    var uid = renderer.CONTEXT_UID;\n    var glTextures = texture._glTextures;\n    var glRenderTargets = texture._glRenderTargets;\n\n    if (glTextures[uid]) {\n      renderer.unbindTexture(texture);\n      glTextures[uid].destroy();\n      texture.off('update', this.updateTexture, this);\n      texture.off('dispose', this.destroyTexture, this);\n      delete glTextures[uid];\n\n      if (!skipRemove) {\n        var i = this._managedTextures.indexOf(texture);\n\n        if (i !== -1) {\n          (0, _utils.removeItems)(this._managedTextures, i, 1);\n        }\n      }\n    }\n\n    if (glRenderTargets && glRenderTargets[uid]) {\n      if (renderer._activeRenderTarget === glRenderTargets[uid]) {\n        renderer.bindRenderTarget(renderer.rootRenderTarget);\n      }\n\n      glRenderTargets[uid].destroy();\n      delete glRenderTargets[uid];\n    }\n  };\n  /**\n   * Deletes all the textures from WebGL\n   */\n\n\n  TextureManager.prototype.removeAll = function removeAll() {\n    // empty all the old gl textures as they are useless now\n    for (var i = 0; i < this._managedTextures.length; ++i) {\n      var texture = this._managedTextures[i];\n\n      if (texture._glTextures[this.renderer.CONTEXT_UID]) {\n        delete texture._glTextures[this.renderer.CONTEXT_UID];\n      }\n    }\n  };\n  /**\n   * Destroys this manager and removes all its textures\n   */\n\n\n  TextureManager.prototype.destroy = function destroy() {\n    // destroy managed textures\n    for (var i = 0; i < this._managedTextures.length; ++i) {\n      var texture = this._managedTextures[i];\n      this.destroyTexture(texture, true);\n      texture.off('update', this.updateTexture, this);\n      texture.off('dispose', this.destroyTexture, this);\n    }\n\n    this._managedTextures = null;\n  };\n\n  return TextureManager;\n}();\n\nexports.default = TextureManager;","map":{"version":3,"sources":["../../../../src/core/renderers/webgl/TextureManager.js"],"names":["TextureManager","renderer","bindTexture","getTexture","updateTexture","texture","location","gl","isRenderTexture","boundTextures","i","glTexture","renderTarget","destroyTexture","skipRemove","uid","glTextures","glRenderTargets","removeAll","destroy"],"mappings":"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","sourcesContent":["import { GLTexture } from 'pixi-gl-core';\nimport { WRAP_MODES, SCALE_MODES } from '../../const';\nimport RenderTarget from './utils/RenderTarget';\nimport { removeItems } from '../../utils';\n\n/**\n * Helper class to create a webGL Texture\n *\n * @class\n * @memberof PIXI\n */\nexport default class TextureManager\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        /**\n         * A reference to the current renderer\n         *\n         * @member {PIXI.WebGLRenderer}\n         */\n        this.renderer = renderer;\n\n        /**\n         * The current WebGL rendering context\n         *\n         * @member {WebGLRenderingContext}\n         */\n        this.gl = renderer.gl;\n\n        /**\n         * Track textures in the renderer so we can no longer listen to them on destruction.\n         *\n         * @member {Array<*>}\n         * @private\n         */\n        this._managedTextures = [];\n    }\n\n    /**\n     * Binds a texture.\n     *\n     */\n    bindTexture()\n    {\n        // empty\n    }\n\n    /**\n     * Gets a texture.\n     *\n     */\n    getTexture()\n    {\n        // empty\n    }\n\n    /**\n     * Updates and/or Creates a WebGL texture for the renderer's context.\n     *\n     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to update\n     * @param {number} location - the location the texture will be bound to.\n     * @return {GLTexture} The gl texture.\n     */\n    updateTexture(texture, location)\n    {\n        // assume it good!\n        // texture = texture.baseTexture || texture;\n\n        const gl = this.gl;\n\n        const isRenderTexture = !!texture._glRenderTargets;\n\n        if (!texture.hasLoaded)\n        {\n            return null;\n        }\n\n        const boundTextures = this.renderer.boundTextures;\n\n        // if the location is undefined then this may have been called by n event.\n        // this being the case the texture may already be bound to a slot. As a texture can only be bound once\n        // we need to find its current location if it exists.\n        if (location === undefined)\n        {\n            location = 0;\n\n            // TODO maybe we can use texture bound ids later on...\n            // check if texture is already bound..\n            for (let i = 0; i < boundTextures.length; ++i)\n            {\n                if (boundTextures[i] === texture)\n                {\n                    location = i;\n                    break;\n                }\n            }\n        }\n\n        boundTextures[location] = texture;\n\n        gl.activeTexture(gl.TEXTURE0 + location);\n\n        let glTexture = texture._glTextures[this.renderer.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            if (isRenderTexture)\n            {\n                const renderTarget = new RenderTarget(\n                    this.gl,\n                    texture.width,\n                    texture.height,\n                    texture.scaleMode,\n                    texture.resolution\n                );\n\n                renderTarget.resize(texture.width, texture.height);\n                texture._glRenderTargets[this.renderer.CONTEXT_UID] = renderTarget;\n                glTexture = renderTarget.texture;\n\n                // framebuffer constructor disactivates current framebuffer\n                if (!this.renderer._activeRenderTarget.root)\n                {\n                    this.renderer._activeRenderTarget.frameBuffer.bind();\n                }\n            }\n            else\n            {\n                glTexture = new GLTexture(this.gl, null, null, null, null);\n                glTexture.bind(location);\n                glTexture.premultiplyAlpha = true;\n                glTexture.upload(texture.source);\n            }\n\n            texture._glTextures[this.renderer.CONTEXT_UID] = glTexture;\n\n            texture.on('update', this.updateTexture, this);\n            texture.on('dispose', this.destroyTexture, this);\n\n            this._managedTextures.push(texture);\n\n            if (texture.isPowerOfTwo)\n            {\n                if (texture.mipmap)\n                {\n                    glTexture.enableMipmap();\n                }\n\n                if (texture.wrapMode === WRAP_MODES.CLAMP)\n                {\n                    glTexture.enableWrapClamp();\n                }\n                else if (texture.wrapMode === WRAP_MODES.REPEAT)\n                {\n                    glTexture.enableWrapRepeat();\n                }\n                else\n                {\n                    glTexture.enableWrapMirrorRepeat();\n                }\n            }\n            else\n            {\n                glTexture.enableWrapClamp();\n            }\n\n            if (texture.scaleMode === SCALE_MODES.NEAREST)\n            {\n                glTexture.enableNearestScaling();\n            }\n            else\n            {\n                glTexture.enableLinearScaling();\n            }\n        }\n        // the texture already exists so we only need to update it..\n        else if (isRenderTexture)\n        {\n            texture._glRenderTargets[this.renderer.CONTEXT_UID].resize(texture.width, texture.height);\n        }\n        else\n        {\n            glTexture.upload(texture.source);\n        }\n\n        return glTexture;\n    }\n\n    /**\n     * Deletes the texture from WebGL\n     *\n     * @param {PIXI.BaseTexture|PIXI.Texture} texture - the texture to destroy\n     * @param {boolean} [skipRemove=false] - Whether to skip removing the texture from the TextureManager.\n     */\n    destroyTexture(texture, skipRemove)\n    {\n        texture = texture.baseTexture || texture;\n\n        if (!texture.hasLoaded)\n        {\n            return;\n        }\n\n        const renderer = this.renderer;\n        const uid = renderer.CONTEXT_UID;\n        const glTextures = texture._glTextures;\n        const glRenderTargets = texture._glRenderTargets;\n\n        if (glTextures[uid])\n        {\n            renderer.unbindTexture(texture);\n\n            glTextures[uid].destroy();\n            texture.off('update', this.updateTexture, this);\n            texture.off('dispose', this.destroyTexture, this);\n\n            delete glTextures[uid];\n\n            if (!skipRemove)\n            {\n                const i = this._managedTextures.indexOf(texture);\n\n                if (i !== -1)\n                {\n                    removeItems(this._managedTextures, i, 1);\n                }\n            }\n        }\n\n        if (glRenderTargets && glRenderTargets[uid])\n        {\n            if (renderer._activeRenderTarget === glRenderTargets[uid])\n            {\n                renderer.bindRenderTarget(renderer.rootRenderTarget);\n            }\n\n            glRenderTargets[uid].destroy();\n            delete glRenderTargets[uid];\n        }\n    }\n\n    /**\n     * Deletes all the textures from WebGL\n     */\n    removeAll()\n    {\n        // empty all the old gl textures as they are useless now\n        for (let i = 0; i < this._managedTextures.length; ++i)\n        {\n            const texture = this._managedTextures[i];\n\n            if (texture._glTextures[this.renderer.CONTEXT_UID])\n            {\n                delete texture._glTextures[this.renderer.CONTEXT_UID];\n            }\n        }\n    }\n\n    /**\n     * Destroys this manager and removes all its textures\n     */\n    destroy()\n    {\n        // destroy managed textures\n        for (let i = 0; i < this._managedTextures.length; ++i)\n        {\n            const texture = this._managedTextures[i];\n\n            this.destroyTexture(texture, true);\n\n            texture.off('update', this.updateTexture, this);\n            texture.off('dispose', this.destroyTexture, this);\n        }\n\n        this._managedTextures = null;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}