{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _Point = require('./Point');\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _const = require('../const');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * The PixiJS Matrix class as an object, which makes it a lot faster,\n * here is a representation of it :\n * | a | c | tx|\n * | b | d | ty|\n * | 0 | 0 | 1 |\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar Matrix = function () {\n  /**\n   * @param {number} [a=1] - x scale\n   * @param {number} [b=0] - x skew\n   * @param {number} [c=0] - y skew\n   * @param {number} [d=1] - y scale\n   * @param {number} [tx=0] - x translation\n   * @param {number} [ty=0] - y translation\n   */\n  function Matrix() {\n    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    var tx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    var ty = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n    _classCallCheck(this, Matrix);\n    /**\n     * @member {number}\n     * @default 1\n     */\n\n\n    this.a = a;\n    /**\n     * @member {number}\n     * @default 0\n     */\n\n    this.b = b;\n    /**\n     * @member {number}\n     * @default 0\n     */\n\n    this.c = c;\n    /**\n     * @member {number}\n     * @default 1\n     */\n\n    this.d = d;\n    /**\n     * @member {number}\n     * @default 0\n     */\n\n    this.tx = tx;\n    /**\n     * @member {number}\n     * @default 0\n     */\n\n    this.ty = ty;\n    this.array = null;\n  }\n  /**\n   * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n   *\n   * a = array[0]\n   * b = array[1]\n   * c = array[3]\n   * d = array[4]\n   * tx = array[2]\n   * ty = array[5]\n   *\n   * @param {number[]} array - The array that the matrix will be populated from.\n   */\n\n\n  Matrix.prototype.fromArray = function fromArray(array) {\n    this.a = array[0];\n    this.b = array[1];\n    this.c = array[3];\n    this.d = array[4];\n    this.tx = array[2];\n    this.ty = array[5];\n  };\n  /**\n   * sets the matrix properties\n   *\n   * @param {number} a - Matrix component\n   * @param {number} b - Matrix component\n   * @param {number} c - Matrix component\n   * @param {number} d - Matrix component\n   * @param {number} tx - Matrix component\n   * @param {number} ty - Matrix component\n   *\n   * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n   */\n\n\n  Matrix.prototype.set = function set(a, b, c, d, tx, ty) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.d = d;\n    this.tx = tx;\n    this.ty = ty;\n    return this;\n  };\n  /**\n   * Creates an array from the current Matrix object.\n   *\n   * @param {boolean} transpose - Whether we need to transpose the matrix or not\n   * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out\n   * @return {number[]} the newly created array which contains the matrix\n   */\n\n\n  Matrix.prototype.toArray = function toArray(transpose, out) {\n    if (!this.array) {\n      this.array = new Float32Array(9);\n    }\n\n    var array = out || this.array;\n\n    if (transpose) {\n      array[0] = this.a;\n      array[1] = this.b;\n      array[2] = 0;\n      array[3] = this.c;\n      array[4] = this.d;\n      array[5] = 0;\n      array[6] = this.tx;\n      array[7] = this.ty;\n      array[8] = 1;\n    } else {\n      array[0] = this.a;\n      array[1] = this.c;\n      array[2] = this.tx;\n      array[3] = this.b;\n      array[4] = this.d;\n      array[5] = this.ty;\n      array[6] = 0;\n      array[7] = 0;\n      array[8] = 1;\n    }\n\n    return array;\n  };\n  /**\n   * Get a new position with the current transformation applied.\n   * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n   *\n   * @param {PIXI.Point} pos - The origin\n   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @return {PIXI.Point} The new point, transformed through this matrix\n   */\n\n\n  Matrix.prototype.apply = function apply(pos, newPos) {\n    newPos = newPos || new _Point2.default();\n    var x = pos.x;\n    var y = pos.y;\n    newPos.x = this.a * x + this.c * y + this.tx;\n    newPos.y = this.b * x + this.d * y + this.ty;\n    return newPos;\n  };\n  /**\n   * Get a new position with the inverse of the current transformation applied.\n   * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n   *\n   * @param {PIXI.Point} pos - The origin\n   * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n   * @return {PIXI.Point} The new point, inverse-transformed through this matrix\n   */\n\n\n  Matrix.prototype.applyInverse = function applyInverse(pos, newPos) {\n    newPos = newPos || new _Point2.default();\n    var id = 1 / (this.a * this.d + this.c * -this.b);\n    var x = pos.x;\n    var y = pos.y;\n    newPos.x = this.d * id * x + -this.c * id * y + (this.ty * this.c - this.tx * this.d) * id;\n    newPos.y = this.a * id * y + -this.b * id * x + (-this.ty * this.a + this.tx * this.b) * id;\n    return newPos;\n  };\n  /**\n   * Translates the matrix on the x and y.\n   *\n   * @param {number} x How much to translate x by\n   * @param {number} y How much to translate y by\n   * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n   */\n\n\n  Matrix.prototype.translate = function translate(x, y) {\n    this.tx += x;\n    this.ty += y;\n    return this;\n  };\n  /**\n   * Applies a scale transformation to the matrix.\n   *\n   * @param {number} x The amount to scale horizontally\n   * @param {number} y The amount to scale vertically\n   * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n   */\n\n\n  Matrix.prototype.scale = function scale(x, y) {\n    this.a *= x;\n    this.d *= y;\n    this.c *= x;\n    this.b *= y;\n    this.tx *= x;\n    this.ty *= y;\n    return this;\n  };\n  /**\n   * Applies a rotation transformation to the matrix.\n   *\n   * @param {number} angle - The angle in radians.\n   * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n   */\n\n\n  Matrix.prototype.rotate = function rotate(angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    var a1 = this.a;\n    var c1 = this.c;\n    var tx1 = this.tx;\n    this.a = a1 * cos - this.b * sin;\n    this.b = a1 * sin + this.b * cos;\n    this.c = c1 * cos - this.d * sin;\n    this.d = c1 * sin + this.d * cos;\n    this.tx = tx1 * cos - this.ty * sin;\n    this.ty = tx1 * sin + this.ty * cos;\n    return this;\n  };\n  /**\n   * Appends the given Matrix to this Matrix.\n   *\n   * @param {PIXI.Matrix} matrix - The matrix to append.\n   * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n   */\n\n\n  Matrix.prototype.append = function append(matrix) {\n    var a1 = this.a;\n    var b1 = this.b;\n    var c1 = this.c;\n    var d1 = this.d;\n    this.a = matrix.a * a1 + matrix.b * c1;\n    this.b = matrix.a * b1 + matrix.b * d1;\n    this.c = matrix.c * a1 + matrix.d * c1;\n    this.d = matrix.c * b1 + matrix.d * d1;\n    this.tx = matrix.tx * a1 + matrix.ty * c1 + this.tx;\n    this.ty = matrix.tx * b1 + matrix.ty * d1 + this.ty;\n    return this;\n  };\n  /**\n   * Sets the matrix based on all the available properties\n   *\n   * @param {number} x - Position on the x axis\n   * @param {number} y - Position on the y axis\n   * @param {number} pivotX - Pivot on the x axis\n   * @param {number} pivotY - Pivot on the y axis\n   * @param {number} scaleX - Scale on the x axis\n   * @param {number} scaleY - Scale on the y axis\n   * @param {number} rotation - Rotation in radians\n   * @param {number} skewX - Skew on the x axis\n   * @param {number} skewY - Skew on the y axis\n   * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n   */\n\n\n  Matrix.prototype.setTransform = function setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY) {\n    this.a = Math.cos(rotation + skewY) * scaleX;\n    this.b = Math.sin(rotation + skewY) * scaleX;\n    this.c = -Math.sin(rotation - skewX) * scaleY;\n    this.d = Math.cos(rotation - skewX) * scaleY;\n    this.tx = x - (pivotX * this.a + pivotY * this.c);\n    this.ty = y - (pivotX * this.b + pivotY * this.d);\n    return this;\n  };\n  /**\n   * Prepends the given Matrix to this Matrix.\n   *\n   * @param {PIXI.Matrix} matrix - The matrix to prepend\n   * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n   */\n\n\n  Matrix.prototype.prepend = function prepend(matrix) {\n    var tx1 = this.tx;\n\n    if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1) {\n      var a1 = this.a;\n      var c1 = this.c;\n      this.a = a1 * matrix.a + this.b * matrix.c;\n      this.b = a1 * matrix.b + this.b * matrix.d;\n      this.c = c1 * matrix.a + this.d * matrix.c;\n      this.d = c1 * matrix.b + this.d * matrix.d;\n    }\n\n    this.tx = tx1 * matrix.a + this.ty * matrix.c + matrix.tx;\n    this.ty = tx1 * matrix.b + this.ty * matrix.d + matrix.ty;\n    return this;\n  };\n  /**\n   * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n   *\n   * @param {PIXI.Transform|PIXI.TransformStatic} transform - The transform to apply the properties to.\n   * @return {PIXI.Transform|PIXI.TransformStatic} The transform with the newly applied properties\n   */\n\n\n  Matrix.prototype.decompose = function decompose(transform) {\n    // sort out rotation / skew..\n    var a = this.a;\n    var b = this.b;\n    var c = this.c;\n    var d = this.d;\n    var skewX = -Math.atan2(-c, d);\n    var skewY = Math.atan2(b, a);\n    var delta = Math.abs(skewX + skewY);\n\n    if (delta < 0.00001 || Math.abs(_const.PI_2 - delta) < 0.00001) {\n      transform.rotation = skewY;\n      transform.skew.x = transform.skew.y = 0;\n    } else {\n      transform.rotation = 0;\n      transform.skew.x = skewX;\n      transform.skew.y = skewY;\n    } // next set scale\n\n\n    transform.scale.x = Math.sqrt(a * a + b * b);\n    transform.scale.y = Math.sqrt(c * c + d * d); // next set position\n\n    transform.position.x = this.tx;\n    transform.position.y = this.ty;\n    return transform;\n  };\n  /**\n   * Inverts this matrix\n   *\n   * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n   */\n\n\n  Matrix.prototype.invert = function invert() {\n    var a1 = this.a;\n    var b1 = this.b;\n    var c1 = this.c;\n    var d1 = this.d;\n    var tx1 = this.tx;\n    var n = a1 * d1 - b1 * c1;\n    this.a = d1 / n;\n    this.b = -b1 / n;\n    this.c = -c1 / n;\n    this.d = a1 / n;\n    this.tx = (c1 * this.ty - d1 * tx1) / n;\n    this.ty = -(a1 * this.ty - b1 * tx1) / n;\n    return this;\n  };\n  /**\n   * Resets this Matix to an identity (default) matrix.\n   *\n   * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n   */\n\n\n  Matrix.prototype.identity = function identity() {\n    this.a = 1;\n    this.b = 0;\n    this.c = 0;\n    this.d = 1;\n    this.tx = 0;\n    this.ty = 0;\n    return this;\n  };\n  /**\n   * Creates a new Matrix object with the same values as this one.\n   *\n   * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.\n   */\n\n\n  Matrix.prototype.clone = function clone() {\n    var matrix = new Matrix();\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  };\n  /**\n   * Changes the values of the given matrix to be the same as the ones in this matrix\n   *\n   * @param {PIXI.Matrix} matrix - The matrix to copy from.\n   * @return {PIXI.Matrix} The matrix given in parameter with its values updated.\n   */\n\n\n  Matrix.prototype.copy = function copy(matrix) {\n    matrix.a = this.a;\n    matrix.b = this.b;\n    matrix.c = this.c;\n    matrix.d = this.d;\n    matrix.tx = this.tx;\n    matrix.ty = this.ty;\n    return matrix;\n  };\n  /**\n   * A default (identity) matrix\n   *\n   * @static\n   * @const\n   */\n\n\n  _createClass(Matrix, null, [{\n    key: 'IDENTITY',\n    get: function get() {\n      return new Matrix();\n    }\n    /**\n     * A temp matrix\n     *\n     * @static\n     * @const\n     */\n\n  }, {\n    key: 'TEMP_MATRIX',\n    get: function get() {\n      return new Matrix();\n    }\n  }]);\n\n  return Matrix;\n}();\n\nexports.default = Matrix;","map":{"version":3,"sources":["../../../src/core/math/Matrix.js"],"names":["Matrix","a","b","c","d","tx","ty","fromArray","array","set","toArray","transpose","out","apply","pos","newPos","x","y","applyInverse","id","translate","scale","rotate","angle","cos","Math","sin","a1","c1","tx1","append","matrix","b1","d1","setTransform","pivotX","pivotY","scaleX","scaleY","rotation","skewX","skewY","prepend","decompose","transform","delta","invert","n","identity","clone","copy"],"mappings":"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","sourcesContent":["import Point from './Point';\nimport { PI_2 } from '../const';\n\n/**\n * The PixiJS Matrix class as an object, which makes it a lot faster,\n * here is a representation of it :\n * | a | c | tx|\n * | b | d | ty|\n * | 0 | 0 | 1 |\n *\n * @class\n * @memberof PIXI\n */\nexport default class Matrix\n{\n    /**\n     * @param {number} [a=1] - x scale\n     * @param {number} [b=0] - x skew\n     * @param {number} [c=0] - y skew\n     * @param {number} [d=1] - y scale\n     * @param {number} [tx=0] - x translation\n     * @param {number} [ty=0] - y translation\n     */\n    constructor(a = 1, b = 0, c = 0, d = 1, tx = 0, ty = 0)\n    {\n        /**\n         * @member {number}\n         * @default 1\n         */\n        this.a = a;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this.b = b;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this.c = c;\n\n        /**\n         * @member {number}\n         * @default 1\n         */\n        this.d = d;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this.tx = tx;\n\n        /**\n         * @member {number}\n         * @default 0\n         */\n        this.ty = ty;\n\n        this.array = null;\n    }\n\n    /**\n     * Creates a Matrix object based on the given array. The Element to Matrix mapping order is as follows:\n     *\n     * a = array[0]\n     * b = array[1]\n     * c = array[3]\n     * d = array[4]\n     * tx = array[2]\n     * ty = array[5]\n     *\n     * @param {number[]} array - The array that the matrix will be populated from.\n     */\n    fromArray(array)\n    {\n        this.a = array[0];\n        this.b = array[1];\n        this.c = array[3];\n        this.d = array[4];\n        this.tx = array[2];\n        this.ty = array[5];\n    }\n\n    /**\n     * sets the matrix properties\n     *\n     * @param {number} a - Matrix component\n     * @param {number} b - Matrix component\n     * @param {number} c - Matrix component\n     * @param {number} d - Matrix component\n     * @param {number} tx - Matrix component\n     * @param {number} ty - Matrix component\n     *\n     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n     */\n    set(a, b, c, d, tx, ty)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n        this.tx = tx;\n        this.ty = ty;\n\n        return this;\n    }\n\n    /**\n     * Creates an array from the current Matrix object.\n     *\n     * @param {boolean} transpose - Whether we need to transpose the matrix or not\n     * @param {Float32Array} [out=new Float32Array(9)] - If provided the array will be assigned to out\n     * @return {number[]} the newly created array which contains the matrix\n     */\n    toArray(transpose, out)\n    {\n        if (!this.array)\n        {\n            this.array = new Float32Array(9);\n        }\n\n        const array = out || this.array;\n\n        if (transpose)\n        {\n            array[0] = this.a;\n            array[1] = this.b;\n            array[2] = 0;\n            array[3] = this.c;\n            array[4] = this.d;\n            array[5] = 0;\n            array[6] = this.tx;\n            array[7] = this.ty;\n            array[8] = 1;\n        }\n        else\n        {\n            array[0] = this.a;\n            array[1] = this.c;\n            array[2] = this.tx;\n            array[3] = this.b;\n            array[4] = this.d;\n            array[5] = this.ty;\n            array[6] = 0;\n            array[7] = 0;\n            array[8] = 1;\n        }\n\n        return array;\n    }\n\n    /**\n     * Get a new position with the current transformation applied.\n     * Can be used to go from a child's coordinate space to the world coordinate space. (e.g. rendering)\n     *\n     * @param {PIXI.Point} pos - The origin\n     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @return {PIXI.Point} The new point, transformed through this matrix\n     */\n    apply(pos, newPos)\n    {\n        newPos = newPos || new Point();\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (this.a * x) + (this.c * y) + this.tx;\n        newPos.y = (this.b * x) + (this.d * y) + this.ty;\n\n        return newPos;\n    }\n\n    /**\n     * Get a new position with the inverse of the current transformation applied.\n     * Can be used to go from the world coordinate space to a child's coordinate space. (e.g. input)\n     *\n     * @param {PIXI.Point} pos - The origin\n     * @param {PIXI.Point} [newPos] - The point that the new position is assigned to (allowed to be same as input)\n     * @return {PIXI.Point} The new point, inverse-transformed through this matrix\n     */\n    applyInverse(pos, newPos)\n    {\n        newPos = newPos || new Point();\n\n        const id = 1 / ((this.a * this.d) + (this.c * -this.b));\n\n        const x = pos.x;\n        const y = pos.y;\n\n        newPos.x = (this.d * id * x) + (-this.c * id * y) + (((this.ty * this.c) - (this.tx * this.d)) * id);\n        newPos.y = (this.a * id * y) + (-this.b * id * x) + (((-this.ty * this.a) + (this.tx * this.b)) * id);\n\n        return newPos;\n    }\n\n    /**\n     * Translates the matrix on the x and y.\n     *\n     * @param {number} x How much to translate x by\n     * @param {number} y How much to translate y by\n     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n     */\n    translate(x, y)\n    {\n        this.tx += x;\n        this.ty += y;\n\n        return this;\n    }\n\n    /**\n     * Applies a scale transformation to the matrix.\n     *\n     * @param {number} x The amount to scale horizontally\n     * @param {number} y The amount to scale vertically\n     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n     */\n    scale(x, y)\n    {\n        this.a *= x;\n        this.d *= y;\n        this.c *= x;\n        this.b *= y;\n        this.tx *= x;\n        this.ty *= y;\n\n        return this;\n    }\n\n    /**\n     * Applies a rotation transformation to the matrix.\n     *\n     * @param {number} angle - The angle in radians.\n     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n     */\n    rotate(angle)\n    {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n\n        const a1 = this.a;\n        const c1 = this.c;\n        const tx1 = this.tx;\n\n        this.a = (a1 * cos) - (this.b * sin);\n        this.b = (a1 * sin) + (this.b * cos);\n        this.c = (c1 * cos) - (this.d * sin);\n        this.d = (c1 * sin) + (this.d * cos);\n        this.tx = (tx1 * cos) - (this.ty * sin);\n        this.ty = (tx1 * sin) + (this.ty * cos);\n\n        return this;\n    }\n\n    /**\n     * Appends the given Matrix to this Matrix.\n     *\n     * @param {PIXI.Matrix} matrix - The matrix to append.\n     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n     */\n    append(matrix)\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n\n        this.a = (matrix.a * a1) + (matrix.b * c1);\n        this.b = (matrix.a * b1) + (matrix.b * d1);\n        this.c = (matrix.c * a1) + (matrix.d * c1);\n        this.d = (matrix.c * b1) + (matrix.d * d1);\n\n        this.tx = (matrix.tx * a1) + (matrix.ty * c1) + this.tx;\n        this.ty = (matrix.tx * b1) + (matrix.ty * d1) + this.ty;\n\n        return this;\n    }\n\n    /**\n     * Sets the matrix based on all the available properties\n     *\n     * @param {number} x - Position on the x axis\n     * @param {number} y - Position on the y axis\n     * @param {number} pivotX - Pivot on the x axis\n     * @param {number} pivotY - Pivot on the y axis\n     * @param {number} scaleX - Scale on the x axis\n     * @param {number} scaleY - Scale on the y axis\n     * @param {number} rotation - Rotation in radians\n     * @param {number} skewX - Skew on the x axis\n     * @param {number} skewY - Skew on the y axis\n     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n     */\n    setTransform(x, y, pivotX, pivotY, scaleX, scaleY, rotation, skewX, skewY)\n    {\n        this.a = Math.cos(rotation + skewY) * scaleX;\n        this.b = Math.sin(rotation + skewY) * scaleX;\n        this.c = -Math.sin(rotation - skewX) * scaleY;\n        this.d = Math.cos(rotation - skewX) * scaleY;\n\n        this.tx = x - ((pivotX * this.a) + (pivotY * this.c));\n        this.ty = y - ((pivotX * this.b) + (pivotY * this.d));\n\n        return this;\n    }\n\n    /**\n     * Prepends the given Matrix to this Matrix.\n     *\n     * @param {PIXI.Matrix} matrix - The matrix to prepend\n     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n     */\n    prepend(matrix)\n    {\n        const tx1 = this.tx;\n\n        if (matrix.a !== 1 || matrix.b !== 0 || matrix.c !== 0 || matrix.d !== 1)\n        {\n            const a1 = this.a;\n            const c1 = this.c;\n\n            this.a = (a1 * matrix.a) + (this.b * matrix.c);\n            this.b = (a1 * matrix.b) + (this.b * matrix.d);\n            this.c = (c1 * matrix.a) + (this.d * matrix.c);\n            this.d = (c1 * matrix.b) + (this.d * matrix.d);\n        }\n\n        this.tx = (tx1 * matrix.a) + (this.ty * matrix.c) + matrix.tx;\n        this.ty = (tx1 * matrix.b) + (this.ty * matrix.d) + matrix.ty;\n\n        return this;\n    }\n\n    /**\n     * Decomposes the matrix (x, y, scaleX, scaleY, and rotation) and sets the properties on to a transform.\n     *\n     * @param {PIXI.Transform|PIXI.TransformStatic} transform - The transform to apply the properties to.\n     * @return {PIXI.Transform|PIXI.TransformStatic} The transform with the newly applied properties\n     */\n    decompose(transform)\n    {\n        // sort out rotation / skew..\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const d = this.d;\n\n        const skewX = -Math.atan2(-c, d);\n        const skewY = Math.atan2(b, a);\n\n        const delta = Math.abs(skewX + skewY);\n\n        if (delta < 0.00001 || Math.abs(PI_2 - delta) < 0.00001)\n        {\n            transform.rotation = skewY;\n            transform.skew.x = transform.skew.y = 0;\n        }\n        else\n        {\n            transform.rotation = 0;\n            transform.skew.x = skewX;\n            transform.skew.y = skewY;\n        }\n\n        // next set scale\n        transform.scale.x = Math.sqrt((a * a) + (b * b));\n        transform.scale.y = Math.sqrt((c * c) + (d * d));\n\n        // next set position\n        transform.position.x = this.tx;\n        transform.position.y = this.ty;\n\n        return transform;\n    }\n\n    /**\n     * Inverts this matrix\n     *\n     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n     */\n    invert()\n    {\n        const a1 = this.a;\n        const b1 = this.b;\n        const c1 = this.c;\n        const d1 = this.d;\n        const tx1 = this.tx;\n        const n = (a1 * d1) - (b1 * c1);\n\n        this.a = d1 / n;\n        this.b = -b1 / n;\n        this.c = -c1 / n;\n        this.d = a1 / n;\n        this.tx = ((c1 * this.ty) - (d1 * tx1)) / n;\n        this.ty = -((a1 * this.ty) - (b1 * tx1)) / n;\n\n        return this;\n    }\n\n    /**\n     * Resets this Matix to an identity (default) matrix.\n     *\n     * @return {PIXI.Matrix} This matrix. Good for chaining method calls.\n     */\n    identity()\n    {\n        this.a = 1;\n        this.b = 0;\n        this.c = 0;\n        this.d = 1;\n        this.tx = 0;\n        this.ty = 0;\n\n        return this;\n    }\n\n    /**\n     * Creates a new Matrix object with the same values as this one.\n     *\n     * @return {PIXI.Matrix} A copy of this matrix. Good for chaining method calls.\n     */\n    clone()\n    {\n        const matrix = new Matrix();\n\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * Changes the values of the given matrix to be the same as the ones in this matrix\n     *\n     * @param {PIXI.Matrix} matrix - The matrix to copy from.\n     * @return {PIXI.Matrix} The matrix given in parameter with its values updated.\n     */\n    copy(matrix)\n    {\n        matrix.a = this.a;\n        matrix.b = this.b;\n        matrix.c = this.c;\n        matrix.d = this.d;\n        matrix.tx = this.tx;\n        matrix.ty = this.ty;\n\n        return matrix;\n    }\n\n    /**\n     * A default (identity) matrix\n     *\n     * @static\n     * @const\n     */\n    static get IDENTITY()\n    {\n        return new Matrix();\n    }\n\n    /**\n     * A temp matrix\n     *\n     * @static\n     * @const\n     */\n    static get TEMP_MATRIX()\n    {\n        return new Matrix();\n    }\n}\n"]},"metadata":{},"sourceType":"script"}