{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _core = require('../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _ObservablePoint = require('../core/math/ObservablePoint');\n\nvar _ObservablePoint2 = _interopRequireDefault(_ObservablePoint);\n\nvar _utils = require('../core/utils');\n\nvar _settings = require('../core/settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font. To\n * split a line you can use '\\n', '\\r' or '\\r\\n' in your string. You can generate the fnt files using:\n *\n * A BitmapText can only be created when the font is loaded\n *\n * ```js\n * // in this case the font is in a file called 'desyrel.fnt'\n * let bitmapText = new PIXI.extras.BitmapText(\"text using a fancy font!\", {font: \"35px Desyrel\", align: \"right\"});\n * ```\n *\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.extras\n */\n\n\nvar BitmapText = function (_core$Container) {\n  _inherits(BitmapText, _core$Container);\n  /**\n   * @param {string} text - The copy that you would like the text to display\n   * @param {object} style - The style parameters\n   * @param {string|object} style.font - The font descriptor for the object, can be passed as a string of form\n   *      \"24px FontName\" or \"FontName\" or as an object with explicit name/size properties.\n   * @param {string} [style.font.name] - The bitmap font id\n   * @param {number} [style.font.size] - The size of the font in pixels, e.g. 24\n   * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'), does not affect\n   *      single line text\n   * @param {number} [style.tint=0xFFFFFF] - The tint color\n   */\n\n\n  function BitmapText(text) {\n    var style = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, BitmapText);\n    /**\n     * Private tracker for the width of the overall text\n     *\n     * @member {number}\n     * @private\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _core$Container.call(this));\n\n    _this._textWidth = 0;\n    /**\n     * Private tracker for the height of the overall text\n     *\n     * @member {number}\n     * @private\n     */\n\n    _this._textHeight = 0;\n    /**\n     * Private tracker for the letter sprite pool.\n     *\n     * @member {PIXI.Sprite[]}\n     * @private\n     */\n\n    _this._glyphs = [];\n    /**\n     * Private tracker for the current style.\n     *\n     * @member {object}\n     * @private\n     */\n\n    _this._font = {\n      tint: style.tint !== undefined ? style.tint : 0xFFFFFF,\n      align: style.align || 'left',\n      name: null,\n      size: 0\n    };\n    /**\n     * Private tracker for the current font.\n     *\n     * @member {object}\n     * @private\n     */\n\n    _this.font = style.font; // run font setter\n\n    /**\n     * Private tracker for the current text.\n     *\n     * @member {string}\n     * @private\n     */\n\n    _this._text = text;\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     *\n     * @member {number}\n     * @private\n     */\n\n    _this._maxWidth = 0;\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * ie: when trying to vertically align.\n     *\n     * @member {number}\n     * @private\n     */\n\n    _this._maxLineHeight = 0;\n    /**\n     * Letter spacing. This is useful for setting the space between characters.\n     * @member {number}\n     * @private\n     */\n\n    _this._letterSpacing = 0;\n    /**\n     * Text anchor. read-only\n     *\n     * @member {PIXI.ObservablePoint}\n     * @private\n     */\n\n    _this._anchor = new _ObservablePoint2.default(function () {\n      _this.dirty = true;\n    }, _this, 0, 0);\n    /**\n     * The dirty state of this object.\n     *\n     * @member {boolean}\n     */\n\n    _this.dirty = false;\n\n    _this.updateText();\n\n    return _this;\n  }\n  /**\n   * Renders text and updates it when needed\n   *\n   * @private\n   */\n\n\n  BitmapText.prototype.updateText = function updateText() {\n    var data = BitmapText.fonts[this._font.name];\n    var scale = this._font.size / data.size;\n    var pos = new core.Point();\n    var chars = [];\n    var lineWidths = [];\n    var text = this.text.replace(/(?:\\r\\n|\\r)/g, '\\n');\n    var textLength = text.length;\n    var maxWidth = this._maxWidth * data.size / this._font.size;\n    var prevCharCode = null;\n    var lastLineWidth = 0;\n    var maxLineWidth = 0;\n    var line = 0;\n    var lastBreakPos = -1;\n    var lastBreakWidth = 0;\n    var spacesRemoved = 0;\n    var maxLineHeight = 0;\n\n    for (var i = 0; i < textLength; i++) {\n      var charCode = text.charCodeAt(i);\n      var char = text.charAt(i);\n\n      if (/(?:\\s)/.test(char)) {\n        lastBreakPos = i;\n        lastBreakWidth = lastLineWidth;\n      }\n\n      if (char === '\\r' || char === '\\n') {\n        lineWidths.push(lastLineWidth);\n        maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        ++line;\n        ++spacesRemoved;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n        continue;\n      }\n\n      var charData = data.chars[charCode];\n\n      if (!charData) {\n        continue;\n      }\n\n      if (prevCharCode && charData.kerning[prevCharCode]) {\n        pos.x += charData.kerning[prevCharCode];\n      }\n\n      chars.push({\n        texture: charData.texture,\n        line: line,\n        charCode: charCode,\n        position: new core.Point(pos.x + charData.xOffset + this._letterSpacing / 2, pos.y + charData.yOffset)\n      });\n      pos.x += charData.xAdvance + this._letterSpacing;\n      lastLineWidth = pos.x;\n      maxLineHeight = Math.max(maxLineHeight, charData.yOffset + charData.texture.height);\n      prevCharCode = charCode;\n\n      if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {\n        ++spacesRemoved;\n        core.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n        i = lastBreakPos;\n        lastBreakPos = -1;\n        lineWidths.push(lastBreakWidth);\n        maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n        line++;\n        pos.x = 0;\n        pos.y += data.lineHeight;\n        prevCharCode = null;\n      }\n    }\n\n    var lastChar = text.charAt(text.length - 1);\n\n    if (lastChar !== '\\r' && lastChar !== '\\n') {\n      if (/(?:\\s)/.test(lastChar)) {\n        lastLineWidth = lastBreakWidth;\n      }\n\n      lineWidths.push(lastLineWidth);\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n    }\n\n    var lineAlignOffsets = [];\n\n    for (var _i = 0; _i <= line; _i++) {\n      var alignOffset = 0;\n\n      if (this._font.align === 'right') {\n        alignOffset = maxLineWidth - lineWidths[_i];\n      } else if (this._font.align === 'center') {\n        alignOffset = (maxLineWidth - lineWidths[_i]) / 2;\n      }\n\n      lineAlignOffsets.push(alignOffset);\n    }\n\n    var lenChars = chars.length;\n    var tint = this.tint;\n\n    for (var _i2 = 0; _i2 < lenChars; _i2++) {\n      var c = this._glyphs[_i2]; // get the next glyph sprite\n\n      if (c) {\n        c.texture = chars[_i2].texture;\n      } else {\n        c = new core.Sprite(chars[_i2].texture);\n\n        this._glyphs.push(c);\n      }\n\n      c.position.x = (chars[_i2].position.x + lineAlignOffsets[chars[_i2].line]) * scale;\n      c.position.y = chars[_i2].position.y * scale;\n      c.scale.x = c.scale.y = scale;\n      c.tint = tint;\n\n      if (!c.parent) {\n        this.addChild(c);\n      }\n    } // remove unnecessary children.\n\n\n    for (var _i3 = lenChars; _i3 < this._glyphs.length; ++_i3) {\n      this.removeChild(this._glyphs[_i3]);\n    }\n\n    this._textWidth = maxLineWidth * scale;\n    this._textHeight = (pos.y + data.lineHeight) * scale; // apply anchor\n\n    if (this.anchor.x !== 0 || this.anchor.y !== 0) {\n      for (var _i4 = 0; _i4 < lenChars; _i4++) {\n        this._glyphs[_i4].x -= this._textWidth * this.anchor.x;\n        this._glyphs[_i4].y -= this._textHeight * this.anchor.y;\n      }\n    }\n\n    this._maxLineHeight = maxLineHeight * scale;\n  };\n  /**\n   * Updates the transform of this object\n   *\n   * @private\n   */\n\n\n  BitmapText.prototype.updateTransform = function updateTransform() {\n    this.validate();\n    this.containerUpdateTransform();\n  };\n  /**\n   * Validates text before calling parent's getLocalBounds\n   *\n   * @return {PIXI.Rectangle} The rectangular bounding area\n   */\n\n\n  BitmapText.prototype.getLocalBounds = function getLocalBounds() {\n    this.validate();\n    return _core$Container.prototype.getLocalBounds.call(this);\n  };\n  /**\n   * Updates text when needed\n   *\n   * @private\n   */\n\n\n  BitmapText.prototype.validate = function validate() {\n    if (this.dirty) {\n      this.updateText();\n      this.dirty = false;\n    }\n  };\n  /**\n   * The tint of the BitmapText object\n   *\n   * @member {number}\n   */\n\n  /**\n   * Register a bitmap font with data and a texture.\n   *\n   * @static\n   * @param {XMLDocument} xml - The XML document data.\n   * @param {Object.<string, PIXI.Texture>|PIXI.Texture|PIXI.Texture[]} textures - List of textures for each page.\n   *  If providing an object, the key is the `<page>` element's `file` attribute in the FNT file.\n   * @return {Object} Result font object with font, size, lineHeight and char fields.\n   */\n\n\n  BitmapText.registerFont = function registerFont(xml, textures) {\n    var data = {};\n    var info = xml.getElementsByTagName('info')[0];\n    var common = xml.getElementsByTagName('common')[0];\n    var pages = xml.getElementsByTagName('page');\n    var res = (0, _utils.getResolutionOfUrl)(pages[0].getAttribute('file'), _settings2.default.RESOLUTION);\n    var pagesTextures = {};\n    data.font = info.getAttribute('face');\n    data.size = parseInt(info.getAttribute('size'), 10);\n    data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) / res;\n    data.chars = {}; // Single texture, convert to list\n\n    if (textures instanceof core.Texture) {\n      textures = [textures];\n    } // Convert the input Texture, Textures or object\n    // into a page Texture lookup by \"id\"\n\n\n    for (var i = 0; i < pages.length; i++) {\n      var id = pages[i].getAttribute('id');\n      var file = pages[i].getAttribute('file');\n      pagesTextures[id] = textures instanceof Array ? textures[i] : textures[file];\n    } // parse letters\n\n\n    var letters = xml.getElementsByTagName('char');\n\n    for (var _i5 = 0; _i5 < letters.length; _i5++) {\n      var letter = letters[_i5];\n      var charCode = parseInt(letter.getAttribute('id'), 10);\n      var page = letter.getAttribute('page') || 0;\n      var textureRect = new core.Rectangle(parseInt(letter.getAttribute('x'), 10) / res + pagesTextures[page].frame.x / res, parseInt(letter.getAttribute('y'), 10) / res + pagesTextures[page].frame.y / res, parseInt(letter.getAttribute('width'), 10) / res, parseInt(letter.getAttribute('height'), 10) / res);\n      data.chars[charCode] = {\n        xOffset: parseInt(letter.getAttribute('xoffset'), 10) / res,\n        yOffset: parseInt(letter.getAttribute('yoffset'), 10) / res,\n        xAdvance: parseInt(letter.getAttribute('xadvance'), 10) / res,\n        kerning: {},\n        texture: new core.Texture(pagesTextures[page].baseTexture, textureRect),\n        page: page\n      };\n    } // parse kernings\n\n\n    var kernings = xml.getElementsByTagName('kerning');\n\n    for (var _i6 = 0; _i6 < kernings.length; _i6++) {\n      var kerning = kernings[_i6];\n      var first = parseInt(kerning.getAttribute('first'), 10) / res;\n      var second = parseInt(kerning.getAttribute('second'), 10) / res;\n      var amount = parseInt(kerning.getAttribute('amount'), 10) / res;\n\n      if (data.chars[second]) {\n        data.chars[second].kerning[first] = amount;\n      }\n    } // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3\n    // but it's very likely to change\n\n\n    BitmapText.fonts[data.font] = data;\n    return data;\n  };\n\n  _createClass(BitmapText, [{\n    key: 'tint',\n    get: function get() {\n      return this._font.tint;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this._font.tint = typeof value === 'number' && value >= 0 ? value : 0xFFFFFF;\n      this.dirty = true;\n    }\n    /**\n     * The alignment of the BitmapText object\n     *\n     * @member {string}\n     * @default 'left'\n     */\n\n  }, {\n    key: 'align',\n    get: function get() {\n      return this._font.align;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this._font.align = value || 'left';\n      this.dirty = true;\n    }\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is 0,0 this means the text's origin is the top left\n     * Setting the anchor to 0.5,0.5 means the text's origin is centered\n     * Setting the anchor to 1,1 would mean the text's origin point will be the bottom right corner\n     *\n     * @member {PIXI.Point | number}\n     */\n\n  }, {\n    key: 'anchor',\n    get: function get() {\n      return this._anchor;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      if (typeof value === 'number') {\n        this._anchor.set(value);\n      } else {\n        this._anchor.copy(value);\n      }\n    }\n    /**\n     * The font descriptor of the BitmapText object\n     *\n     * @member {string|object}\n     */\n\n  }, {\n    key: 'font',\n    get: function get() {\n      return this._font;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      if (!value) {\n        return;\n      }\n\n      if (typeof value === 'string') {\n        value = value.split(' ');\n        this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');\n        this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;\n      } else {\n        this._font.name = value.name;\n        this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);\n      }\n\n      this.dirty = true;\n    }\n    /**\n     * The text of the BitmapText object\n     *\n     * @member {string}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n      return this._text;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      value = value.toString() || ' ';\n\n      if (this._text === value) {\n        return;\n      }\n\n      this._text = value;\n      this.dirty = true;\n    }\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: 'maxWidth',\n    get: function get() {\n      return this._maxWidth;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      if (this._maxWidth === value) {\n        return;\n      }\n\n      this._maxWidth = value;\n      this.dirty = true;\n    }\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * ie: when trying to vertically align.\n     *\n     * @member {number}\n     * @readonly\n     */\n\n  }, {\n    key: 'maxLineHeight',\n    get: function get() {\n      this.validate();\n      return this._maxLineHeight;\n    }\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readonly\n     */\n\n  }, {\n    key: 'textWidth',\n    get: function get() {\n      this.validate();\n      return this._textWidth;\n    }\n    /**\n     * Additional space between characters.\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: 'letterSpacing',\n    get: function get() {\n      return this._letterSpacing;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      if (this._letterSpacing !== value) {\n        this._letterSpacing = value;\n        this.dirty = true;\n      }\n    }\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readonly\n     */\n\n  }, {\n    key: 'textHeight',\n    get: function get() {\n      this.validate();\n      return this._textHeight;\n    }\n  }]);\n\n  return BitmapText;\n}(core.Container);\n\nexports.default = BitmapText;\nBitmapText.fonts = {};","map":{"version":3,"sources":["../../src/extras/BitmapText.js"],"names":["core","BitmapText","Container","style","tint","align","name","size","updateText","data","scale","pos","chars","lineWidths","text","textLength","maxWidth","prevCharCode","lastLineWidth","maxLineWidth","line","lastBreakPos","lastBreakWidth","spacesRemoved","maxLineHeight","i","charCode","char","Math","charData","texture","position","lastChar","lineAlignOffsets","alignOffset","lenChars","c","updateTransform","getLocalBounds","validate","value","parseInt","registerFont","xml","textures","info","common","pages","res","pagesTextures","id","file","letters","letter","page","textureRect","xOffset","yOffset","xAdvance","kerning","kernings","first","second","amount"],"mappings":"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","sourcesContent":["import * as core from '../core';\nimport ObservablePoint from '../core/math/ObservablePoint';\nimport { getResolutionOfUrl } from '../core/utils';\nimport settings from '../core/settings';\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font. To\n * split a line you can use '\\n', '\\r' or '\\r\\n' in your string. You can generate the fnt files using:\n *\n * A BitmapText can only be created when the font is loaded\n *\n * ```js\n * // in this case the font is in a file called 'desyrel.fnt'\n * let bitmapText = new PIXI.extras.BitmapText(\"text using a fancy font!\", {font: \"35px Desyrel\", align: \"right\"});\n * ```\n *\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.extras\n */\nexport default class BitmapText extends core.Container\n{\n    /**\n     * @param {string} text - The copy that you would like the text to display\n     * @param {object} style - The style parameters\n     * @param {string|object} style.font - The font descriptor for the object, can be passed as a string of form\n     *      \"24px FontName\" or \"FontName\" or as an object with explicit name/size properties.\n     * @param {string} [style.font.name] - The bitmap font id\n     * @param {number} [style.font.size] - The size of the font in pixels, e.g. 24\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'), does not affect\n     *      single line text\n     * @param {number} [style.tint=0xFFFFFF] - The tint color\n     */\n    constructor(text, style = {})\n    {\n        super();\n\n        /**\n         * Private tracker for the width of the overall text\n         *\n         * @member {number}\n         * @private\n         */\n        this._textWidth = 0;\n\n        /**\n         * Private tracker for the height of the overall text\n         *\n         * @member {number}\n         * @private\n         */\n        this._textHeight = 0;\n\n        /**\n         * Private tracker for the letter sprite pool.\n         *\n         * @member {PIXI.Sprite[]}\n         * @private\n         */\n        this._glyphs = [];\n\n        /**\n         * Private tracker for the current style.\n         *\n         * @member {object}\n         * @private\n         */\n        this._font = {\n            tint: style.tint !== undefined ? style.tint : 0xFFFFFF,\n            align: style.align || 'left',\n            name: null,\n            size: 0,\n        };\n\n        /**\n         * Private tracker for the current font.\n         *\n         * @member {object}\n         * @private\n         */\n        this.font = style.font; // run font setter\n\n        /**\n         * Private tracker for the current text.\n         *\n         * @member {string}\n         * @private\n         */\n        this._text = text;\n\n        /**\n         * The max width of this bitmap text in pixels. If the text provided is longer than the\n         * value provided, line breaks will be automatically inserted in the last whitespace.\n         * Disable by setting value to 0\n         *\n         * @member {number}\n         * @private\n         */\n        this._maxWidth = 0;\n\n        /**\n         * The max line height. This is useful when trying to use the total height of the Text,\n         * ie: when trying to vertically align.\n         *\n         * @member {number}\n         * @private\n         */\n        this._maxLineHeight = 0;\n\n        /**\n         * Letter spacing. This is useful for setting the space between characters.\n         * @member {number}\n         * @private\n         */\n        this._letterSpacing = 0;\n\n        /**\n         * Text anchor. read-only\n         *\n         * @member {PIXI.ObservablePoint}\n         * @private\n         */\n        this._anchor = new ObservablePoint(() => { this.dirty = true; }, this, 0, 0);\n\n        /**\n         * The dirty state of this object.\n         *\n         * @member {boolean}\n         */\n        this.dirty = false;\n\n        this.updateText();\n    }\n\n    /**\n     * Renders text and updates it when needed\n     *\n     * @private\n     */\n    updateText()\n    {\n        const data = BitmapText.fonts[this._font.name];\n        const scale = this._font.size / data.size;\n        const pos = new core.Point();\n        const chars = [];\n        const lineWidths = [];\n        const text = this.text.replace(/(?:\\r\\n|\\r)/g, '\\n');\n        const textLength = text.length;\n        const maxWidth = this._maxWidth * data.size / this._font.size;\n\n        let prevCharCode = null;\n        let lastLineWidth = 0;\n        let maxLineWidth = 0;\n        let line = 0;\n        let lastBreakPos = -1;\n        let lastBreakWidth = 0;\n        let spacesRemoved = 0;\n        let maxLineHeight = 0;\n\n        for (let i = 0; i < textLength; i++)\n        {\n            const charCode = text.charCodeAt(i);\n            const char = text.charAt(i);\n\n            if (/(?:\\s)/.test(char))\n            {\n                lastBreakPos = i;\n                lastBreakWidth = lastLineWidth;\n            }\n\n            if (char === '\\r' || char === '\\n')\n            {\n                lineWidths.push(lastLineWidth);\n                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n                ++line;\n                ++spacesRemoved;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                continue;\n            }\n\n            const charData = data.chars[charCode];\n\n            if (!charData)\n            {\n                continue;\n            }\n\n            if (prevCharCode && charData.kerning[prevCharCode])\n            {\n                pos.x += charData.kerning[prevCharCode];\n            }\n\n            chars.push({\n                texture: charData.texture,\n                line,\n                charCode,\n                position: new core.Point(pos.x + charData.xOffset + (this._letterSpacing / 2), pos.y + charData.yOffset),\n            });\n            pos.x += charData.xAdvance + this._letterSpacing;\n            lastLineWidth = pos.x;\n            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));\n            prevCharCode = charCode;\n\n            if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth)\n            {\n                ++spacesRemoved;\n                core.utils.removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n                i = lastBreakPos;\n                lastBreakPos = -1;\n\n                lineWidths.push(lastBreakWidth);\n                maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n                line++;\n\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n            }\n        }\n\n        const lastChar = text.charAt(text.length - 1);\n\n        if (lastChar !== '\\r' && lastChar !== '\\n')\n        {\n            if (/(?:\\s)/.test(lastChar))\n            {\n                lastLineWidth = lastBreakWidth;\n            }\n\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        }\n\n        const lineAlignOffsets = [];\n\n        for (let i = 0; i <= line; i++)\n        {\n            let alignOffset = 0;\n\n            if (this._font.align === 'right')\n            {\n                alignOffset = maxLineWidth - lineWidths[i];\n            }\n            else if (this._font.align === 'center')\n            {\n                alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            lineAlignOffsets.push(alignOffset);\n        }\n\n        const lenChars = chars.length;\n        const tint = this.tint;\n\n        for (let i = 0; i < lenChars; i++)\n        {\n            let c = this._glyphs[i]; // get the next glyph sprite\n\n            if (c)\n            {\n                c.texture = chars[i].texture;\n            }\n            else\n            {\n                c = new core.Sprite(chars[i].texture);\n                this._glyphs.push(c);\n            }\n\n            c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;\n            c.position.y = chars[i].position.y * scale;\n            c.scale.x = c.scale.y = scale;\n            c.tint = tint;\n\n            if (!c.parent)\n            {\n                this.addChild(c);\n            }\n        }\n\n        // remove unnecessary children.\n        for (let i = lenChars; i < this._glyphs.length; ++i)\n        {\n            this.removeChild(this._glyphs[i]);\n        }\n\n        this._textWidth = maxLineWidth * scale;\n        this._textHeight = (pos.y + data.lineHeight) * scale;\n\n        // apply anchor\n        if (this.anchor.x !== 0 || this.anchor.y !== 0)\n        {\n            for (let i = 0; i < lenChars; i++)\n            {\n                this._glyphs[i].x -= this._textWidth * this.anchor.x;\n                this._glyphs[i].y -= this._textHeight * this.anchor.y;\n            }\n        }\n        this._maxLineHeight = maxLineHeight * scale;\n    }\n\n    /**\n     * Updates the transform of this object\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        this.validate();\n        this.containerUpdateTransform();\n    }\n\n    /**\n     * Validates text before calling parent's getLocalBounds\n     *\n     * @return {PIXI.Rectangle} The rectangular bounding area\n     */\n    getLocalBounds()\n    {\n        this.validate();\n\n        return super.getLocalBounds();\n    }\n\n    /**\n     * Updates text when needed\n     *\n     * @private\n     */\n    validate()\n    {\n        if (this.dirty)\n        {\n            this.updateText();\n            this.dirty = false;\n        }\n    }\n\n    /**\n     * The tint of the BitmapText object\n     *\n     * @member {number}\n     */\n    get tint()\n    {\n        return this._font.tint;\n    }\n\n    set tint(value) // eslint-disable-line require-jsdoc\n    {\n        this._font.tint = (typeof value === 'number' && value >= 0) ? value : 0xFFFFFF;\n\n        this.dirty = true;\n    }\n\n    /**\n     * The alignment of the BitmapText object\n     *\n     * @member {string}\n     * @default 'left'\n     */\n    get align()\n    {\n        return this._font.align;\n    }\n\n    set align(value) // eslint-disable-line require-jsdoc\n    {\n        this._font.align = value || 'left';\n\n        this.dirty = true;\n    }\n\n    /**\n     * The anchor sets the origin point of the text.\n     * The default is 0,0 this means the text's origin is the top left\n     * Setting the anchor to 0.5,0.5 means the text's origin is centered\n     * Setting the anchor to 1,1 would mean the text's origin point will be the bottom right corner\n     *\n     * @member {PIXI.Point | number}\n     */\n    get anchor()\n    {\n        return this._anchor;\n    }\n\n    set anchor(value) // eslint-disable-line require-jsdoc\n    {\n        if (typeof value === 'number')\n        {\n            this._anchor.set(value);\n        }\n        else\n        {\n            this._anchor.copy(value);\n        }\n    }\n\n    /**\n     * The font descriptor of the BitmapText object\n     *\n     * @member {string|object}\n     */\n    get font()\n    {\n        return this._font;\n    }\n\n    set font(value) // eslint-disable-line require-jsdoc\n    {\n        if (!value)\n        {\n            return;\n        }\n\n        if (typeof value === 'string')\n        {\n            value = value.split(' ');\n\n            this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');\n            this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;\n        }\n        else\n        {\n            this._font.name = value.name;\n            this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);\n        }\n\n        this.dirty = true;\n    }\n\n    /**\n     * The text of the BitmapText object\n     *\n     * @member {string}\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    set text(value) // eslint-disable-line require-jsdoc\n    {\n        value = value.toString() || ' ';\n        if (this._text === value)\n        {\n            return;\n        }\n        this._text = value;\n        this.dirty = true;\n    }\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the\n     * value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     *\n     * @member {number}\n     */\n    get maxWidth()\n    {\n        return this._maxWidth;\n    }\n\n    set maxWidth(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._maxWidth === value)\n        {\n            return;\n        }\n        this._maxWidth = value;\n        this.dirty = true;\n    }\n\n    /**\n     * The max line height. This is useful when trying to use the total height of the Text,\n     * ie: when trying to vertically align.\n     *\n     * @member {number}\n     * @readonly\n     */\n    get maxLineHeight()\n    {\n        this.validate();\n\n        return this._maxLineHeight;\n    }\n\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readonly\n     */\n    get textWidth()\n    {\n        this.validate();\n\n        return this._textWidth;\n    }\n\n    /**\n     * Additional space between characters.\n     *\n     * @member {number}\n     */\n    get letterSpacing()\n    {\n        return this._letterSpacing;\n    }\n\n    set letterSpacing(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._letterSpacing !== value)\n        {\n            this._letterSpacing = value;\n            this.dirty = true;\n        }\n    }\n\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readonly\n     */\n    get textHeight()\n    {\n        this.validate();\n\n        return this._textHeight;\n    }\n\n    /**\n     * Register a bitmap font with data and a texture.\n     *\n     * @static\n     * @param {XMLDocument} xml - The XML document data.\n     * @param {Object.<string, PIXI.Texture>|PIXI.Texture|PIXI.Texture[]} textures - List of textures for each page.\n     *  If providing an object, the key is the `<page>` element's `file` attribute in the FNT file.\n     * @return {Object} Result font object with font, size, lineHeight and char fields.\n     */\n    static registerFont(xml, textures)\n    {\n        const data = {};\n        const info = xml.getElementsByTagName('info')[0];\n        const common = xml.getElementsByTagName('common')[0];\n        const pages = xml.getElementsByTagName('page');\n        const res = getResolutionOfUrl(pages[0].getAttribute('file'), settings.RESOLUTION);\n        const pagesTextures = {};\n\n        data.font = info.getAttribute('face');\n        data.size = parseInt(info.getAttribute('size'), 10);\n        data.lineHeight = parseInt(common.getAttribute('lineHeight'), 10) / res;\n        data.chars = {};\n\n        // Single texture, convert to list\n        if (textures instanceof core.Texture)\n        {\n            textures = [textures];\n        }\n\n        // Convert the input Texture, Textures or object\n        // into a page Texture lookup by \"id\"\n        for (let i = 0; i < pages.length; i++)\n        {\n            const id = pages[i].getAttribute('id');\n            const file = pages[i].getAttribute('file');\n\n            pagesTextures[id] = textures instanceof Array ? textures[i] : textures[file];\n        }\n\n        // parse letters\n        const letters = xml.getElementsByTagName('char');\n\n        for (let i = 0; i < letters.length; i++)\n        {\n            const letter = letters[i];\n            const charCode = parseInt(letter.getAttribute('id'), 10);\n            const page = letter.getAttribute('page') || 0;\n            const textureRect = new core.Rectangle(\n                (parseInt(letter.getAttribute('x'), 10) / res) + (pagesTextures[page].frame.x / res),\n                (parseInt(letter.getAttribute('y'), 10) / res) + (pagesTextures[page].frame.y / res),\n                parseInt(letter.getAttribute('width'), 10) / res,\n                parseInt(letter.getAttribute('height'), 10) / res\n            );\n\n            data.chars[charCode] = {\n                xOffset: parseInt(letter.getAttribute('xoffset'), 10) / res,\n                yOffset: parseInt(letter.getAttribute('yoffset'), 10) / res,\n                xAdvance: parseInt(letter.getAttribute('xadvance'), 10) / res,\n                kerning: {},\n                texture: new core.Texture(pagesTextures[page].baseTexture, textureRect),\n                page,\n            };\n        }\n\n        // parse kernings\n        const kernings = xml.getElementsByTagName('kerning');\n\n        for (let i = 0; i < kernings.length; i++)\n        {\n            const kerning = kernings[i];\n            const first = parseInt(kerning.getAttribute('first'), 10) / res;\n            const second = parseInt(kerning.getAttribute('second'), 10) / res;\n            const amount = parseInt(kerning.getAttribute('amount'), 10) / res;\n\n            if (data.chars[second])\n            {\n                data.chars[second].kerning[first] = amount;\n            }\n        }\n\n        // I'm leaving this as a temporary fix so we can test the bitmap fonts in v3\n        // but it's very likely to change\n        BitmapText.fonts[data.font] = data;\n\n        return data;\n    }\n}\n\nBitmapText.fonts = {};\n"]},"metadata":{},"sourceType":"script"}