{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _core = require('../../core');\n\nvar core = _interopRequireWildcard(_core);\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar TEMP_RECT = new core.Rectangle();\nvar BYTES_PER_PIXEL = 4;\n/**\n * The extract manager provides functionality to export content from the renderers.\n *\n * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract\n *\n * @class\n * @memberof PIXI.extract\n */\n\nvar WebGLExtract = function () {\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer\n   */\n  function WebGLExtract(renderer) {\n    _classCallCheck(this, WebGLExtract);\n\n    this.renderer = renderer;\n    /**\n     * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture\n     *\n     * @member {PIXI.extract.WebGLExtract} extract\n     * @memberof PIXI.WebGLRenderer#\n     * @see PIXI.extract.WebGLExtract\n     */\n\n    renderer.extract = this;\n  }\n  /**\n   * Will return a HTML Image of the target\n   *\n   * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n   *  to convert. If left empty will use use the main renderer\n   * @return {HTMLImageElement} HTML Image of the target\n   */\n\n\n  WebGLExtract.prototype.image = function image(target) {\n    var image = new Image();\n    image.src = this.base64(target);\n    return image;\n  };\n  /**\n   * Will return a a base64 encoded string of this target. It works by calling\n   *  `WebGLExtract.getCanvas` and then running toDataURL on that.\n   *\n   * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n   *  to convert. If left empty will use use the main renderer\n   * @return {string} A base64 encoded string of the texture.\n   */\n\n\n  WebGLExtract.prototype.base64 = function base64(target) {\n    return this.canvas(target).toDataURL();\n  };\n  /**\n   * Creates a Canvas element, renders this target to it and then returns it.\n   *\n   * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n   *  to convert. If left empty will use use the main renderer\n   * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n   */\n\n\n  WebGLExtract.prototype.canvas = function canvas(target) {\n    var renderer = this.renderer;\n    var textureBuffer = void 0;\n    var resolution = void 0;\n    var frame = void 0;\n    var flipY = false;\n    var renderTexture = void 0;\n    var generated = false;\n\n    if (target) {\n      if (target instanceof core.RenderTexture) {\n        renderTexture = target;\n      } else {\n        renderTexture = this.renderer.generateTexture(target);\n        generated = true;\n      }\n    }\n\n    if (renderTexture) {\n      textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];\n      resolution = textureBuffer.resolution;\n      frame = renderTexture.frame;\n      flipY = false;\n    } else {\n      textureBuffer = this.renderer.rootRenderTarget;\n      resolution = textureBuffer.resolution;\n      flipY = true;\n      frame = TEMP_RECT;\n      frame.width = textureBuffer.size.width;\n      frame.height = textureBuffer.size.height;\n    }\n\n    var width = Math.floor(frame.width * resolution + 1e-4);\n    var height = Math.floor(frame.height * resolution + 1e-4);\n    var canvasBuffer = new core.CanvasRenderTarget(width, height, 1);\n\n    if (textureBuffer) {\n      // bind the buffer\n      renderer.bindRenderTarget(textureBuffer); // set up an array of pixels\n\n      var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height); // read pixels to the array\n\n      var gl = renderer.gl;\n      gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels); // add the pixels to the canvas\n\n      var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);\n      canvasData.data.set(webglPixels);\n      canvasBuffer.context.putImageData(canvasData, 0, 0); // pulling pixels\n\n      if (flipY) {\n        canvasBuffer.context.scale(1, -1);\n        canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height);\n      }\n    }\n\n    if (generated) {\n      renderTexture.destroy(true);\n    } // send the canvas back..\n\n\n    return canvasBuffer.canvas;\n  };\n  /**\n   * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n   * order, with integer values between 0 and 255 (included).\n   *\n   * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n   *  to convert. If left empty will use use the main renderer\n   * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture\n   */\n\n\n  WebGLExtract.prototype.pixels = function pixels(target) {\n    var renderer = this.renderer;\n    var textureBuffer = void 0;\n    var resolution = void 0;\n    var frame = void 0;\n    var renderTexture = void 0;\n    var generated = false;\n\n    if (target) {\n      if (target instanceof core.RenderTexture) {\n        renderTexture = target;\n      } else {\n        renderTexture = this.renderer.generateTexture(target);\n        generated = true;\n      }\n    }\n\n    if (renderTexture) {\n      textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];\n      resolution = textureBuffer.resolution;\n      frame = renderTexture.frame;\n    } else {\n      textureBuffer = this.renderer.rootRenderTarget;\n      resolution = textureBuffer.resolution;\n      frame = TEMP_RECT;\n      frame.width = textureBuffer.size.width;\n      frame.height = textureBuffer.size.height;\n    }\n\n    var width = frame.width * resolution;\n    var height = frame.height * resolution;\n    var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n    if (textureBuffer) {\n      // bind the buffer\n      renderer.bindRenderTarget(textureBuffer); // read pixels to the array\n\n      var gl = renderer.gl;\n      gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);\n    }\n\n    if (generated) {\n      renderTexture.destroy(true);\n    }\n\n    return webglPixels;\n  };\n  /**\n   * Destroys the extract\n   *\n   */\n\n\n  WebGLExtract.prototype.destroy = function destroy() {\n    this.renderer.extract = null;\n    this.renderer = null;\n  };\n\n  return WebGLExtract;\n}();\n\nexports.default = WebGLExtract;\ncore.WebGLRenderer.registerPlugin('extract', WebGLExtract);","map":{"version":3,"sources":["../../../src/extract/webgl/WebGLExtract.js"],"names":["core","TEMP_RECT","BYTES_PER_PIXEL","WebGLExtract","renderer","image","target","base64","canvas","textureBuffer","resolution","frame","flipY","renderTexture","generated","width","Math","height","canvasBuffer","webglPixels","gl","canvasData","pixels","destroy"],"mappings":"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","sourcesContent":["import * as core from '../../core';\n\nconst TEMP_RECT = new core.Rectangle();\nconst BYTES_PER_PIXEL = 4;\n\n/**\n * The extract manager provides functionality to export content from the renderers.\n *\n * An instance of this class is automatically created by default, and can be found at renderer.plugins.extract\n *\n * @class\n * @memberof PIXI.extract\n */\nexport default class WebGLExtract\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - A reference to the current renderer\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n        /**\n         * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture\n         *\n         * @member {PIXI.extract.WebGLExtract} extract\n         * @memberof PIXI.WebGLRenderer#\n         * @see PIXI.extract.WebGLExtract\n         */\n        renderer.extract = this;\n    }\n\n    /**\n     * Will return a HTML Image of the target\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {HTMLImageElement} HTML Image of the target\n     */\n    image(target)\n    {\n        const image = new Image();\n\n        image.src = this.base64(target);\n\n        return image;\n    }\n\n    /**\n     * Will return a a base64 encoded string of this target. It works by calling\n     *  `WebGLExtract.getCanvas` and then running toDataURL on that.\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {string} A base64 encoded string of the texture.\n     */\n    base64(target)\n    {\n        return this.canvas(target).toDataURL();\n    }\n\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n     */\n    canvas(target)\n    {\n        const renderer = this.renderer;\n        let textureBuffer;\n        let resolution;\n        let frame;\n        let flipY = false;\n        let renderTexture;\n        let generated = false;\n\n        if (target)\n        {\n            if (target instanceof core.RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = this.renderer.generateTexture(target);\n                generated = true;\n            }\n        }\n\n        if (renderTexture)\n        {\n            textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];\n            resolution = textureBuffer.resolution;\n            frame = renderTexture.frame;\n            flipY = false;\n        }\n        else\n        {\n            textureBuffer = this.renderer.rootRenderTarget;\n            resolution = textureBuffer.resolution;\n            flipY = true;\n\n            frame = TEMP_RECT;\n            frame.width = textureBuffer.size.width;\n            frame.height = textureBuffer.size.height;\n        }\n\n        const width = Math.floor((frame.width * resolution) + 1e-4);\n        const height = Math.floor((frame.height * resolution) + 1e-4);\n\n        const canvasBuffer = new core.CanvasRenderTarget(width, height, 1);\n\n        if (textureBuffer)\n        {\n            // bind the buffer\n            renderer.bindRenderTarget(textureBuffer);\n\n            // set up an array of pixels\n            const webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n            // read pixels to the array\n            const gl = renderer.gl;\n\n            gl.readPixels(\n                frame.x * resolution,\n                frame.y * resolution,\n                width,\n                height,\n                gl.RGBA,\n                gl.UNSIGNED_BYTE,\n                webglPixels\n            );\n\n            // add the pixels to the canvas\n            const canvasData = canvasBuffer.context.getImageData(0, 0, width, height);\n\n            canvasData.data.set(webglPixels);\n\n            canvasBuffer.context.putImageData(canvasData, 0, 0);\n\n            // pulling pixels\n            if (flipY)\n            {\n                canvasBuffer.context.scale(1, -1);\n                canvasBuffer.context.drawImage(canvasBuffer.canvas, 0, -height);\n            }\n        }\n\n        if (generated)\n        {\n            renderTexture.destroy(true);\n        }\n        // send the canvas back..\n\n        return canvasBuffer.canvas;\n    }\n\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use use the main renderer\n     * @return {Uint8ClampedArray} One-dimensional array containing the pixel data of the entire texture\n     */\n    pixels(target)\n    {\n        const renderer = this.renderer;\n        let textureBuffer;\n        let resolution;\n        let frame;\n        let renderTexture;\n        let generated = false;\n\n        if (target)\n        {\n            if (target instanceof core.RenderTexture)\n            {\n                renderTexture = target;\n            }\n            else\n            {\n                renderTexture = this.renderer.generateTexture(target);\n                generated = true;\n            }\n        }\n\n        if (renderTexture)\n        {\n            textureBuffer = renderTexture.baseTexture._glRenderTargets[this.renderer.CONTEXT_UID];\n            resolution = textureBuffer.resolution;\n            frame = renderTexture.frame;\n        }\n        else\n        {\n            textureBuffer = this.renderer.rootRenderTarget;\n            resolution = textureBuffer.resolution;\n\n            frame = TEMP_RECT;\n            frame.width = textureBuffer.size.width;\n            frame.height = textureBuffer.size.height;\n        }\n\n        const width = frame.width * resolution;\n        const height = frame.height * resolution;\n\n        const webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n\n        if (textureBuffer)\n        {\n            // bind the buffer\n            renderer.bindRenderTarget(textureBuffer);\n            // read pixels to the array\n            const gl = renderer.gl;\n\n            gl.readPixels(\n                frame.x * resolution,\n                frame.y * resolution,\n                width,\n                height,\n                gl.RGBA,\n                gl.UNSIGNED_BYTE,\n                webglPixels\n            );\n        }\n\n        if (generated)\n        {\n            renderTexture.destroy(true);\n        }\n\n        return webglPixels;\n    }\n\n    /**\n     * Destroys the extract\n     *\n     */\n    destroy()\n    {\n        this.renderer.extract = null;\n        this.renderer = null;\n    }\n}\n\ncore.WebGLRenderer.registerPlugin('extract', WebGLExtract);\n"]},"metadata":{},"sourceType":"script"}