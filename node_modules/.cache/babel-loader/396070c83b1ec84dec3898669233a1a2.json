{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _utils = require('../utils');\n\nvar _DisplayObject2 = require('./DisplayObject');\n\nvar _DisplayObject3 = _interopRequireDefault(_DisplayObject2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * A Container represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n *```js\n * let container = new PIXI.Container();\n * container.addChild(sprite);\n * ```\n *\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI\n */\n\n\nvar Container = function (_DisplayObject) {\n  _inherits(Container, _DisplayObject);\n  /**\n   *\n   */\n\n\n  function Container() {\n    _classCallCheck(this, Container);\n    /**\n     * The array of children of this container.\n     *\n     * @member {PIXI.DisplayObject[]}\n     * @readonly\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _DisplayObject.call(this));\n\n    _this.children = [];\n    return _this;\n  }\n  /**\n   * Overridable method that can be used by Container subclasses whenever the children array is modified\n   *\n   * @private\n   */\n\n\n  Container.prototype.onChildrenChange = function onChildrenChange() {}\n  /* empty */\n\n  /**\n   * Adds one or more children to the container.\n   *\n   * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n   *\n   * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container\n   * @return {PIXI.DisplayObject} The first child that was added.\n   */\n  ;\n\n  Container.prototype.addChild = function addChild(child) {\n    var argumentsLength = arguments.length; // if there is only one argument we can bypass looping through the them\n\n    if (argumentsLength > 1) {\n      // loop through the arguments property and add all children\n      // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n      for (var i = 0; i < argumentsLength; i++) {\n        this.addChild(arguments[i]);\n      }\n    } else {\n      // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n      if (child.parent) {\n        child.parent.removeChild(child);\n      }\n\n      child.parent = this; // ensure child transform will be recalculated\n\n      child.transform._parentID = -1;\n      this.children.push(child); // ensure bounds will be recalculated\n\n      this._boundsID++; // TODO - lets either do all callbacks or all events.. not both!\n\n      this.onChildrenChange(this.children.length - 1);\n      child.emit('added', this);\n    }\n\n    return child;\n  };\n  /**\n   * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n   *\n   * @param {PIXI.DisplayObject} child - The child to add\n   * @param {number} index - The index to place the child in\n   * @return {PIXI.DisplayObject} The child that was added.\n   */\n\n\n  Container.prototype.addChildAt = function addChildAt(child, index) {\n    if (index < 0 || index > this.children.length) {\n      throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length);\n    }\n\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n\n    child.parent = this; // ensure child transform will be recalculated\n\n    child.transform._parentID = -1;\n    this.children.splice(index, 0, child); // ensure bounds will be recalculated\n\n    this._boundsID++; // TODO - lets either do all callbacks or all events.. not both!\n\n    this.onChildrenChange(index);\n    child.emit('added', this);\n    return child;\n  };\n  /**\n   * Swaps the position of 2 Display Objects within this container.\n   *\n   * @param {PIXI.DisplayObject} child - First display object to swap\n   * @param {PIXI.DisplayObject} child2 - Second display object to swap\n   */\n\n\n  Container.prototype.swapChildren = function swapChildren(child, child2) {\n    if (child === child2) {\n      return;\n    }\n\n    var index1 = this.getChildIndex(child);\n    var index2 = this.getChildIndex(child2);\n    this.children[index1] = child2;\n    this.children[index2] = child;\n    this.onChildrenChange(index1 < index2 ? index1 : index2);\n  };\n  /**\n   * Returns the index position of a child DisplayObject instance\n   *\n   * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify\n   * @return {number} The index position of the child display object to identify\n   */\n\n\n  Container.prototype.getChildIndex = function getChildIndex(child) {\n    var index = this.children.indexOf(child);\n\n    if (index === -1) {\n      throw new Error('The supplied DisplayObject must be a child of the caller');\n    }\n\n    return index;\n  };\n  /**\n   * Changes the position of an existing child in the display object container\n   *\n   * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number\n   * @param {number} index - The resulting index number for the child display object\n   */\n\n\n  Container.prototype.setChildIndex = function setChildIndex(child, index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error('The index ' + index + ' supplied is out of bounds ' + this.children.length);\n    }\n\n    var currentIndex = this.getChildIndex(child);\n    (0, _utils.removeItems)(this.children, currentIndex, 1); // remove from old position\n\n    this.children.splice(index, 0, child); // add at new position\n\n    this.onChildrenChange(index);\n  };\n  /**\n   * Returns the child at the specified index\n   *\n   * @param {number} index - The index to get the child at\n   * @return {PIXI.DisplayObject} The child at the given index, if any.\n   */\n\n\n  Container.prototype.getChildAt = function getChildAt(index) {\n    if (index < 0 || index >= this.children.length) {\n      throw new Error('getChildAt: Index (' + index + ') does not exist.');\n    }\n\n    return this.children[index];\n  };\n  /**\n   * Removes one or more children from the container.\n   *\n   * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove\n   * @return {PIXI.DisplayObject} The first child that was removed.\n   */\n\n\n  Container.prototype.removeChild = function removeChild(child) {\n    var argumentsLength = arguments.length; // if there is only one argument we can bypass looping through the them\n\n    if (argumentsLength > 1) {\n      // loop through the arguments property and add all children\n      // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n      for (var i = 0; i < argumentsLength; i++) {\n        this.removeChild(arguments[i]);\n      }\n    } else {\n      var index = this.children.indexOf(child);\n      if (index === -1) return null;\n      child.parent = null; // ensure child transform will be recalculated\n\n      child.transform._parentID = -1;\n      (0, _utils.removeItems)(this.children, index, 1); // ensure bounds will be recalculated\n\n      this._boundsID++; // TODO - lets either do all callbacks or all events.. not both!\n\n      this.onChildrenChange(index);\n      child.emit('removed', this);\n    }\n\n    return child;\n  };\n  /**\n   * Removes a child from the specified index position.\n   *\n   * @param {number} index - The index to get the child from\n   * @return {PIXI.DisplayObject} The child that was removed.\n   */\n\n\n  Container.prototype.removeChildAt = function removeChildAt(index) {\n    var child = this.getChildAt(index); // ensure child transform will be recalculated..\n\n    child.parent = null;\n    child.transform._parentID = -1;\n    (0, _utils.removeItems)(this.children, index, 1); // ensure bounds will be recalculated\n\n    this._boundsID++; // TODO - lets either do all callbacks or all events.. not both!\n\n    this.onChildrenChange(index);\n    child.emit('removed', this);\n    return child;\n  };\n  /**\n   * Removes all children from this container that are within the begin and end indexes.\n   *\n   * @param {number} [beginIndex=0] - The beginning position.\n   * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.\n   * @returns {DisplayObject[]} List of removed children\n   */\n\n\n  Container.prototype.removeChildren = function removeChildren() {\n    var beginIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var endIndex = arguments[1];\n    var begin = beginIndex;\n    var end = typeof endIndex === 'number' ? endIndex : this.children.length;\n    var range = end - begin;\n    var removed = void 0;\n\n    if (range > 0 && range <= end) {\n      removed = this.children.splice(begin, range);\n\n      for (var i = 0; i < removed.length; ++i) {\n        removed[i].parent = null;\n\n        if (removed[i].transform) {\n          removed[i].transform._parentID = -1;\n        }\n      }\n\n      this._boundsID++;\n      this.onChildrenChange(beginIndex);\n\n      for (var _i = 0; _i < removed.length; ++_i) {\n        removed[_i].emit('removed', this);\n      }\n\n      return removed;\n    } else if (range === 0 && this.children.length === 0) {\n      return [];\n    }\n\n    throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n  };\n  /**\n   * Updates the transform on all children of this container for rendering\n   */\n\n\n  Container.prototype.updateTransform = function updateTransform() {\n    this._boundsID++;\n    this.transform.updateTransform(this.parent.transform); // TODO: check render flags, how to process stuff here\n\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      var child = this.children[i];\n\n      if (child.visible) {\n        child.updateTransform();\n      }\n    }\n  };\n  /**\n   * Recalculates the bounds of the container.\n   *\n   */\n\n\n  Container.prototype.calculateBounds = function calculateBounds() {\n    this._bounds.clear();\n\n    this._calculateBounds();\n\n    for (var i = 0; i < this.children.length; i++) {\n      var child = this.children[i];\n\n      if (!child.visible || !child.renderable) {\n        continue;\n      }\n\n      child.calculateBounds(); // TODO: filter+mask, need to mask both somehow\n\n      if (child._mask) {\n        child._mask.calculateBounds();\n\n        this._bounds.addBoundsMask(child._bounds, child._mask._bounds);\n      } else if (child.filterArea) {\n        this._bounds.addBoundsArea(child._bounds, child.filterArea);\n      } else {\n        this._bounds.addBounds(child._bounds);\n      }\n    }\n\n    this._lastBoundsID = this._boundsID;\n  };\n  /**\n   * Recalculates the bounds of the object. Override this to\n   * calculate the bounds of the specific object (not including children).\n   *\n   */\n\n\n  Container.prototype._calculateBounds = function _calculateBounds() {} // FILL IN//\n\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n  ;\n\n  Container.prototype.renderWebGL = function renderWebGL(renderer) {\n    // if the object is not visible or the alpha is 0 then no need to render this element\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    } // do a quick check to see if this element has a mask or a filter.\n\n\n    if (this._mask || this.filters && this.filters.length) {\n      this.renderAdvancedWebGL(renderer);\n    } else {\n      this._renderWebGL(renderer); // simple render children!\n\n\n      for (var i = 0, j = this.children.length; i < j; ++i) {\n        this.children[i].renderWebGL(renderer);\n      }\n    }\n  };\n  /**\n   * Render the object using the WebGL renderer and advanced features.\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n\n  Container.prototype.renderAdvancedWebGL = function renderAdvancedWebGL(renderer) {\n    renderer.flush();\n    var filters = this._filters;\n    var mask = this._mask; // push filter first as we need to ensure the stencil buffer is correct for any masking\n\n    if (filters) {\n      if (!this._enabledFilters) {\n        this._enabledFilters = [];\n      }\n\n      this._enabledFilters.length = 0;\n\n      for (var i = 0; i < filters.length; i++) {\n        if (filters[i].enabled) {\n          this._enabledFilters.push(filters[i]);\n        }\n      }\n\n      if (this._enabledFilters.length) {\n        renderer.filterManager.pushFilter(this, this._enabledFilters);\n      }\n    }\n\n    if (mask) {\n      renderer.maskManager.pushMask(this, this._mask);\n    } // add this object to the batch, only rendered if it has a texture.\n\n\n    this._renderWebGL(renderer); // now loop through the children and make sure they get rendered\n\n\n    for (var _i2 = 0, j = this.children.length; _i2 < j; _i2++) {\n      this.children[_i2].renderWebGL(renderer);\n    }\n\n    renderer.flush();\n\n    if (mask) {\n      renderer.maskManager.popMask(this, this._mask);\n    }\n\n    if (filters && this._enabledFilters && this._enabledFilters.length) {\n      renderer.filterManager.popFilter();\n    }\n  };\n  /**\n   * To be overridden by the subclasses.\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n\n  Container.prototype._renderWebGL = function _renderWebGL(renderer) // eslint-disable-line no-unused-vars\n  {} // this is where content itself gets rendered...\n\n  /**\n   * To be overridden by the subclass\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */\n  ;\n\n  Container.prototype._renderCanvas = function _renderCanvas(renderer) // eslint-disable-line no-unused-vars\n  {} // this is where content itself gets rendered...\n\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */\n  ;\n\n  Container.prototype.renderCanvas = function renderCanvas(renderer) {\n    // if not visible or the alpha is 0 then no need to render this\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n      return;\n    }\n\n    if (this._mask) {\n      renderer.maskManager.pushMask(this._mask);\n    }\n\n    this._renderCanvas(renderer);\n\n    for (var i = 0, j = this.children.length; i < j; ++i) {\n      this.children[i].renderCanvas(renderer);\n    }\n\n    if (this._mask) {\n      renderer.maskManager.popMask(renderer);\n    }\n  };\n  /**\n   * Removes all internal references and listeners as well as removes children from the display list.\n   * Do not use a Container after calling `destroy`.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *  method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n\n\n  Container.prototype.destroy = function destroy(options) {\n    _DisplayObject.prototype.destroy.call(this);\n\n    var destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n    var oldChildren = this.removeChildren(0, this.children.length);\n\n    if (destroyChildren) {\n      for (var i = 0; i < oldChildren.length; ++i) {\n        oldChildren[i].destroy(options);\n      }\n    }\n  };\n  /**\n   * The width of the Container, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   */\n\n\n  _createClass(Container, [{\n    key: 'width',\n    get: function get() {\n      return this.scale.x * this.getLocalBounds().width;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      var width = this.getLocalBounds().width;\n\n      if (width !== 0) {\n        this.scale.x = value / width;\n      } else {\n        this.scale.x = 1;\n      }\n\n      this._width = value;\n    }\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: 'height',\n    get: function get() {\n      return this.scale.y * this.getLocalBounds().height;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      var height = this.getLocalBounds().height;\n\n      if (height !== 0) {\n        this.scale.y = value / height;\n      } else {\n        this.scale.y = 1;\n      }\n\n      this._height = value;\n    }\n  }]);\n\n  return Container;\n}(_DisplayObject3.default); // performance increase to avoid using call.. (10x faster)\n\n\nexports.default = Container;\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;","map":{"version":3,"sources":["../../../src/core/display/Container.js"],"names":["Container","onChildrenChange","addChild","child","argumentsLength","arguments","i","addChildAt","index","swapChildren","child2","index1","index2","getChildIndex","setChildIndex","currentIndex","getChildAt","removeChild","removeChildAt","removeChildren","beginIndex","endIndex","begin","end","range","removed","updateTransform","j","calculateBounds","_calculateBounds","renderWebGL","renderer","renderAdvancedWebGL","filters","mask","_renderWebGL","_renderCanvas","renderCanvas","destroy","options","destroyChildren","oldChildren","value","width","height"],"mappings":"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","sourcesContent":["import { removeItems } from '../utils';\nimport DisplayObject from './DisplayObject';\n\n/**\n * A Container represents a collection of display objects.\n * It is the base class of all display objects that act as a container for other objects.\n *\n *```js\n * let container = new PIXI.Container();\n * container.addChild(sprite);\n * ```\n *\n * @class\n * @extends PIXI.DisplayObject\n * @memberof PIXI\n */\nexport default class Container extends DisplayObject\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        super();\n\n        /**\n         * The array of children of this container.\n         *\n         * @member {PIXI.DisplayObject[]}\n         * @readonly\n         */\n        this.children = [];\n    }\n\n    /**\n     * Overridable method that can be used by Container subclasses whenever the children array is modified\n     *\n     * @private\n     */\n    onChildrenChange()\n    {\n        /* empty */\n    }\n\n    /**\n     * Adds one or more children to the container.\n     *\n     * Multiple items can be added like so: `myContainer.addChild(thingOne, thingTwo, thingThree)`\n     *\n     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to add to the container\n     * @return {PIXI.DisplayObject} The first child that was added.\n     */\n    addChild(child)\n    {\n        const argumentsLength = arguments.length;\n\n        // if there is only one argument we can bypass looping through the them\n        if (argumentsLength > 1)\n        {\n            // loop through the arguments property and add all children\n            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n            for (let i = 0; i < argumentsLength; i++)\n            {\n                this.addChild(arguments[i]);\n            }\n        }\n        else\n        {\n            // if the child has a parent then lets remove it as PixiJS objects can only exist in one place\n            if (child.parent)\n            {\n                child.parent.removeChild(child);\n            }\n\n            child.parent = this;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n\n            this.children.push(child);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(this.children.length - 1);\n            child.emit('added', this);\n        }\n\n        return child;\n    }\n\n    /**\n     * Adds a child to the container at a specified index. If the index is out of bounds an error will be thrown\n     *\n     * @param {PIXI.DisplayObject} child - The child to add\n     * @param {number} index - The index to place the child in\n     * @return {PIXI.DisplayObject} The child that was added.\n     */\n    addChildAt(child, index)\n    {\n        if (index < 0 || index > this.children.length)\n        {\n            throw new Error(`${child}addChildAt: The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n        // ensure child transform will be recalculated\n        child.transform._parentID = -1;\n\n        this.children.splice(index, 0, child);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('added', this);\n\n        return child;\n    }\n\n    /**\n     * Swaps the position of 2 Display Objects within this container.\n     *\n     * @param {PIXI.DisplayObject} child - First display object to swap\n     * @param {PIXI.DisplayObject} child2 - Second display object to swap\n     */\n    swapChildren(child, child2)\n    {\n        if (child === child2)\n        {\n            return;\n        }\n\n        const index1 = this.getChildIndex(child);\n        const index2 = this.getChildIndex(child2);\n\n        this.children[index1] = child2;\n        this.children[index2] = child;\n        this.onChildrenChange(index1 < index2 ? index1 : index2);\n    }\n\n    /**\n     * Returns the index position of a child DisplayObject instance\n     *\n     * @param {PIXI.DisplayObject} child - The DisplayObject instance to identify\n     * @return {number} The index position of the child display object to identify\n     */\n    getChildIndex(child)\n    {\n        const index = this.children.indexOf(child);\n\n        if (index === -1)\n        {\n            throw new Error('The supplied DisplayObject must be a child of the caller');\n        }\n\n        return index;\n    }\n\n    /**\n     * Changes the position of an existing child in the display object container\n     *\n     * @param {PIXI.DisplayObject} child - The child DisplayObject instance for which you want to change the index number\n     * @param {number} index - The resulting index number for the child display object\n     */\n    setChildIndex(child, index)\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`The index ${index} supplied is out of bounds ${this.children.length}`);\n        }\n\n        const currentIndex = this.getChildIndex(child);\n\n        removeItems(this.children, currentIndex, 1); // remove from old position\n        this.children.splice(index, 0, child); // add at new position\n\n        this.onChildrenChange(index);\n    }\n\n    /**\n     * Returns the child at the specified index\n     *\n     * @param {number} index - The index to get the child at\n     * @return {PIXI.DisplayObject} The child at the given index, if any.\n     */\n    getChildAt(index)\n    {\n        if (index < 0 || index >= this.children.length)\n        {\n            throw new Error(`getChildAt: Index (${index}) does not exist.`);\n        }\n\n        return this.children[index];\n    }\n\n    /**\n     * Removes one or more children from the container.\n     *\n     * @param {...PIXI.DisplayObject} child - The DisplayObject(s) to remove\n     * @return {PIXI.DisplayObject} The first child that was removed.\n     */\n    removeChild(child)\n    {\n        const argumentsLength = arguments.length;\n\n        // if there is only one argument we can bypass looping through the them\n        if (argumentsLength > 1)\n        {\n            // loop through the arguments property and add all children\n            // use it the right way (.length and [i]) so that this function can still be optimised by JS runtimes\n            for (let i = 0; i < argumentsLength; i++)\n            {\n                this.removeChild(arguments[i]);\n            }\n        }\n        else\n        {\n            const index = this.children.indexOf(child);\n\n            if (index === -1) return null;\n\n            child.parent = null;\n            // ensure child transform will be recalculated\n            child.transform._parentID = -1;\n            removeItems(this.children, index, 1);\n\n            // ensure bounds will be recalculated\n            this._boundsID++;\n\n            // TODO - lets either do all callbacks or all events.. not both!\n            this.onChildrenChange(index);\n            child.emit('removed', this);\n        }\n\n        return child;\n    }\n\n    /**\n     * Removes a child from the specified index position.\n     *\n     * @param {number} index - The index to get the child from\n     * @return {PIXI.DisplayObject} The child that was removed.\n     */\n    removeChildAt(index)\n    {\n        const child = this.getChildAt(index);\n\n        // ensure child transform will be recalculated..\n        child.parent = null;\n        child.transform._parentID = -1;\n        removeItems(this.children, index, 1);\n\n        // ensure bounds will be recalculated\n        this._boundsID++;\n\n        // TODO - lets either do all callbacks or all events.. not both!\n        this.onChildrenChange(index);\n        child.emit('removed', this);\n\n        return child;\n    }\n\n    /**\n     * Removes all children from this container that are within the begin and end indexes.\n     *\n     * @param {number} [beginIndex=0] - The beginning position.\n     * @param {number} [endIndex=this.children.length] - The ending position. Default value is size of the container.\n     * @returns {DisplayObject[]} List of removed children\n     */\n    removeChildren(beginIndex = 0, endIndex)\n    {\n        const begin = beginIndex;\n        const end = typeof endIndex === 'number' ? endIndex : this.children.length;\n        const range = end - begin;\n        let removed;\n\n        if (range > 0 && range <= end)\n        {\n            removed = this.children.splice(begin, range);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].parent = null;\n                if (removed[i].transform)\n                {\n                    removed[i].transform._parentID = -1;\n                }\n            }\n\n            this._boundsID++;\n\n            this.onChildrenChange(beginIndex);\n\n            for (let i = 0; i < removed.length; ++i)\n            {\n                removed[i].emit('removed', this);\n            }\n\n            return removed;\n        }\n        else if (range === 0 && this.children.length === 0)\n        {\n            return [];\n        }\n\n        throw new RangeError('removeChildren: numeric values are outside the acceptable range.');\n    }\n\n    /**\n     * Updates the transform on all children of this container for rendering\n     */\n    updateTransform()\n    {\n        this._boundsID++;\n\n        this.transform.updateTransform(this.parent.transform);\n\n        // TODO: check render flags, how to process stuff here\n        this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            const child = this.children[i];\n\n            if (child.visible)\n            {\n                child.updateTransform();\n            }\n        }\n    }\n\n    /**\n     * Recalculates the bounds of the container.\n     *\n     */\n    calculateBounds()\n    {\n        this._bounds.clear();\n\n        this._calculateBounds();\n\n        for (let i = 0; i < this.children.length; i++)\n        {\n            const child = this.children[i];\n\n            if (!child.visible || !child.renderable)\n            {\n                continue;\n            }\n\n            child.calculateBounds();\n\n            // TODO: filter+mask, need to mask both somehow\n            if (child._mask)\n            {\n                child._mask.calculateBounds();\n                this._bounds.addBoundsMask(child._bounds, child._mask._bounds);\n            }\n            else if (child.filterArea)\n            {\n                this._bounds.addBoundsArea(child._bounds, child.filterArea);\n            }\n            else\n            {\n                this._bounds.addBounds(child._bounds);\n            }\n        }\n\n        this._lastBoundsID = this._boundsID;\n    }\n\n    /**\n     * Recalculates the bounds of the object. Override this to\n     * calculate the bounds of the specific object (not including children).\n     *\n     */\n    _calculateBounds()\n    {\n        // FILL IN//\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    renderWebGL(renderer)\n    {\n        // if the object is not visible or the alpha is 0 then no need to render this element\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        // do a quick check to see if this element has a mask or a filter.\n        if (this._mask || (this.filters && this.filters.length))\n        {\n            this.renderAdvancedWebGL(renderer);\n        }\n        else\n        {\n            this._renderWebGL(renderer);\n\n            // simple render children!\n            for (let i = 0, j = this.children.length; i < j; ++i)\n            {\n                this.children[i].renderWebGL(renderer);\n            }\n        }\n    }\n\n    /**\n     * Render the object using the WebGL renderer and advanced features.\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    renderAdvancedWebGL(renderer)\n    {\n        renderer.flush();\n\n        const filters = this._filters;\n        const mask = this._mask;\n\n        // push filter first as we need to ensure the stencil buffer is correct for any masking\n        if (filters)\n        {\n            if (!this._enabledFilters)\n            {\n                this._enabledFilters = [];\n            }\n\n            this._enabledFilters.length = 0;\n\n            for (let i = 0; i < filters.length; i++)\n            {\n                if (filters[i].enabled)\n                {\n                    this._enabledFilters.push(filters[i]);\n                }\n            }\n\n            if (this._enabledFilters.length)\n            {\n                renderer.filterManager.pushFilter(this, this._enabledFilters);\n            }\n        }\n\n        if (mask)\n        {\n            renderer.maskManager.pushMask(this, this._mask);\n        }\n\n        // add this object to the batch, only rendered if it has a texture.\n        this._renderWebGL(renderer);\n\n        // now loop through the children and make sure they get rendered\n        for (let i = 0, j = this.children.length; i < j; i++)\n        {\n            this.children[i].renderWebGL(renderer);\n        }\n\n        renderer.flush();\n\n        if (mask)\n        {\n            renderer.maskManager.popMask(this, this._mask);\n        }\n\n        if (filters && this._enabledFilters && this._enabledFilters.length)\n        {\n            renderer.filterManager.popFilter();\n        }\n    }\n\n    /**\n     * To be overridden by the subclasses.\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderWebGL(renderer) // eslint-disable-line no-unused-vars\n    {\n        // this is where content itself gets rendered...\n    }\n\n    /**\n     * To be overridden by the subclass\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer) // eslint-disable-line no-unused-vars\n    {\n        // this is where content itself gets rendered...\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    renderCanvas(renderer)\n    {\n        // if not visible or the alpha is 0 then no need to render this\n        if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n        {\n            return;\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.pushMask(this._mask);\n        }\n\n        this._renderCanvas(renderer);\n        for (let i = 0, j = this.children.length; i < j; ++i)\n        {\n            this.children[i].renderCanvas(renderer);\n        }\n\n        if (this._mask)\n        {\n            renderer.maskManager.popMask(renderer);\n        }\n    }\n\n    /**\n     * Removes all internal references and listeners as well as removes children from the display list.\n     * Do not use a Container after calling `destroy`.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *  method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy();\n\n        const destroyChildren = typeof options === 'boolean' ? options : options && options.children;\n\n        const oldChildren = this.removeChildren(0, this.children.length);\n\n        if (destroyChildren)\n        {\n            for (let i = 0; i < oldChildren.length; ++i)\n            {\n                oldChildren[i].destroy(options);\n            }\n        }\n    }\n\n    /**\n     * The width of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this.scale.x * this.getLocalBounds().width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        const width = this.getLocalBounds().width;\n\n        if (width !== 0)\n        {\n            this.scale.x = value / width;\n        }\n        else\n        {\n            this.scale.x = 1;\n        }\n\n        this._width = value;\n    }\n\n    /**\n     * The height of the Container, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this.scale.y * this.getLocalBounds().height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        const height = this.getLocalBounds().height;\n\n        if (height !== 0)\n        {\n            this.scale.y = value / height;\n        }\n        else\n        {\n            this.scale.y = 1;\n        }\n\n        this._height = value;\n    }\n}\n\n// performance increase to avoid using call.. (10x faster)\nContainer.prototype.containerUpdateTransform = Container.prototype.updateTransform;\n"]},"metadata":{},"sourceType":"script"}