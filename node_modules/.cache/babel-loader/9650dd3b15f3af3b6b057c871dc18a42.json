{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _Sprite2 = require('../sprites/Sprite');\n\nvar _Sprite3 = _interopRequireDefault(_Sprite2);\n\nvar _Texture = require('../textures/Texture');\n\nvar _Texture2 = _interopRequireDefault(_Texture);\n\nvar _math = require('../math');\n\nvar _utils = require('../utils');\n\nvar _const = require('../const');\n\nvar _settings = require('../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nvar _TextStyle = require('./TextStyle');\n\nvar _TextStyle2 = _interopRequireDefault(_TextStyle);\n\nvar _TextMetrics = require('./TextMetrics');\n\nvar _TextMetrics2 = _interopRequireDefault(_TextMetrics);\n\nvar _trimCanvas = require('../utils/trimCanvas');\n\nvar _trimCanvas2 = _interopRequireDefault(_trimCanvas);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/* eslint max-depth: [2, 8] */\n\n\nvar defaultDestroyOptions = {\n  texture: true,\n  children: false,\n  baseTexture: true\n};\n/**\n * A Text Object will create a line or multiple lines of text. To split a line you can use '\\n' in your text string,\n * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.\n *\n * A Text can be created directly from a string and a style object,\n * which can be generated [here](https://pixijs.io/pixi-text-style).\n *\n * ```js\n * let text = new PIXI.Text('This is a PixiJS text',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n */\n\nvar Text = function (_Sprite) {\n  _inherits(Text, _Sprite);\n  /**\n   * @param {string} text - The string that you would like the text to display\n   * @param {object|PIXI.TextStyle} [style] - The style parameters\n   * @param {HTMLCanvasElement} [canvas] - The canvas element for drawing text\n   */\n\n\n  function Text(text, style, canvas) {\n    _classCallCheck(this, Text);\n\n    canvas = canvas || document.createElement('canvas');\n    canvas.width = 3;\n    canvas.height = 3;\n\n    var texture = _Texture2.default.fromCanvas(canvas, _settings2.default.SCALE_MODE, 'text');\n\n    texture.orig = new _math.Rectangle();\n    texture.trim = new _math.Rectangle(); // base texture is already automatically added to the cache, now adding the actual texture\n\n    var _this = _possibleConstructorReturn(this, _Sprite.call(this, texture));\n\n    _Texture2.default.addToCache(_this._texture, _this._texture.baseTexture.textureCacheIds[0]);\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @member {HTMLCanvasElement}\n     */\n\n\n    _this.canvas = canvas;\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @member {CanvasRenderingContext2D}\n     */\n\n    _this.context = _this.canvas.getContext('2d');\n    /**\n     * The resolution / device pixel ratio of the canvas. This is set automatically by the renderer.\n     * @member {number}\n     * @default 1\n     */\n\n    _this.resolution = _settings2.default.RESOLUTION;\n    /**\n     * Private tracker for the current text.\n     *\n     * @member {string}\n     * @private\n     */\n\n    _this._text = null;\n    /**\n     * Private tracker for the current style.\n     *\n     * @member {object}\n     * @private\n     */\n\n    _this._style = null;\n    /**\n     * Private listener to track style changes.\n     *\n     * @member {Function}\n     * @private\n     */\n\n    _this._styleListener = null;\n    /**\n     * Private tracker for the current font.\n     *\n     * @member {string}\n     * @private\n     */\n\n    _this._font = '';\n    _this.text = text;\n    _this.style = style;\n    _this.localStyleID = -1;\n    return _this;\n  }\n  /**\n   * Renders text and updates it when needed.\n   *\n   * @private\n   * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n   */\n\n\n  Text.prototype.updateText = function updateText(respectDirty) {\n    var style = this._style; // check if style has changed..\n\n    if (this.localStyleID !== style.styleID) {\n      this.dirty = true;\n      this.localStyleID = style.styleID;\n    }\n\n    if (!this.dirty && respectDirty) {\n      return;\n    }\n\n    this._font = this._style.toFontString();\n    var context = this.context;\n\n    var measured = _TextMetrics2.default.measureText(this._text, this._style, this._style.wordWrap, this.canvas);\n\n    var width = measured.width;\n    var height = measured.height;\n    var lines = measured.lines;\n    var lineHeight = measured.lineHeight;\n    var lineWidths = measured.lineWidths;\n    var maxLineWidth = measured.maxLineWidth;\n    var fontProperties = measured.fontProperties;\n    this.canvas.width = Math.ceil((Math.max(1, width) + style.padding * 2) * this.resolution);\n    this.canvas.height = Math.ceil((Math.max(1, height) + style.padding * 2) * this.resolution);\n    context.scale(this.resolution, this.resolution);\n    context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    context.font = this._font;\n    context.strokeStyle = style.stroke;\n    context.lineWidth = style.strokeThickness;\n    context.textBaseline = style.textBaseline;\n    context.lineJoin = style.lineJoin;\n    context.miterLimit = style.miterLimit;\n    var linePositionX = void 0;\n    var linePositionY = void 0;\n\n    if (style.dropShadow) {\n      context.fillStyle = style.dropShadowColor;\n      context.globalAlpha = style.dropShadowAlpha;\n      context.shadowBlur = style.dropShadowBlur;\n\n      if (style.dropShadowBlur > 0) {\n        context.shadowColor = style.dropShadowColor;\n      }\n\n      var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;\n      var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;\n\n      for (var i = 0; i < lines.length; i++) {\n        linePositionX = style.strokeThickness / 2;\n        linePositionY = style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent;\n\n        if (style.align === 'right') {\n          linePositionX += maxLineWidth - lineWidths[i];\n        } else if (style.align === 'center') {\n          linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n        }\n\n        if (style.fill) {\n          this.drawLetterSpacing(lines[i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding);\n\n          if (style.stroke && style.strokeThickness) {\n            context.strokeStyle = style.dropShadowColor;\n            this.drawLetterSpacing(lines[i], linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding, true);\n            context.strokeStyle = style.stroke;\n          }\n        }\n      }\n    } // reset the shadow blur and alpha that was set by the drop shadow, for the regular text\n\n\n    context.shadowBlur = 0;\n    context.globalAlpha = 1; // set canvas text styles\n\n    context.fillStyle = this._generateFillStyle(style, lines); // draw lines line by line\n\n    for (var _i = 0; _i < lines.length; _i++) {\n      linePositionX = style.strokeThickness / 2;\n      linePositionY = style.strokeThickness / 2 + _i * lineHeight + fontProperties.ascent;\n\n      if (style.align === 'right') {\n        linePositionX += maxLineWidth - lineWidths[_i];\n      } else if (style.align === 'center') {\n        linePositionX += (maxLineWidth - lineWidths[_i]) / 2;\n      }\n\n      if (style.stroke && style.strokeThickness) {\n        this.drawLetterSpacing(lines[_i], linePositionX + style.padding, linePositionY + style.padding, true);\n      }\n\n      if (style.fill) {\n        this.drawLetterSpacing(lines[_i], linePositionX + style.padding, linePositionY + style.padding);\n      }\n    }\n\n    this.updateTexture();\n  };\n  /**\n   * Render the text with letter-spacing.\n   * @param {string} text - The text to draw\n   * @param {number} x - Horizontal position to draw the text\n   * @param {number} y - Vertical position to draw the text\n   * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the\n   *  text? If not, it's for the inside fill\n   * @private\n   */\n\n\n  Text.prototype.drawLetterSpacing = function drawLetterSpacing(text, x, y) {\n    var isStroke = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var style = this._style; // letterSpacing of 0 means normal\n\n    var letterSpacing = style.letterSpacing;\n\n    if (letterSpacing === 0) {\n      if (isStroke) {\n        this.context.strokeText(text, x, y);\n      } else {\n        this.context.fillText(text, x, y);\n      }\n\n      return;\n    }\n\n    var characters = String.prototype.split.call(text, '');\n    var currentPosition = x;\n    var index = 0;\n    var current = '';\n    var previousWidth = this.context.measureText(text).width;\n    var currentWidth = 0;\n\n    while (index < text.length) {\n      current = characters[index++];\n\n      if (isStroke) {\n        this.context.strokeText(current, currentPosition, y);\n      } else {\n        this.context.fillText(current, currentPosition, y);\n      }\n\n      currentWidth = this.context.measureText(text.substring(index)).width;\n      currentPosition += previousWidth - currentWidth + letterSpacing;\n      previousWidth = currentWidth;\n    }\n  };\n  /**\n   * Updates texture size based on canvas size\n   *\n   * @private\n   */\n\n\n  Text.prototype.updateTexture = function updateTexture() {\n    var canvas = this.canvas;\n\n    if (this._style.trim) {\n      var trimmed = (0, _trimCanvas2.default)(canvas);\n\n      if (trimmed.data) {\n        canvas.width = trimmed.width;\n        canvas.height = trimmed.height;\n        this.context.putImageData(trimmed.data, 0, 0);\n      }\n    }\n\n    var texture = this._texture;\n    var style = this._style;\n    var padding = style.trim ? 0 : style.padding;\n    var baseTexture = texture.baseTexture;\n    baseTexture.hasLoaded = true;\n    baseTexture.resolution = this.resolution;\n    baseTexture.realWidth = canvas.width;\n    baseTexture.realHeight = canvas.height;\n    baseTexture.width = canvas.width / this.resolution;\n    baseTexture.height = canvas.height / this.resolution;\n    texture.trim.width = texture._frame.width = canvas.width / this.resolution;\n    texture.trim.height = texture._frame.height = canvas.height / this.resolution;\n    texture.trim.x = -padding;\n    texture.trim.y = -padding;\n    texture.orig.width = texture._frame.width - padding * 2;\n    texture.orig.height = texture._frame.height - padding * 2; // call sprite onTextureUpdate to update scale if _width or _height were set\n\n    this._onTextureUpdate();\n\n    baseTexture.emit('update', baseTexture);\n    this.dirty = false;\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n\n  Text.prototype.renderWebGL = function renderWebGL(renderer) {\n    if (this.resolution !== renderer.resolution) {\n      this.resolution = renderer.resolution;\n      this.dirty = true;\n    }\n\n    this.updateText(true);\n\n    _Sprite.prototype.renderWebGL.call(this, renderer);\n  };\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The renderer\n   */\n\n\n  Text.prototype._renderCanvas = function _renderCanvas(renderer) {\n    if (this.resolution !== renderer.resolution) {\n      this.resolution = renderer.resolution;\n      this.dirty = true;\n    }\n\n    this.updateText(true);\n\n    _Sprite.prototype._renderCanvas.call(this, renderer);\n  };\n  /**\n   * Gets the local bounds of the text object.\n   *\n   * @param {Rectangle} rect - The output rectangle.\n   * @return {Rectangle} The bounds.\n   */\n\n\n  Text.prototype.getLocalBounds = function getLocalBounds(rect) {\n    this.updateText(true);\n    return _Sprite.prototype.getLocalBounds.call(this, rect);\n  };\n  /**\n   * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.\n   */\n\n\n  Text.prototype._calculateBounds = function _calculateBounds() {\n    this.updateText(true);\n    this.calculateVertices(); // if we have already done this on THIS frame.\n\n    this._bounds.addQuad(this.vertexData);\n  };\n  /**\n   * Method to be called upon a TextStyle change.\n   * @private\n   */\n\n\n  Text.prototype._onStyleChange = function _onStyleChange() {\n    this.dirty = true;\n  };\n  /**\n   * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n   *\n   * @private\n   * @param {object} style - The style.\n   * @param {string[]} lines - The lines of text.\n   * @return {string|number|CanvasGradient} The fill style\n   */\n\n\n  Text.prototype._generateFillStyle = function _generateFillStyle(style, lines) {\n    if (!Array.isArray(style.fill)) {\n      return style.fill;\n    } // cocoon on canvas+ cannot generate textures, so use the first colour instead\n\n\n    if (navigator.isCocoonJS) {\n      return style.fill[0];\n    } // the gradient will be evenly spaced out according to how large the array is.\n    // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\n\n\n    var gradient = void 0;\n    var totalIterations = void 0;\n    var currentIteration = void 0;\n    var stop = void 0;\n    var width = this.canvas.width / this.resolution;\n    var height = this.canvas.height / this.resolution; // make a copy of the style settings, so we can manipulate them later\n\n    var fill = style.fill.slice();\n    var fillGradientStops = style.fillGradientStops.slice(); // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\n\n    if (!fillGradientStops.length) {\n      var lengthPlus1 = fill.length + 1;\n\n      for (var i = 1; i < lengthPlus1; ++i) {\n        fillGradientStops.push(i / lengthPlus1);\n      }\n    } // stop the bleeding of the last gradient on the line above to the top gradient of the this line\n    // by hard defining the first gradient colour at point 0, and last gradient colour at point 1\n\n\n    fill.unshift(style.fill[0]);\n    fillGradientStops.unshift(0);\n    fill.push(style.fill[style.fill.length - 1]);\n    fillGradientStops.push(1);\n\n    if (style.fillGradientType === _const.TEXT_GRADIENT.LINEAR_VERTICAL) {\n      // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\n      gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height); // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n      // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n\n      totalIterations = (fill.length + 1) * lines.length;\n      currentIteration = 0;\n\n      for (var _i2 = 0; _i2 < lines.length; _i2++) {\n        currentIteration += 1;\n\n        for (var j = 0; j < fill.length; j++) {\n          if (typeof fillGradientStops[j] === 'number') {\n            stop = fillGradientStops[j] / lines.length + _i2 / lines.length;\n          } else {\n            stop = currentIteration / totalIterations;\n          }\n\n          gradient.addColorStop(stop, fill[j]);\n          currentIteration++;\n        }\n      }\n    } else {\n      // start the gradient at the center left of the canvas, and end at the center right of the canvas\n      gradient = this.context.createLinearGradient(0, height / 2, width, height / 2); // can just evenly space out the gradients in this case, as multiple lines makes no difference\n      // to an even left to right gradient\n\n      totalIterations = fill.length + 1;\n      currentIteration = 1;\n\n      for (var _i3 = 0; _i3 < fill.length; _i3++) {\n        if (typeof fillGradientStops[_i3] === 'number') {\n          stop = fillGradientStops[_i3];\n        } else {\n          stop = currentIteration / totalIterations;\n        }\n\n        gradient.addColorStop(stop, fill[_i3]);\n        currentIteration++;\n      }\n    }\n\n    return gradient;\n  };\n  /**\n   * Destroys this text object.\n   * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n   * the majority of the time the texture will not be shared with any other Sprites.\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their\n   *  destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n   * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n   */\n\n\n  Text.prototype.destroy = function destroy(options) {\n    if (typeof options === 'boolean') {\n      options = {\n        children: options\n      };\n    }\n\n    options = Object.assign({}, defaultDestroyOptions, options);\n\n    _Sprite.prototype.destroy.call(this, options); // make sure to reset the the context and canvas.. dont want this hanging around in memory!\n\n\n    this.context = null;\n    this.canvas = null;\n    this._style = null;\n  };\n  /**\n   * The width of the Text, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   */\n\n\n  _createClass(Text, [{\n    key: 'width',\n    get: function get() {\n      this.updateText(true);\n      return Math.abs(this.scale.x) * this._texture.orig.width;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.updateText(true);\n      var s = (0, _utils.sign)(this.scale.x) || 1;\n      this.scale.x = s * value / this._texture.orig.width;\n      this._width = value;\n    }\n    /**\n     * The height of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: 'height',\n    get: function get() {\n      this.updateText(true);\n      return Math.abs(this.scale.y) * this._texture.orig.height;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.updateText(true);\n      var s = (0, _utils.sign)(this.scale.y) || 1;\n      this.scale.y = s * value / this._texture.orig.height;\n      this._height = value;\n    }\n    /**\n     * Set the style of the text. Set up an event listener to listen for changes on the style\n     * object and mark the text as dirty.\n     *\n     * @member {object|PIXI.TextStyle}\n     */\n\n  }, {\n    key: 'style',\n    get: function get() {\n      return this._style;\n    },\n    set: function set(style) // eslint-disable-line require-jsdoc\n    {\n      style = style || {};\n\n      if (style instanceof _TextStyle2.default) {\n        this._style = style;\n      } else {\n        this._style = new _TextStyle2.default(style);\n      }\n\n      this.localStyleID = -1;\n      this.dirty = true;\n    }\n    /**\n     * Set the copy for the text object. To split a line you can use '\\n'.\n     *\n     * @member {string}\n     */\n\n  }, {\n    key: 'text',\n    get: function get() {\n      return this._text;\n    },\n    set: function set(text) // eslint-disable-line require-jsdoc\n    {\n      text = String(text === '' || text === null || text === undefined ? ' ' : text);\n\n      if (this._text === text) {\n        return;\n      }\n\n      this._text = text;\n      this.dirty = true;\n    }\n  }]);\n\n  return Text;\n}(_Sprite3.default);\n\nexports.default = Text;","map":{"version":3,"sources":["../../../src/core/text/Text.js"],"names":["defaultDestroyOptions","texture","children","baseTexture","Text","canvas","document","updateText","respectDirty","style","context","measured","width","height","lines","lineHeight","lineWidths","maxLineWidth","fontProperties","Math","linePositionX","linePositionY","xShadowOffset","yShadowOffset","i","drawLetterSpacing","text","x","y","isStroke","letterSpacing","characters","String","currentPosition","index","current","previousWidth","currentWidth","updateTexture","trimmed","padding","renderWebGL","renderer","_renderCanvas","getLocalBounds","rect","_calculateBounds","_onStyleChange","_generateFillStyle","Array","navigator","gradient","totalIterations","currentIteration","stop","fill","fillGradientStops","lengthPlus1","j","destroy","options","Object","value","s"],"mappings":"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","sourcesContent":["/* eslint max-depth: [2, 8] */\nimport Sprite from '../sprites/Sprite';\nimport Texture from '../textures/Texture';\nimport { Rectangle } from '../math';\nimport { sign } from '../utils';\nimport { TEXT_GRADIENT } from '../const';\nimport settings from '../settings';\nimport TextStyle from './TextStyle';\nimport TextMetrics from './TextMetrics';\nimport trimCanvas from '../utils/trimCanvas';\n\nconst defaultDestroyOptions = {\n    texture: true,\n    children: false,\n    baseTexture: true,\n};\n\n/**\n * A Text Object will create a line or multiple lines of text. To split a line you can use '\\n' in your text string,\n * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.\n *\n * A Text can be created directly from a string and a style object,\n * which can be generated [here](https://pixijs.io/pixi-text-style).\n *\n * ```js\n * let text = new PIXI.Text('This is a PixiJS text',{fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'});\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n */\nexport default class Text extends Sprite\n{\n    /**\n     * @param {string} text - The string that you would like the text to display\n     * @param {object|PIXI.TextStyle} [style] - The style parameters\n     * @param {HTMLCanvasElement} [canvas] - The canvas element for drawing text\n     */\n    constructor(text, style, canvas)\n    {\n        canvas = canvas || document.createElement('canvas');\n\n        canvas.width = 3;\n        canvas.height = 3;\n\n        const texture = Texture.fromCanvas(canvas, settings.SCALE_MODE, 'text');\n\n        texture.orig = new Rectangle();\n        texture.trim = new Rectangle();\n\n        super(texture);\n\n        // base texture is already automatically added to the cache, now adding the actual texture\n        Texture.addToCache(this._texture, this._texture.baseTexture.textureCacheIds[0]);\n\n        /**\n         * The canvas element that everything is drawn to\n         *\n         * @member {HTMLCanvasElement}\n         */\n        this.canvas = canvas;\n\n        /**\n         * The canvas 2d context that everything is drawn with\n         * @member {CanvasRenderingContext2D}\n         */\n        this.context = this.canvas.getContext('2d');\n\n        /**\n         * The resolution / device pixel ratio of the canvas. This is set automatically by the renderer.\n         * @member {number}\n         * @default 1\n         */\n        this.resolution = settings.RESOLUTION;\n\n        /**\n         * Private tracker for the current text.\n         *\n         * @member {string}\n         * @private\n         */\n        this._text = null;\n\n        /**\n         * Private tracker for the current style.\n         *\n         * @member {object}\n         * @private\n         */\n        this._style = null;\n        /**\n         * Private listener to track style changes.\n         *\n         * @member {Function}\n         * @private\n         */\n        this._styleListener = null;\n\n        /**\n         * Private tracker for the current font.\n         *\n         * @member {string}\n         * @private\n         */\n        this._font = '';\n\n        this.text = text;\n        this.style = style;\n\n        this.localStyleID = -1;\n    }\n\n    /**\n     * Renders text and updates it when needed.\n     *\n     * @private\n     * @param {boolean} respectDirty - Whether to abort updating the text if the Text isn't dirty and the function is called.\n     */\n    updateText(respectDirty)\n    {\n        const style = this._style;\n\n        // check if style has changed..\n        if (this.localStyleID !== style.styleID)\n        {\n            this.dirty = true;\n            this.localStyleID = style.styleID;\n        }\n\n        if (!this.dirty && respectDirty)\n        {\n            return;\n        }\n\n        this._font = this._style.toFontString();\n\n        const context = this.context;\n        const measured = TextMetrics.measureText(this._text, this._style, this._style.wordWrap, this.canvas);\n        const width = measured.width;\n        const height = measured.height;\n        const lines = measured.lines;\n        const lineHeight = measured.lineHeight;\n        const lineWidths = measured.lineWidths;\n        const maxLineWidth = measured.maxLineWidth;\n        const fontProperties = measured.fontProperties;\n\n        this.canvas.width = Math.ceil((Math.max(1, width) + (style.padding * 2)) * this.resolution);\n        this.canvas.height = Math.ceil((Math.max(1, height) + (style.padding * 2)) * this.resolution);\n\n        context.scale(this.resolution, this.resolution);\n\n        context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n        context.font = this._font;\n        context.strokeStyle = style.stroke;\n        context.lineWidth = style.strokeThickness;\n        context.textBaseline = style.textBaseline;\n        context.lineJoin = style.lineJoin;\n        context.miterLimit = style.miterLimit;\n\n        let linePositionX;\n        let linePositionY;\n\n        if (style.dropShadow)\n        {\n            context.fillStyle = style.dropShadowColor;\n            context.globalAlpha = style.dropShadowAlpha;\n            context.shadowBlur = style.dropShadowBlur;\n\n            if (style.dropShadowBlur > 0)\n            {\n                context.shadowColor = style.dropShadowColor;\n            }\n\n            const xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;\n            const yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;\n\n            for (let i = 0; i < lines.length; i++)\n            {\n                linePositionX = style.strokeThickness / 2;\n                linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent;\n\n                if (style.align === 'right')\n                {\n                    linePositionX += maxLineWidth - lineWidths[i];\n                }\n                else if (style.align === 'center')\n                {\n                    linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n                }\n\n                if (style.fill)\n                {\n                    this.drawLetterSpacing(\n                        lines[i],\n                        linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding\n                    );\n\n                    if (style.stroke && style.strokeThickness)\n                    {\n                        context.strokeStyle = style.dropShadowColor;\n                        this.drawLetterSpacing(\n                            lines[i],\n                            linePositionX + xShadowOffset + style.padding, linePositionY + yShadowOffset + style.padding,\n                            true\n                        );\n                        context.strokeStyle = style.stroke;\n                    }\n                }\n            }\n        }\n\n        // reset the shadow blur and alpha that was set by the drop shadow, for the regular text\n        context.shadowBlur = 0;\n        context.globalAlpha = 1;\n\n        // set canvas text styles\n        context.fillStyle = this._generateFillStyle(style, lines);\n\n        // draw lines line by line\n        for (let i = 0; i < lines.length; i++)\n        {\n            linePositionX = style.strokeThickness / 2;\n            linePositionY = ((style.strokeThickness / 2) + (i * lineHeight)) + fontProperties.ascent;\n\n            if (style.align === 'right')\n            {\n                linePositionX += maxLineWidth - lineWidths[i];\n            }\n            else if (style.align === 'center')\n            {\n                linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            if (style.stroke && style.strokeThickness)\n            {\n                this.drawLetterSpacing(\n                    lines[i],\n                    linePositionX + style.padding,\n                    linePositionY + style.padding,\n                    true\n                );\n            }\n\n            if (style.fill)\n            {\n                this.drawLetterSpacing(\n                    lines[i],\n                    linePositionX + style.padding,\n                    linePositionY + style.padding\n                );\n            }\n        }\n\n        this.updateTexture();\n    }\n\n    /**\n     * Render the text with letter-spacing.\n     * @param {string} text - The text to draw\n     * @param {number} x - Horizontal position to draw the text\n     * @param {number} y - Vertical position to draw the text\n     * @param {boolean} [isStroke=false] - Is this drawing for the outside stroke of the\n     *  text? If not, it's for the inside fill\n     * @private\n     */\n    drawLetterSpacing(text, x, y, isStroke = false)\n    {\n        const style = this._style;\n\n        // letterSpacing of 0 means normal\n        const letterSpacing = style.letterSpacing;\n\n        if (letterSpacing === 0)\n        {\n            if (isStroke)\n            {\n                this.context.strokeText(text, x, y);\n            }\n            else\n            {\n                this.context.fillText(text, x, y);\n            }\n\n            return;\n        }\n\n        const characters = String.prototype.split.call(text, '');\n        let currentPosition = x;\n        let index = 0;\n        let current = '';\n        let previousWidth = this.context.measureText(text).width;\n        let currentWidth = 0;\n\n        while (index < text.length)\n        {\n            current = characters[index++];\n            if (isStroke)\n            {\n                this.context.strokeText(current, currentPosition, y);\n            }\n            else\n            {\n                this.context.fillText(current, currentPosition, y);\n            }\n            currentWidth = this.context.measureText(text.substring(index)).width;\n            currentPosition += previousWidth - currentWidth + letterSpacing;\n            previousWidth = currentWidth;\n        }\n    }\n\n    /**\n     * Updates texture size based on canvas size\n     *\n     * @private\n     */\n    updateTexture()\n    {\n        const canvas = this.canvas;\n\n        if (this._style.trim)\n        {\n            const trimmed = trimCanvas(canvas);\n\n            if (trimmed.data)\n            {\n                canvas.width = trimmed.width;\n                canvas.height = trimmed.height;\n                this.context.putImageData(trimmed.data, 0, 0);\n            }\n        }\n\n        const texture = this._texture;\n        const style = this._style;\n        const padding = style.trim ? 0 : style.padding;\n        const baseTexture = texture.baseTexture;\n\n        baseTexture.hasLoaded = true;\n        baseTexture.resolution = this.resolution;\n\n        baseTexture.realWidth = canvas.width;\n        baseTexture.realHeight = canvas.height;\n        baseTexture.width = canvas.width / this.resolution;\n        baseTexture.height = canvas.height / this.resolution;\n\n        texture.trim.width = texture._frame.width = canvas.width / this.resolution;\n        texture.trim.height = texture._frame.height = canvas.height / this.resolution;\n        texture.trim.x = -padding;\n        texture.trim.y = -padding;\n\n        texture.orig.width = texture._frame.width - (padding * 2);\n        texture.orig.height = texture._frame.height - (padding * 2);\n\n        // call sprite onTextureUpdate to update scale if _width or _height were set\n        this._onTextureUpdate();\n\n        baseTexture.emit('update', baseTexture);\n\n        this.dirty = false;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    renderWebGL(renderer)\n    {\n        if (this.resolution !== renderer.resolution)\n        {\n            this.resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super.renderWebGL(renderer);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The renderer\n     */\n    _renderCanvas(renderer)\n    {\n        if (this.resolution !== renderer.resolution)\n        {\n            this.resolution = renderer.resolution;\n            this.dirty = true;\n        }\n\n        this.updateText(true);\n\n        super._renderCanvas(renderer);\n    }\n\n    /**\n     * Gets the local bounds of the text object.\n     *\n     * @param {Rectangle} rect - The output rectangle.\n     * @return {Rectangle} The bounds.\n     */\n    getLocalBounds(rect)\n    {\n        this.updateText(true);\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * calculates the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.\n     */\n    _calculateBounds()\n    {\n        this.updateText(true);\n        this.calculateVertices();\n        // if we have already done this on THIS frame.\n        this._bounds.addQuad(this.vertexData);\n    }\n\n    /**\n     * Method to be called upon a TextStyle change.\n     * @private\n     */\n    _onStyleChange()\n    {\n        this.dirty = true;\n    }\n\n    /**\n     * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n     *\n     * @private\n     * @param {object} style - The style.\n     * @param {string[]} lines - The lines of text.\n     * @return {string|number|CanvasGradient} The fill style\n     */\n    _generateFillStyle(style, lines)\n    {\n        if (!Array.isArray(style.fill))\n        {\n            return style.fill;\n        }\n\n        // cocoon on canvas+ cannot generate textures, so use the first colour instead\n        if (navigator.isCocoonJS)\n        {\n            return style.fill[0];\n        }\n\n        // the gradient will be evenly spaced out according to how large the array is.\n        // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\n        let gradient;\n        let totalIterations;\n        let currentIteration;\n        let stop;\n\n        const width = this.canvas.width / this.resolution;\n        const height = this.canvas.height / this.resolution;\n\n        // make a copy of the style settings, so we can manipulate them later\n        const fill = style.fill.slice();\n        const fillGradientStops = style.fillGradientStops.slice();\n\n        // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\n        if (!fillGradientStops.length)\n        {\n            const lengthPlus1 = fill.length + 1;\n\n            for (let i = 1; i < lengthPlus1; ++i)\n            {\n                fillGradientStops.push(i / lengthPlus1);\n            }\n        }\n\n        // stop the bleeding of the last gradient on the line above to the top gradient of the this line\n        // by hard defining the first gradient colour at point 0, and last gradient colour at point 1\n        fill.unshift(style.fill[0]);\n        fillGradientStops.unshift(0);\n\n        fill.push(style.fill[style.fill.length - 1]);\n        fillGradientStops.push(1);\n\n        if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL)\n        {\n            // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\n            gradient = this.context.createLinearGradient(width / 2, 0, width / 2, height);\n\n            // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n            // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n            totalIterations = (fill.length + 1) * lines.length;\n            currentIteration = 0;\n            for (let i = 0; i < lines.length; i++)\n            {\n                currentIteration += 1;\n                for (let j = 0; j < fill.length; j++)\n                {\n                    if (typeof fillGradientStops[j] === 'number')\n                    {\n                        stop = (fillGradientStops[j] / lines.length) + (i / lines.length);\n                    }\n                    else\n                    {\n                        stop = currentIteration / totalIterations;\n                    }\n                    gradient.addColorStop(stop, fill[j]);\n                    currentIteration++;\n                }\n            }\n        }\n        else\n        {\n            // start the gradient at the center left of the canvas, and end at the center right of the canvas\n            gradient = this.context.createLinearGradient(0, height / 2, width, height / 2);\n\n            // can just evenly space out the gradients in this case, as multiple lines makes no difference\n            // to an even left to right gradient\n            totalIterations = fill.length + 1;\n            currentIteration = 1;\n\n            for (let i = 0; i < fill.length; i++)\n            {\n                if (typeof fillGradientStops[i] === 'number')\n                {\n                    stop = fillGradientStops[i];\n                }\n                else\n                {\n                    stop = currentIteration / totalIterations;\n                }\n                gradient.addColorStop(stop, fill[i]);\n                currentIteration++;\n            }\n        }\n\n        return gradient;\n    }\n\n    /**\n     * Destroys this text object.\n     * Note* Unlike a Sprite, a Text object will automatically destroy its baseTexture and texture as\n     * the majority of the time the texture will not be shared with any other Sprites.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=true] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=true] - Should it destroy the base texture of the sprite as well\n     */\n    destroy(options)\n    {\n        if (typeof options === 'boolean')\n        {\n            options = { children: options };\n        }\n\n        options = Object.assign({}, defaultDestroyOptions, options);\n\n        super.destroy(options);\n\n        // make sure to reset the the context and canvas.. dont want this hanging around in memory!\n        this.context = null;\n        this.canvas = null;\n\n        this._style = null;\n    }\n\n    /**\n     * The width of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = sign(this.scale.x) || 1;\n\n        this.scale.x = s * value / this._texture.orig.width;\n        this._width = value;\n    }\n\n    /**\n     * The height of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        this.updateText(true);\n\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this.updateText(true);\n\n        const s = sign(this.scale.y) || 1;\n\n        this.scale.y = s * value / this._texture.orig.height;\n        this._height = value;\n    }\n\n    /**\n     * Set the style of the text. Set up an event listener to listen for changes on the style\n     * object and mark the text as dirty.\n     *\n     * @member {object|PIXI.TextStyle}\n     */\n    get style()\n    {\n        return this._style;\n    }\n\n    set style(style) // eslint-disable-line require-jsdoc\n    {\n        style = style || {};\n\n        if (style instanceof TextStyle)\n        {\n            this._style = style;\n        }\n        else\n        {\n            this._style = new TextStyle(style);\n        }\n\n        this.localStyleID = -1;\n        this.dirty = true;\n    }\n\n    /**\n     * Set the copy for the text object. To split a line you can use '\\n'.\n     *\n     * @member {string}\n     */\n    get text()\n    {\n        return this._text;\n    }\n\n    set text(text) // eslint-disable-line require-jsdoc\n    {\n        text = String(text === '' || text === null || text === undefined ? ' ' : text);\n\n        if (this._text === text)\n        {\n            return;\n        }\n        this._text = text;\n        this.dirty = true;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}