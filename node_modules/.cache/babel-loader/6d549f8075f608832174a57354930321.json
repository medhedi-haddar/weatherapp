{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _const = require('../../const');\n\nvar _settings = require('../../settings');\n\nvar _settings2 = _interopRequireDefault(_settings);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * TextureGarbageCollector. This class manages the GPU and ensures that it does not get clogged\n * up with textures that are no longer being used.\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar TextureGarbageCollector = function () {\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.\n   */\n  function TextureGarbageCollector(renderer) {\n    _classCallCheck(this, TextureGarbageCollector);\n\n    this.renderer = renderer;\n    this.count = 0;\n    this.checkCount = 0;\n    this.maxIdle = _settings2.default.GC_MAX_IDLE;\n    this.checkCountMax = _settings2.default.GC_MAX_CHECK_COUNT;\n    this.mode = _settings2.default.GC_MODE;\n  }\n  /**\n   * Checks to see when the last time a texture was used\n   * if the texture has not been used for a specified amount of time it will be removed from the GPU\n   */\n\n\n  TextureGarbageCollector.prototype.update = function update() {\n    this.count++;\n\n    if (this.mode === _const.GC_MODES.MANUAL) {\n      return;\n    }\n\n    this.checkCount++;\n\n    if (this.checkCount > this.checkCountMax) {\n      this.checkCount = 0;\n      this.run();\n    }\n  };\n  /**\n   * Checks to see when the last time a texture was used\n   * if the texture has not been used for a specified amount of time it will be removed from the GPU\n   */\n\n\n  TextureGarbageCollector.prototype.run = function run() {\n    var tm = this.renderer.textureManager;\n    var managedTextures = tm._managedTextures;\n    var wasRemoved = false;\n\n    for (var i = 0; i < managedTextures.length; i++) {\n      var texture = managedTextures[i]; // only supports non generated textures at the moment!\n\n      if (!texture._glRenderTargets && this.count - texture.touched > this.maxIdle) {\n        tm.destroyTexture(texture, true);\n        managedTextures[i] = null;\n        wasRemoved = true;\n      }\n    }\n\n    if (wasRemoved) {\n      var j = 0;\n\n      for (var _i = 0; _i < managedTextures.length; _i++) {\n        if (managedTextures[_i] !== null) {\n          managedTextures[j++] = managedTextures[_i];\n        }\n      }\n\n      managedTextures.length = j;\n    }\n  };\n  /**\n   * Removes all the textures within the specified displayObject and its children from the GPU\n   *\n   * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.\n   */\n\n\n  TextureGarbageCollector.prototype.unload = function unload(displayObject) {\n    var tm = this.renderer.textureManager; // only destroy non generated textures\n\n    if (displayObject._texture && displayObject._texture._glRenderTargets) {\n      tm.destroyTexture(displayObject._texture, true);\n    }\n\n    for (var i = displayObject.children.length - 1; i >= 0; i--) {\n      this.unload(displayObject.children[i]);\n    }\n  };\n\n  return TextureGarbageCollector;\n}();\n\nexports.default = TextureGarbageCollector;","map":{"version":3,"sources":["../../../../src/core/renderers/webgl/TextureGarbageCollector.js"],"names":["TextureGarbageCollector","update","run","tm","managedTextures","wasRemoved","i","texture","j","unload","displayObject"],"mappings":";;;;AAAA,IAAA,MAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;;;;;;;;;;;;;;AAEA;;;;;;;;;IAOqBA,uB;AAEjB;;;AAGA,WAAA,uBAAA,CAAA,QAAA,EACA;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,uBAAA,CAAA;;AACI,SAAA,QAAA,GAAA,QAAA;AAEA,SAAA,KAAA,GAAA,CAAA;AACA,SAAA,UAAA,GAAA,CAAA;AACA,SAAA,OAAA,GAAe,UAAA,CAAA,OAAA,CAAf,WAAA;AACA,SAAA,aAAA,GAAqB,UAAA,CAAA,OAAA,CAArB,kBAAA;AACA,SAAA,IAAA,GAAY,UAAA,CAAA,OAAA,CAAZ,OAAA;AACH;AAED;;;;;;oCAIAC,M,qBACA;AACI,SAAA,KAAA;;AAEA,QAAI,KAAA,IAAA,KAAc,MAAA,CAAA,QAAA,CAAlB,MAAA,EACA;AACI;AACH;;AAED,SAAA,UAAA;;AAEA,QAAI,KAAA,UAAA,GAAkB,KAAtB,aAAA,EACA;AACI,WAAA,UAAA,GAAA,CAAA;AAEA,WAAA,GAAA;AACH;;AAGL;;;;;;oCAIAC,G,kBACA;AACI,QAAMC,EAAAA,GAAK,KAAA,QAAA,CAAX,cAAA;AACA,QAAMC,eAAAA,GAAmBD,EAAAA,CAAzB,gBAAA;AACA,QAAIE,UAAAA,GAAJ,KAAA;;AAEA,SAAK,IAAIC,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAIF,eAAAA,CAApB,MAAA,EAA4CE,CAA5C,EAAA,EACA;AACI,UAAMC,OAAAA,GAAUH,eAAAA,CAAhB,CAAgBA,CAAhB,CADJ,CAGI;;AACA,UAAI,CAACG,OAAAA,CAAD,gBAAA,IAA6B,KAAA,KAAA,GAAaA,OAAAA,CAAb,OAAA,GAA+B,KAAhE,OAAA,EACA;AACIJ,QAAAA,EAAAA,CAAAA,cAAAA,CAAAA,OAAAA,EAAAA,IAAAA;AACAC,QAAAA,eAAAA,CAAAA,CAAAA,CAAAA,GAAAA,IAAAA;AACAC,QAAAA,UAAAA,GAAAA,IAAAA;AACH;AACJ;;AAED,QAAA,UAAA,EACA;AACI,UAAIG,CAAAA,GAAJ,CAAA;;AAEA,WAAK,IAAIF,EAAAA,GAAT,CAAA,EAAgBA,EAAAA,GAAIF,eAAAA,CAApB,MAAA,EAA4CE,EAA5C,EAAA,EACA;AACI,YAAIF,eAAAA,CAAAA,EAAAA,CAAAA,KAAJ,IAAA,EACA;AACIA,UAAAA,eAAAA,CAAgBI,CAAhBJ,EAAAA,CAAAA,GAAuBA,eAAAA,CAAvBA,EAAuBA,CAAvBA;AACH;AACJ;;AAEDA,MAAAA,eAAAA,CAAAA,MAAAA,GAAAA,CAAAA;AACH;;AAGL;;;;;;;oCAKAK,M,mBAAOC,a,EACP;AACI,QAAMP,EAAAA,GAAK,KAAA,QAAA,CAAX,cAAA,CADJ,CAGI;;AACA,QAAIO,aAAAA,CAAAA,QAAAA,IAA0BA,aAAAA,CAAAA,QAAAA,CAA9B,gBAAA,EACA;AACIP,MAAAA,EAAAA,CAAAA,cAAAA,CAAkBO,aAAAA,CAAlBP,QAAAA,EAAAA,IAAAA;AACH;;AAED,SAAK,IAAIG,CAAAA,GAAII,aAAAA,CAAAA,QAAAA,CAAAA,MAAAA,GAAb,CAAA,EAAgDJ,CAAAA,IAAhD,CAAA,EAAwDA,CAAxD,EAAA,EACA;AACI,WAAA,MAAA,CAAYI,aAAAA,CAAAA,QAAAA,CAAZ,CAAYA,CAAZ;AACH;;;;;;kBAhGYV,uB","sourcesContent":["import { GC_MODES } from '../../const';\nimport settings from '../../settings';\n\n/**\n * TextureGarbageCollector. This class manages the GPU and ensures that it does not get clogged\n * up with textures that are no longer being used.\n *\n * @class\n * @memberof PIXI\n */\nexport default class TextureGarbageCollector\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.\n     */\n    constructor(renderer)\n    {\n        this.renderer = renderer;\n\n        this.count = 0;\n        this.checkCount = 0;\n        this.maxIdle = settings.GC_MAX_IDLE;\n        this.checkCountMax = settings.GC_MAX_CHECK_COUNT;\n        this.mode = settings.GC_MODE;\n    }\n\n    /**\n     * Checks to see when the last time a texture was used\n     * if the texture has not been used for a specified amount of time it will be removed from the GPU\n     */\n    update()\n    {\n        this.count++;\n\n        if (this.mode === GC_MODES.MANUAL)\n        {\n            return;\n        }\n\n        this.checkCount++;\n\n        if (this.checkCount > this.checkCountMax)\n        {\n            this.checkCount = 0;\n\n            this.run();\n        }\n    }\n\n    /**\n     * Checks to see when the last time a texture was used\n     * if the texture has not been used for a specified amount of time it will be removed from the GPU\n     */\n    run()\n    {\n        const tm = this.renderer.textureManager;\n        const managedTextures =  tm._managedTextures;\n        let wasRemoved = false;\n\n        for (let i = 0; i < managedTextures.length; i++)\n        {\n            const texture = managedTextures[i];\n\n            // only supports non generated textures at the moment!\n            if (!texture._glRenderTargets && this.count - texture.touched > this.maxIdle)\n            {\n                tm.destroyTexture(texture, true);\n                managedTextures[i] = null;\n                wasRemoved = true;\n            }\n        }\n\n        if (wasRemoved)\n        {\n            let j = 0;\n\n            for (let i = 0; i < managedTextures.length; i++)\n            {\n                if (managedTextures[i] !== null)\n                {\n                    managedTextures[j++] = managedTextures[i];\n                }\n            }\n\n            managedTextures.length = j;\n        }\n    }\n\n    /**\n     * Removes all the textures within the specified displayObject and its children from the GPU\n     *\n     * @param {PIXI.DisplayObject} displayObject - the displayObject to remove the textures from.\n     */\n    unload(displayObject)\n    {\n        const tm = this.renderer.textureManager;\n\n        // only destroy non generated textures\n        if (displayObject._texture && displayObject._texture._glRenderTargets)\n        {\n            tm.destroyTexture(displayObject._texture, true);\n        }\n\n        for (let i = displayObject.children.length - 1; i >= 0; i--)\n        {\n            this.unload(displayObject.children[i]);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"script"}