{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _Mesh2 = require('./Mesh');\n\nvar _Mesh3 = _interopRequireDefault(_Mesh2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * The rope allows you to draw a texture across several points and them manipulate these points\n *\n *```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * let rope = new PIXI.Rope(PIXI.Texture.fromImage(\"snake.png\"), points);\n *  ```\n *\n * @class\n * @extends PIXI.mesh.Mesh\n * @memberof PIXI.mesh\n *\n */\n\n\nvar Rope = function (_Mesh) {\n  _inherits(Rope, _Mesh);\n  /**\n   * @param {PIXI.Texture} texture - The texture to use on the rope.\n   * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.\n   */\n\n\n  function Rope(texture, points) {\n    _classCallCheck(this, Rope);\n    /**\n     * An array of points that determine the rope\n     *\n     * @member {PIXI.Point[]}\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _Mesh.call(this, texture));\n\n    _this.points = points;\n    /**\n     * An array of vertices used to construct this rope.\n     *\n     * @member {Float32Array}\n     */\n\n    _this.vertices = new Float32Array(points.length * 4);\n    /**\n     * The WebGL Uvs of the rope.\n     *\n     * @member {Float32Array}\n     */\n\n    _this.uvs = new Float32Array(points.length * 4);\n    /**\n     * An array containing the color components\n     *\n     * @member {Float32Array}\n     */\n\n    _this.colors = new Float32Array(points.length * 2);\n    /**\n     * An array containing the indices of the vertices\n     *\n     * @member {Uint16Array}\n     */\n\n    _this.indices = new Uint16Array(points.length * 2);\n    /**\n     * refreshes vertices on every updateTransform\n     * @member {boolean}\n     * @default true\n     */\n\n    _this.autoUpdate = true;\n\n    _this.refresh();\n\n    return _this;\n  }\n  /**\n   * Refreshes\n   *\n   */\n\n\n  Rope.prototype._refresh = function _refresh() {\n    var points = this.points; // if too little points, or texture hasn't got UVs set yet just move on.\n\n    if (points.length < 1 || !this._texture._uvs) {\n      return;\n    } // if the number of points has changed we will need to recreate the arraybuffers\n\n\n    if (this.vertices.length / 4 !== points.length) {\n      this.vertices = new Float32Array(points.length * 4);\n      this.uvs = new Float32Array(points.length * 4);\n      this.colors = new Float32Array(points.length * 2);\n      this.indices = new Uint16Array(points.length * 2);\n    }\n\n    var uvs = this.uvs;\n    var indices = this.indices;\n    var colors = this.colors;\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n    colors[0] = 1;\n    colors[1] = 1;\n    indices[0] = 0;\n    indices[1] = 1;\n    var total = points.length;\n\n    for (var i = 1; i < total; i++) {\n      // time to do some smart drawing!\n      var index = i * 4;\n      var amount = i / (total - 1);\n      uvs[index] = amount;\n      uvs[index + 1] = 0;\n      uvs[index + 2] = amount;\n      uvs[index + 3] = 1;\n      index = i * 2;\n      colors[index] = 1;\n      colors[index + 1] = 1;\n      index = i * 2;\n      indices[index] = index;\n      indices[index + 1] = index + 1;\n    } // ensure that the changes are uploaded\n\n\n    this.dirty++;\n    this.indexDirty++;\n    this.multiplyUvs();\n    this.refreshVertices();\n  };\n  /**\n   * refreshes vertices of Rope mesh\n   */\n\n\n  Rope.prototype.refreshVertices = function refreshVertices() {\n    var points = this.points;\n\n    if (points.length < 1) {\n      return;\n    }\n\n    var lastPoint = points[0];\n    var nextPoint = void 0;\n    var perpX = 0;\n    var perpY = 0; // this.count -= 0.2;\n\n    var vertices = this.vertices;\n    var total = points.length;\n\n    for (var i = 0; i < total; i++) {\n      var point = points[i];\n      var index = i * 4;\n\n      if (i < points.length - 1) {\n        nextPoint = points[i + 1];\n      } else {\n        nextPoint = point;\n      }\n\n      perpY = -(nextPoint.x - lastPoint.x);\n      perpX = nextPoint.y - lastPoint.y;\n      var ratio = (1 - i / (total - 1)) * 10;\n\n      if (ratio > 1) {\n        ratio = 1;\n      }\n\n      var perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      var num = this._texture.height / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n\n      perpX /= perpLength;\n      perpY /= perpLength;\n      perpX *= num;\n      perpY *= num;\n      vertices[index] = point.x + perpX;\n      vertices[index + 1] = point.y + perpY;\n      vertices[index + 2] = point.x - perpX;\n      vertices[index + 3] = point.y - perpY;\n      lastPoint = point;\n    }\n  };\n  /**\n   * Updates the object transform for rendering\n   *\n   * @private\n   */\n\n\n  Rope.prototype.updateTransform = function updateTransform() {\n    if (this.autoUpdate) {\n      this.refreshVertices();\n    }\n\n    this.containerUpdateTransform();\n  };\n\n  return Rope;\n}(_Mesh3.default);\n\nexports.default = Rope;","map":{"version":3,"sources":["../../src/mesh/Rope.js"],"names":["Rope","points","_refresh","uvs","indices","colors","total","i","index","amount","refreshVertices","lastPoint","nextPoint","perpX","perpY","vertices","point","ratio","perpLength","Math","num","updateTransform"],"mappings":"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","sourcesContent":["import Mesh from './Mesh';\n\n/**\n * The rope allows you to draw a texture across several points and them manipulate these points\n *\n *```js\n * for (let i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * let rope = new PIXI.Rope(PIXI.Texture.fromImage(\"snake.png\"), points);\n *  ```\n *\n * @class\n * @extends PIXI.mesh.Mesh\n * @memberof PIXI.mesh\n *\n */\nexport default class Rope extends Mesh\n{\n    /**\n     * @param {PIXI.Texture} texture - The texture to use on the rope.\n     * @param {PIXI.Point[]} points - An array of {@link PIXI.Point} objects to construct this rope.\n     */\n    constructor(texture, points)\n    {\n        super(texture);\n\n        /**\n         * An array of points that determine the rope\n         *\n         * @member {PIXI.Point[]}\n         */\n        this.points = points;\n\n        /**\n         * An array of vertices used to construct this rope.\n         *\n         * @member {Float32Array}\n         */\n        this.vertices = new Float32Array(points.length * 4);\n\n        /**\n         * The WebGL Uvs of the rope.\n         *\n         * @member {Float32Array}\n         */\n        this.uvs = new Float32Array(points.length * 4);\n\n        /**\n         * An array containing the color components\n         *\n         * @member {Float32Array}\n         */\n        this.colors = new Float32Array(points.length * 2);\n\n        /**\n         * An array containing the indices of the vertices\n         *\n         * @member {Uint16Array}\n         */\n        this.indices = new Uint16Array(points.length * 2);\n\n        /**\n         * refreshes vertices on every updateTransform\n         * @member {boolean}\n         * @default true\n         */\n        this.autoUpdate = true;\n\n        this.refresh();\n    }\n\n    /**\n     * Refreshes\n     *\n     */\n    _refresh()\n    {\n        const points = this.points;\n\n        // if too little points, or texture hasn't got UVs set yet just move on.\n        if (points.length < 1 || !this._texture._uvs)\n        {\n            return;\n        }\n\n        // if the number of points has changed we will need to recreate the arraybuffers\n        if (this.vertices.length / 4 !== points.length)\n        {\n            this.vertices = new Float32Array(points.length * 4);\n            this.uvs = new Float32Array(points.length * 4);\n            this.colors = new Float32Array(points.length * 2);\n            this.indices = new Uint16Array(points.length * 2);\n        }\n\n        const uvs = this.uvs;\n\n        const indices = this.indices;\n        const colors = this.colors;\n\n        uvs[0] = 0;\n        uvs[1] = 0;\n        uvs[2] = 0;\n        uvs[3] = 1;\n\n        colors[0] = 1;\n        colors[1] = 1;\n\n        indices[0] = 0;\n        indices[1] = 1;\n\n        const total = points.length;\n\n        for (let i = 1; i < total; i++)\n        {\n            // time to do some smart drawing!\n            let index = i * 4;\n            const amount = i / (total - 1);\n\n            uvs[index] = amount;\n            uvs[index + 1] = 0;\n\n            uvs[index + 2] = amount;\n            uvs[index + 3] = 1;\n\n            index = i * 2;\n            colors[index] = 1;\n            colors[index + 1] = 1;\n\n            index = i * 2;\n            indices[index] = index;\n            indices[index + 1] = index + 1;\n        }\n\n        // ensure that the changes are uploaded\n        this.dirty++;\n        this.indexDirty++;\n\n        this.multiplyUvs();\n        this.refreshVertices();\n    }\n\n    /**\n     * refreshes vertices of Rope mesh\n     */\n    refreshVertices()\n    {\n        const points = this.points;\n\n        if (points.length < 1)\n        {\n            return;\n        }\n\n        let lastPoint = points[0];\n        let nextPoint;\n        let perpX = 0;\n        let perpY = 0;\n\n        // this.count -= 0.2;\n\n        const vertices = this.vertices;\n        const total = points.length;\n\n        for (let i = 0; i < total; i++)\n        {\n            const point = points[i];\n            const index = i * 4;\n\n            if (i < points.length - 1)\n            {\n                nextPoint = points[i + 1];\n            }\n            else\n            {\n                nextPoint = point;\n            }\n\n            perpY = -(nextPoint.x - lastPoint.x);\n            perpX = nextPoint.y - lastPoint.y;\n\n            let ratio = (1 - (i / (total - 1))) * 10;\n\n            if (ratio > 1)\n            {\n                ratio = 1;\n            }\n\n            const perpLength = Math.sqrt((perpX * perpX) + (perpY * perpY));\n            const num = this._texture.height / 2; // (20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n\n            perpX /= perpLength;\n            perpY /= perpLength;\n\n            perpX *= num;\n            perpY *= num;\n\n            vertices[index] = point.x + perpX;\n            vertices[index + 1] = point.y + perpY;\n            vertices[index + 2] = point.x - perpX;\n            vertices[index + 3] = point.y - perpY;\n\n            lastPoint = point;\n        }\n    }\n\n    /**\n     * Updates the object transform for rendering\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        if (this.autoUpdate)\n        {\n            this.refreshVertices();\n        }\n        this.containerUpdateTransform();\n    }\n\n}\n"]},"metadata":{},"sourceType":"script"}