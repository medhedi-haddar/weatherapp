{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _core = require('../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _CanvasTinter = require('../core/sprites/canvas/CanvasTinter');\n\nvar _CanvasTinter2 = _interopRequireDefault(_CanvasTinter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar tempPoint = new core.Point();\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n */\n\nvar TilingSprite = function (_core$Sprite) {\n  _inherits(TilingSprite, _core$Sprite);\n  /**\n   * @param {PIXI.Texture} texture - the texture of the tiling sprite\n   * @param {number} [width=100] - the width of the tiling sprite\n   * @param {number} [height=100] - the height of the tiling sprite\n   */\n\n\n  function TilingSprite(texture) {\n    var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;\n\n    _classCallCheck(this, TilingSprite);\n    /**\n     * Tile transform\n     *\n     * @member {PIXI.TransformStatic}\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _core$Sprite.call(this, texture));\n\n    _this.tileTransform = new core.TransformStatic(); // /// private\n\n    /**\n     * The with of the tiling sprite\n     *\n     * @member {number}\n     * @private\n     */\n\n    _this._width = width;\n    /**\n     * The height of the tiling sprite\n     *\n     * @member {number}\n     * @private\n     */\n\n    _this._height = height;\n    /**\n     * Canvas pattern\n     *\n     * @type {CanvasPattern}\n     * @private\n     */\n\n    _this._canvasPattern = null;\n    /**\n     * transform that is applied to UV to get the texture coords\n     *\n     * @member {PIXI.TextureMatrix}\n     */\n\n    _this.uvTransform = texture.transform || new core.TextureMatrix(texture);\n    /**\n     * Plugin that is responsible for rendering this element.\n     * Allows to customize the rendering process without overriding '_renderWebGL' method.\n     *\n     * @member {string}\n     * @default 'tilingSprite'\n     */\n\n    _this.pluginName = 'tilingSprite';\n    /**\n     * Whether or not anchor affects uvs\n     *\n     * @member {boolean}\n     * @default false\n     */\n\n    _this.uvRespectAnchor = false;\n    return _this;\n  }\n  /**\n   * Changes frame clamping in corresponding textureTransform, shortcut\n   * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n   *\n   * @default 0.5\n   * @member {number}\n   */\n\n  /**\n   * @private\n   */\n\n\n  TilingSprite.prototype._onTextureUpdate = function _onTextureUpdate() {\n    if (this.uvTransform) {\n      this.uvTransform.texture = this._texture;\n    }\n\n    this.cachedTint = 0xFFFFFF;\n  };\n  /**\n   * Renders the object using the WebGL renderer\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The renderer\n   */\n\n\n  TilingSprite.prototype._renderWebGL = function _renderWebGL(renderer) {\n    // tweak our texture temporarily..\n    var texture = this._texture;\n\n    if (!texture || !texture.valid) {\n      return;\n    }\n\n    this.tileTransform.updateLocalTransform();\n    this.uvTransform.update();\n    renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n    renderer.plugins[this.pluginName].render(this);\n  };\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n   */\n\n\n  TilingSprite.prototype._renderCanvas = function _renderCanvas(renderer) {\n    var texture = this._texture;\n\n    if (!texture.baseTexture.hasLoaded) {\n      return;\n    }\n\n    var context = renderer.context;\n    var transform = this.worldTransform;\n    var resolution = renderer.resolution;\n    var isTextureRotated = texture.rotate === 2;\n    var baseTexture = texture.baseTexture;\n    var baseTextureResolution = baseTexture.resolution;\n    var modX = this.tilePosition.x / this.tileScale.x % texture.orig.width * baseTextureResolution;\n    var modY = this.tilePosition.y / this.tileScale.y % texture.orig.height * baseTextureResolution; // create a nice shiny pattern!\n\n    if (this._textureID !== this._texture._updateID || this.cachedTint !== this.tint) {\n      this._textureID = this._texture._updateID; // cut an object from a spritesheet..\n\n      var tempCanvas = new core.CanvasRenderTarget(texture.orig.width, texture.orig.height, baseTextureResolution); // Tint the tiling sprite\n\n      if (this.tint !== 0xFFFFFF) {\n        this.tintedTexture = _CanvasTinter2.default.getTintedTexture(this, this.tint);\n        tempCanvas.context.drawImage(this.tintedTexture, 0, 0);\n      } else {\n        var sx = texture._frame.x * baseTextureResolution;\n        var sy = texture._frame.y * baseTextureResolution;\n        var sWidth = texture._frame.width * baseTextureResolution;\n        var sHeight = texture._frame.height * baseTextureResolution;\n        var dWidth = (texture.trim ? texture.trim.width : texture.orig.width) * baseTextureResolution;\n        var dHeight = (texture.trim ? texture.trim.height : texture.orig.height) * baseTextureResolution;\n        var dx = (texture.trim ? texture.trim.x : 0) * baseTextureResolution;\n        var dy = (texture.trim ? texture.trim.y : 0) * baseTextureResolution;\n\n        if (isTextureRotated) {\n          // Apply rotation and transform\n          tempCanvas.context.rotate(-Math.PI / 2);\n          tempCanvas.context.translate(-dHeight, 0);\n          tempCanvas.context.drawImage(baseTexture.source, sx, sy, sWidth, sHeight, -dy, dx, dHeight, dWidth);\n        } else {\n          tempCanvas.context.drawImage(baseTexture.source, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n        }\n      }\n\n      this.cachedTint = this.tint;\n      this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n    } // set context state..\n\n\n    context.globalAlpha = this.worldAlpha;\n    context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);\n    renderer.setBlendMode(this.blendMode); // fill the pattern!\n\n    context.fillStyle = this._canvasPattern; // TODO - this should be rolled into the setTransform above..\n\n    context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n    var anchorX = this.anchor.x * -this._width * baseTextureResolution;\n    var anchorY = this.anchor.y * -this._height * baseTextureResolution;\n\n    if (this.uvRespectAnchor) {\n      context.translate(modX, modY);\n      context.fillRect(-modX + anchorX, -modY + anchorY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution);\n    } else {\n      context.translate(modX + anchorX, modY + anchorY);\n      context.fillRect(-modX, -modY, this._width / this.tileScale.x * baseTextureResolution, this._height / this.tileScale.y * baseTextureResolution);\n    }\n  };\n  /**\n   * Updates the bounds of the tiling sprite.\n   *\n   * @private\n   */\n\n\n  TilingSprite.prototype._calculateBounds = function _calculateBounds() {\n    var minX = this._width * -this._anchor._x;\n    var minY = this._height * -this._anchor._y;\n    var maxX = this._width * (1 - this._anchor._x);\n    var maxY = this._height * (1 - this._anchor._y);\n\n    this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n  };\n  /**\n   * Gets the local bounds of the sprite object.\n   *\n   * @param {PIXI.Rectangle} rect - The output rectangle.\n   * @return {PIXI.Rectangle} The bounds.\n   */\n\n\n  TilingSprite.prototype.getLocalBounds = function getLocalBounds(rect) {\n    // we can do a fast local bounds if the sprite has no children!\n    if (this.children.length === 0) {\n      this._bounds.minX = this._width * -this._anchor._x;\n      this._bounds.minY = this._height * -this._anchor._y;\n      this._bounds.maxX = this._width * (1 - this._anchor._x);\n      this._bounds.maxY = this._height * (1 - this._anchor._y);\n\n      if (!rect) {\n        if (!this._localBoundsRect) {\n          this._localBoundsRect = new core.Rectangle();\n        }\n\n        rect = this._localBoundsRect;\n      }\n\n      return this._bounds.getRectangle(rect);\n    }\n\n    return _core$Sprite.prototype.getLocalBounds.call(this, rect);\n  };\n  /**\n   * Checks if a point is inside this tiling sprite.\n   *\n   * @param {PIXI.Point} point - the point to check\n   * @return {boolean} Whether or not the sprite contains the point.\n   */\n\n\n  TilingSprite.prototype.containsPoint = function containsPoint(point) {\n    this.worldTransform.applyInverse(point, tempPoint);\n    var width = this._width;\n    var height = this._height;\n    var x1 = -width * this.anchor._x;\n\n    if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {\n      var y1 = -height * this.anchor._y;\n\n      if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * Destroys this sprite and optionally its texture and children\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n   *      method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n   * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n   */\n\n\n  TilingSprite.prototype.destroy = function destroy(options) {\n    _core$Sprite.prototype.destroy.call(this, options);\n\n    this.tileTransform = null;\n    this.uvTransform = null;\n  };\n  /**\n   * Helper function that creates a new tiling sprite based on the source you provide.\n   * The source can be - frame id, image url, video url, canvas element, video element, base texture\n   *\n   * @static\n   * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n   * @param {number} width - the width of the tiling sprite\n   * @param {number} height - the height of the tiling sprite\n   * @return {PIXI.Texture} The newly created texture\n   */\n\n\n  TilingSprite.from = function from(source, width, height) {\n    return new TilingSprite(core.Texture.from(source), width, height);\n  };\n  /**\n   * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n   * The frame ids are created when a Texture packer file has been loaded\n   *\n   * @static\n   * @param {string} frameId - The frame Id of the texture in the cache\n   * @param {number} width - the width of the tiling sprite\n   * @param {number} height - the height of the tiling sprite\n   * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n   */\n\n\n  TilingSprite.fromFrame = function fromFrame(frameId, width, height) {\n    var texture = core.utils.TextureCache[frameId];\n\n    if (!texture) {\n      throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache ' + this);\n    }\n\n    return new TilingSprite(texture, width, height);\n  };\n  /**\n   * Helper function that creates a sprite that will contain a texture based on an image url\n   * If the image is not in the texture cache it will be loaded\n   *\n   * @static\n   * @param {string} imageId - The image url of the texture\n   * @param {number} width - the width of the tiling sprite\n   * @param {number} height - the height of the tiling sprite\n   * @param {boolean} [crossorigin] - if you want to specify the cross-origin parameter\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,\n   *  see {@link PIXI.SCALE_MODES} for possible values\n   * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n   */\n\n\n  TilingSprite.fromImage = function fromImage(imageId, width, height, crossorigin, scaleMode) {\n    return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);\n  };\n  /**\n   * The width of the sprite, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   */\n\n\n  _createClass(TilingSprite, [{\n    key: 'clampMargin',\n    get: function get() {\n      return this.uvTransform.clampMargin;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.uvTransform.clampMargin = value;\n      this.uvTransform.update(true);\n    }\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n\n  }, {\n    key: 'tileScale',\n    get: function get() {\n      return this.tileTransform.scale;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.tileTransform.scale.copy(value);\n    }\n    /**\n     * The offset of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n\n  }, {\n    key: 'tilePosition',\n    get: function get() {\n      return this.tileTransform.position;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this.tileTransform.position.copy(value);\n    }\n  }, {\n    key: 'width',\n    get: function get() {\n      return this._width;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this._width = value;\n    }\n    /**\n     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n\n  }, {\n    key: 'height',\n    get: function get() {\n      return this._height;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this._height = value;\n    }\n  }]);\n\n  return TilingSprite;\n}(core.Sprite);\n\nexports.default = TilingSprite;","map":{"version":3,"sources":["../../src/extras/TilingSprite.js"],"names":["core","tempPoint","TilingSprite","Sprite","width","height","texture","value","_onTextureUpdate","_renderWebGL","renderer","_renderCanvas","context","transform","resolution","isTextureRotated","baseTexture","baseTextureResolution","modX","modY","tempCanvas","sx","sy","sWidth","sHeight","dWidth","dHeight","dx","dy","Math","anchorX","anchorY","_calculateBounds","minX","minY","maxX","maxY","getLocalBounds","rect","containsPoint","point","x1","y1","destroy","options","from","source","fromFrame","frameId","fromImage","imageId","crossorigin","scaleMode"],"mappings":"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","sourcesContent":["import * as core from '../core';\nimport CanvasTinter from '../core/sprites/canvas/CanvasTinter';\n\nconst tempPoint = new core.Point();\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n */\nexport default class TilingSprite extends core.Sprite\n{\n    /**\n     * @param {PIXI.Texture} texture - the texture of the tiling sprite\n     * @param {number} [width=100] - the width of the tiling sprite\n     * @param {number} [height=100] - the height of the tiling sprite\n     */\n    constructor(texture, width = 100, height = 100)\n    {\n        super(texture);\n\n        /**\n         * Tile transform\n         *\n         * @member {PIXI.TransformStatic}\n         */\n        this.tileTransform = new core.TransformStatic();\n\n        // /// private\n\n        /**\n         * The with of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._width = width;\n\n        /**\n         * The height of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._height = height;\n\n        /**\n         * Canvas pattern\n         *\n         * @type {CanvasPattern}\n         * @private\n         */\n        this._canvasPattern = null;\n\n        /**\n         * transform that is applied to UV to get the texture coords\n         *\n         * @member {PIXI.TextureMatrix}\n         */\n        this.uvTransform = texture.transform || new core.TextureMatrix(texture);\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_renderWebGL' method.\n         *\n         * @member {string}\n         * @default 'tilingSprite'\n         */\n        this.pluginName = 'tilingSprite';\n\n        /**\n         * Whether or not anchor affects uvs\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.uvRespectAnchor = false;\n    }\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     *\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this.uvTransform.clampMargin;\n    }\n\n    set clampMargin(value) // eslint-disable-line require-jsdoc\n    {\n        this.uvTransform.clampMargin = value;\n        this.uvTransform.update(true);\n    }\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get tileScale()\n    {\n        return this.tileTransform.scale;\n    }\n\n    set tileScale(value) // eslint-disable-line require-jsdoc\n    {\n        this.tileTransform.scale.copy(value);\n    }\n\n    /**\n     * The offset of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get tilePosition()\n    {\n        return this.tileTransform.position;\n    }\n\n    set tilePosition(value) // eslint-disable-line require-jsdoc\n    {\n        this.tileTransform.position.copy(value);\n    }\n\n    /**\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        if (this.uvTransform)\n        {\n            this.uvTransform.texture = this._texture;\n        }\n        this.cachedTint = 0xFFFFFF;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderWebGL(renderer)\n    {\n        // tweak our texture temporarily..\n        const texture = this._texture;\n\n        if (!texture || !texture.valid)\n        {\n            return;\n        }\n\n        this.tileTransform.updateLocalTransform();\n        this.uvTransform.update();\n\n        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n     */\n    _renderCanvas(renderer)\n    {\n        const texture = this._texture;\n\n        if (!texture.baseTexture.hasLoaded)\n        {\n            return;\n        }\n\n        const context = renderer.context;\n        const transform = this.worldTransform;\n        const resolution = renderer.resolution;\n        const isTextureRotated = texture.rotate === 2;\n        const baseTexture = texture.baseTexture;\n        const baseTextureResolution = baseTexture.resolution;\n        const modX = ((this.tilePosition.x / this.tileScale.x) % texture.orig.width) * baseTextureResolution;\n        const modY = ((this.tilePosition.y / this.tileScale.y) % texture.orig.height) * baseTextureResolution;\n\n        // create a nice shiny pattern!\n        if (this._textureID !== this._texture._updateID || this.cachedTint !== this.tint)\n        {\n            this._textureID = this._texture._updateID;\n            // cut an object from a spritesheet..\n            const tempCanvas = new core.CanvasRenderTarget(texture.orig.width,\n                                                        texture.orig.height,\n                                                        baseTextureResolution);\n\n            // Tint the tiling sprite\n            if (this.tint !== 0xFFFFFF)\n            {\n                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);\n                tempCanvas.context.drawImage(this.tintedTexture, 0, 0);\n            }\n            else\n            {\n                const sx = texture._frame.x * baseTextureResolution;\n                const sy = texture._frame.y * baseTextureResolution;\n                const sWidth = texture._frame.width * baseTextureResolution;\n                const sHeight = texture._frame.height * baseTextureResolution;\n                const dWidth = (texture.trim ? texture.trim.width : texture.orig.width) * baseTextureResolution;\n                const dHeight = (texture.trim ? texture.trim.height : texture.orig.height) * baseTextureResolution;\n                const dx = (texture.trim ? texture.trim.x : 0) * baseTextureResolution;\n                const dy = (texture.trim ? texture.trim.y : 0) * baseTextureResolution;\n\n                if (isTextureRotated)\n                {\n                    // Apply rotation and transform\n                    tempCanvas.context.rotate(-Math.PI / 2);\n                    tempCanvas.context.translate(-dHeight, 0);\n                    tempCanvas.context.drawImage(baseTexture.source,\n                                                sx, sy,\n                                                sWidth, sHeight,\n                                                -dy, dx,\n                                                dHeight, dWidth);\n                }\n                else\n                    {\n                    tempCanvas.context.drawImage(baseTexture.source,\n                                                sx, sy,\n                                                sWidth, sHeight,\n                                                dx, dy,\n                                                dWidth, dHeight);\n                }\n            }\n\n            this.cachedTint = this.tint;\n            this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n        }\n\n        // set context state..\n        context.globalAlpha = this.worldAlpha;\n        context.setTransform(transform.a * resolution,\n                           transform.b * resolution,\n                           transform.c * resolution,\n                           transform.d * resolution,\n                           transform.tx * resolution,\n                           transform.ty * resolution);\n\n        renderer.setBlendMode(this.blendMode);\n\n        // fill the pattern!\n        context.fillStyle = this._canvasPattern;\n\n        // TODO - this should be rolled into the setTransform above..\n        context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n\n        const anchorX = this.anchor.x * -this._width * baseTextureResolution;\n        const anchorY = this.anchor.y * -this._height * baseTextureResolution;\n\n        if (this.uvRespectAnchor)\n        {\n            context.translate(modX, modY);\n\n            context.fillRect(-modX + anchorX, -modY + anchorY,\n                this._width / this.tileScale.x * baseTextureResolution,\n                this._height / this.tileScale.y * baseTextureResolution);\n        }\n        else\n        {\n            context.translate(modX + anchorX, modY + anchorY);\n\n            context.fillRect(-modX, -modY,\n                this._width / this.tileScale.x * baseTextureResolution,\n                this._height / this.tileScale.y * baseTextureResolution);\n        }\n    }\n\n    /**\n     * Updates the bounds of the tiling sprite.\n     *\n     * @private\n     */\n    _calculateBounds()\n    {\n        const minX = this._width * -this._anchor._x;\n        const minY = this._height * -this._anchor._y;\n        const maxX = this._width * (1 - this._anchor._x);\n        const maxY = this._height * (1 - this._anchor._y);\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Gets the local bounds of the sprite object.\n     *\n     * @param {PIXI.Rectangle} rect - The output rectangle.\n     * @return {PIXI.Rectangle} The bounds.\n     */\n    getLocalBounds(rect)\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            this._bounds.minX = this._width * -this._anchor._x;\n            this._bounds.minY = this._height * -this._anchor._y;\n            this._bounds.maxX = this._width * (1 - this._anchor._x);\n            this._bounds.maxY = this._height * (1 - this._anchor._y);\n\n            if (!rect)\n            {\n                if (!this._localBoundsRect)\n                {\n                    this._localBoundsRect = new core.Rectangle();\n                }\n\n                rect = this._localBoundsRect;\n            }\n\n            return this._bounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * Checks if a point is inside this tiling sprite.\n     *\n     * @param {PIXI.Point} point - the point to check\n     * @return {boolean} Whether or not the sprite contains the point.\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this.anchor._x;\n\n        if (tempPoint.x >= x1 && tempPoint.x < x1 + width)\n        {\n            const y1 = -height * this.anchor._y;\n\n            if (tempPoint.y >= y1 && tempPoint.y < y1 + height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite and optionally its texture and children\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        this.tileTransform = null;\n        this.uvTransform = null;\n    }\n\n    /**\n     * Helper function that creates a new tiling sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static from(source, width, height)\n    {\n        return new TilingSprite(core.Texture.from(source), width, height);\n    }\n\n    /**\n     * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n     * The frame ids are created when a Texture packer file has been loaded\n     *\n     * @static\n     * @param {string} frameId - The frame Id of the texture in the cache\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n     */\n    static fromFrame(frameId, width, height)\n    {\n        const texture = core.utils.TextureCache[frameId];\n\n        if (!texture)\n        {\n            throw new Error(`The frameId \"${frameId}\" does not exist in the texture cache ${this}`);\n        }\n\n        return new TilingSprite(texture, width, height);\n    }\n\n    /**\n     * Helper function that creates a sprite that will contain a texture based on an image url\n     * If the image is not in the texture cache it will be loaded\n     *\n     * @static\n     * @param {string} imageId - The image url of the texture\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @param {boolean} [crossorigin] - if you want to specify the cross-origin parameter\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,\n     *  see {@link PIXI.SCALE_MODES} for possible values\n     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n     */\n    static fromImage(imageId, width, height, crossorigin, scaleMode)\n    {\n        return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this._width = value;\n    }\n\n    /**\n     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this._height = value;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}