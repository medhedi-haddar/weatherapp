{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _Matrix = require('./Matrix');\n\nvar _Matrix2 = _interopRequireDefault(_Matrix);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]; // Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16\n\nvar uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nvar vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nvar vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nvar tempMatrices = [];\nvar mul = [];\n\nfunction signum(x) {\n  if (x < 0) {\n    return -1;\n  }\n\n  if (x > 0) {\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction init() {\n  for (var i = 0; i < 16; i++) {\n    var row = [];\n    mul.push(row);\n\n    for (var j = 0; j < 16; j++) {\n      var _ux = signum(ux[i] * ux[j] + vx[i] * uy[j]);\n\n      var _uy = signum(uy[i] * ux[j] + vy[i] * uy[j]);\n\n      var _vx = signum(ux[i] * vx[j] + vx[i] * vy[j]);\n\n      var _vy = signum(uy[i] * vx[j] + vy[i] * vy[j]);\n\n      for (var k = 0; k < 16; k++) {\n        if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy) {\n          row.push(k);\n          break;\n        }\n      }\n    }\n  }\n\n  for (var _i = 0; _i < 16; _i++) {\n    var mat = new _Matrix2.default();\n    mat.set(ux[_i], uy[_i], vx[_i], vy[_i], 0, 0);\n    tempMatrices.push(mat);\n  }\n}\n\ninit();\n/**\n * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html},\n * D8 is the same but with diagonals. Used for texture rotations.\n *\n * Vector xX(i), xY(i) is U-axis of sprite with rotation i\n * Vector yY(i), yY(i) is V-axis of sprite with rotation i\n * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)\n * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)\n * This is the small part of gameofbombs.com portal system. It works.\n *\n * @author Ivan @ivanpopelyshev\n * @class\n * @memberof PIXI\n */\n\nvar GroupD8 = {\n  E: 0,\n  SE: 1,\n  S: 2,\n  SW: 3,\n  W: 4,\n  NW: 5,\n  N: 6,\n  NE: 7,\n  MIRROR_VERTICAL: 8,\n  MIRROR_HORIZONTAL: 12,\n  uX: function uX(ind) {\n    return ux[ind];\n  },\n  uY: function uY(ind) {\n    return uy[ind];\n  },\n  vX: function vX(ind) {\n    return vx[ind];\n  },\n  vY: function vY(ind) {\n    return vy[ind];\n  },\n  inv: function inv(rotation) {\n    if (rotation & 8) {\n      return rotation & 15;\n    }\n\n    return -rotation & 7;\n  },\n  add: function add(rotationSecond, rotationFirst) {\n    return mul[rotationSecond][rotationFirst];\n  },\n  sub: function sub(rotationSecond, rotationFirst) {\n    return mul[rotationSecond][GroupD8.inv(rotationFirst)];\n  },\n\n  /**\n   * Adds 180 degrees to rotation. Commutative operation.\n   *\n   * @memberof PIXI.GroupD8\n   * @param {number} rotation - The number to rotate.\n   * @returns {number} rotated number\n   */\n  rotate180: function rotate180(rotation) {\n    return rotation ^ 4;\n  },\n\n  /**\n   * Direction of main vector can be horizontal, vertical or diagonal.\n   * Some objects work with vertical directions different.\n   *\n   * @memberof PIXI.GroupD8\n   * @param {number} rotation - The number to check.\n   * @returns {boolean} Whether or not the direction is vertical\n   */\n  isVertical: function isVertical(rotation) {\n    return (rotation & 3) === 2;\n  },\n\n  /**\n   * @memberof PIXI.GroupD8\n   * @param {number} dx - TODO\n   * @param {number} dy - TODO\n   *\n   * @return {number} TODO\n   */\n  byDirection: function byDirection(dx, dy) {\n    if (Math.abs(dx) * 2 <= Math.abs(dy)) {\n      if (dy >= 0) {\n        return GroupD8.S;\n      }\n\n      return GroupD8.N;\n    } else if (Math.abs(dy) * 2 <= Math.abs(dx)) {\n      if (dx > 0) {\n        return GroupD8.E;\n      }\n\n      return GroupD8.W;\n    } else if (dy > 0) {\n      if (dx > 0) {\n        return GroupD8.SE;\n      }\n\n      return GroupD8.SW;\n    } else if (dx > 0) {\n      return GroupD8.NE;\n    }\n\n    return GroupD8.NW;\n  },\n\n  /**\n   * Helps sprite to compensate texture packer rotation.\n   *\n   * @memberof PIXI.GroupD8\n   * @param {PIXI.Matrix} matrix - sprite world matrix\n   * @param {number} rotation - The rotation factor to use.\n   * @param {number} tx - sprite anchoring\n   * @param {number} ty - sprite anchoring\n   */\n  matrixAppendRotationInv: function matrixAppendRotationInv(matrix, rotation) {\n    var tx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var ty = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0; // Packer used \"rotation\", we use \"inv(rotation)\"\n\n    var mat = tempMatrices[GroupD8.inv(rotation)];\n    mat.tx = tx;\n    mat.ty = ty;\n    matrix.append(mat);\n  }\n};\nexports.default = GroupD8;","map":{"version":3,"sources":["../../../src/core/math/GroupD8.js"],"names":["ux","uy","vx","vy","tempMatrices","mul","x","i","row","j","_ux","signum","_uy","_vx","_vy","k","mat","init","GroupD8","E","SE","S","SW","W","NW","N","NE","MIRROR_VERTICAL","MIRROR_HORIZONTAL","uX","uY","vX","vY","inv","rotation","add","sub","rotate180","isVertical","byDirection","Math","dy","dx","matrixAppendRotationInv","tx","ty","matrix"],"mappings":"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","sourcesContent":["// Your friendly neighbour https://en.wikipedia.org/wiki/Dihedral_group of order 16\nimport Matrix from './Matrix';\n\nconst ux = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1];\nconst uy = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vx = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1];\nconst vy = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1];\nconst tempMatrices = [];\n\nconst mul = [];\n\nfunction signum(x)\n{\n    if (x < 0)\n    {\n        return -1;\n    }\n    if (x > 0)\n    {\n        return 1;\n    }\n\n    return 0;\n}\n\nfunction init()\n{\n    for (let i = 0; i < 16; i++)\n    {\n        const row = [];\n\n        mul.push(row);\n\n        for (let j = 0; j < 16; j++)\n        {\n            const _ux = signum((ux[i] * ux[j]) + (vx[i] * uy[j]));\n            const _uy = signum((uy[i] * ux[j]) + (vy[i] * uy[j]));\n            const _vx = signum((ux[i] * vx[j]) + (vx[i] * vy[j]));\n            const _vy = signum((uy[i] * vx[j]) + (vy[i] * vy[j]));\n\n            for (let k = 0; k < 16; k++)\n            {\n                if (ux[k] === _ux && uy[k] === _uy && vx[k] === _vx && vy[k] === _vy)\n                {\n                    row.push(k);\n                    break;\n                }\n            }\n        }\n    }\n\n    for (let i = 0; i < 16; i++)\n    {\n        const mat = new Matrix();\n\n        mat.set(ux[i], uy[i], vx[i], vy[i], 0, 0);\n        tempMatrices.push(mat);\n    }\n}\n\ninit();\n\n/**\n * Implements Dihedral Group D_8, see [group D4]{@link http://mathworld.wolfram.com/DihedralGroupD4.html},\n * D8 is the same but with diagonals. Used for texture rotations.\n *\n * Vector xX(i), xY(i) is U-axis of sprite with rotation i\n * Vector yY(i), yY(i) is V-axis of sprite with rotation i\n * Rotations: 0 grad (0), 90 grad (2), 180 grad (4), 270 grad (6)\n * Mirrors: vertical (8), main diagonal (10), horizontal (12), reverse diagonal (14)\n * This is the small part of gameofbombs.com portal system. It works.\n *\n * @author Ivan @ivanpopelyshev\n * @class\n * @memberof PIXI\n */\nconst GroupD8 = {\n    E: 0,\n    SE: 1,\n    S: 2,\n    SW: 3,\n    W: 4,\n    NW: 5,\n    N: 6,\n    NE: 7,\n    MIRROR_VERTICAL: 8,\n    MIRROR_HORIZONTAL: 12,\n    uX: (ind) => ux[ind],\n    uY: (ind) => uy[ind],\n    vX: (ind) => vx[ind],\n    vY: (ind) => vy[ind],\n    inv: (rotation) =>\n    {\n        if (rotation & 8)\n        {\n            return rotation & 15;\n        }\n\n        return (-rotation) & 7;\n    },\n    add: (rotationSecond, rotationFirst) => mul[rotationSecond][rotationFirst],\n    sub: (rotationSecond, rotationFirst) => mul[rotationSecond][GroupD8.inv(rotationFirst)],\n\n    /**\n     * Adds 180 degrees to rotation. Commutative operation.\n     *\n     * @memberof PIXI.GroupD8\n     * @param {number} rotation - The number to rotate.\n     * @returns {number} rotated number\n     */\n    rotate180: (rotation) => rotation ^ 4,\n\n    /**\n     * Direction of main vector can be horizontal, vertical or diagonal.\n     * Some objects work with vertical directions different.\n     *\n     * @memberof PIXI.GroupD8\n     * @param {number} rotation - The number to check.\n     * @returns {boolean} Whether or not the direction is vertical\n     */\n    isVertical: (rotation) => (rotation & 3) === 2,\n\n    /**\n     * @memberof PIXI.GroupD8\n     * @param {number} dx - TODO\n     * @param {number} dy - TODO\n     *\n     * @return {number} TODO\n     */\n    byDirection: (dx, dy) =>\n    {\n        if (Math.abs(dx) * 2 <= Math.abs(dy))\n        {\n            if (dy >= 0)\n            {\n                return GroupD8.S;\n            }\n\n            return GroupD8.N;\n        }\n        else if (Math.abs(dy) * 2 <= Math.abs(dx))\n        {\n            if (dx > 0)\n            {\n                return GroupD8.E;\n            }\n\n            return GroupD8.W;\n        }\n        else if (dy > 0)\n        {\n            if (dx > 0)\n            {\n                return GroupD8.SE;\n            }\n\n            return GroupD8.SW;\n        }\n        else if (dx > 0)\n        {\n            return GroupD8.NE;\n        }\n\n        return GroupD8.NW;\n    },\n\n    /**\n     * Helps sprite to compensate texture packer rotation.\n     *\n     * @memberof PIXI.GroupD8\n     * @param {PIXI.Matrix} matrix - sprite world matrix\n     * @param {number} rotation - The rotation factor to use.\n     * @param {number} tx - sprite anchoring\n     * @param {number} ty - sprite anchoring\n     */\n    matrixAppendRotationInv: (matrix, rotation, tx = 0, ty = 0) =>\n    {\n        // Packer used \"rotation\", we use \"inv(rotation)\"\n        const mat = tempMatrices[GroupD8.inv(rotation)];\n\n        mat.tx = tx;\n        mat.ty = ty;\n        matrix.append(mat);\n    },\n};\n\nexport default GroupD8;\n"]},"metadata":{},"sourceType":"script"}