{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _ = require('../');\n\nvar _utils = require('../utils');\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.loader.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.loader.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @class\n * @memberof PIXI\n */\n\n\nvar Spritesheet = function () {\n  _createClass(Spritesheet, null, [{\n    key: 'BATCH_SIZE',\n\n    /**\n     * The maximum number of Textures to build per process.\n     *\n     * @type {number}\n     * @default 1000\n     */\n    get: function get() {\n      return 1000;\n    }\n    /**\n     * @param {PIXI.BaseTexture} baseTexture Reference to the source BaseTexture object.\n     * @param {Object} data - Spritesheet image data.\n     * @param {string} [resolutionFilename] - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n\n  }]);\n\n  function Spritesheet(baseTexture, data) {\n    var resolutionFilename = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, Spritesheet);\n    /**\n     * Reference to ths source texture\n     * @type {PIXI.BaseTexture}\n     */\n\n\n    this.baseTexture = baseTexture;\n    /**\n     * A map containing all textures of the sprite sheet.\n     * Can be used to create a {@link PIXI.Sprite|Sprite}:\n     * ```js\n     * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n     * ```\n     * @member {Object}\n     */\n\n    this.textures = {};\n    /**\n     * A map containing the textures for each animation.\n     * Can be used to create an {@link PIXI.extras.AnimatedSprite|AnimatedSprite}:\n     * ```js\n     * new PIXI.extras.AnimatedSprite(sheet.animations[\"anim_name\"])\n     * ```\n     * @member {Object}\n     */\n\n    this.animations = {};\n    /**\n     * Reference to the original JSON data.\n     * @type {Object}\n     */\n\n    this.data = data;\n    /**\n     * The resolution of the spritesheet.\n     * @type {number}\n     */\n\n    this.resolution = this._updateResolution(resolutionFilename || this.baseTexture.imageUrl);\n    /**\n     * Map of spritesheet frames.\n     * @type {Object}\n     * @private\n     */\n\n    this._frames = this.data.frames;\n    /**\n     * Collection of frame names.\n     * @type {string[]}\n     * @private\n     */\n\n    this._frameKeys = Object.keys(this._frames);\n    /**\n     * Current batch index being processed.\n     * @type {number}\n     * @private\n     */\n\n    this._batchIndex = 0;\n    /**\n     * Callback when parse is completed.\n     * @type {Function}\n     * @private\n     */\n\n    this._callback = null;\n  }\n  /**\n   * Generate the resolution from the filename or fallback\n   * to the meta.scale field of the JSON data.\n   *\n   * @private\n   * @param {string} resolutionFilename - The filename to use for resolving\n   *        the default resolution.\n   * @return {number} Resolution to use for spritesheet.\n   */\n\n\n  Spritesheet.prototype._updateResolution = function _updateResolution(resolutionFilename) {\n    var scale = this.data.meta.scale; // Use a defaultValue of `null` to check if a url-based resolution is set\n\n    var resolution = (0, _utils.getResolutionOfUrl)(resolutionFilename, null); // No resolution found via URL\n\n    if (resolution === null) {\n      // Use the scale value or default to 1\n      resolution = scale !== undefined ? parseFloat(scale) : 1;\n    } // For non-1 resolutions, update baseTexture\n\n\n    if (resolution !== 1) {\n      this.baseTexture.resolution = resolution;\n      this.baseTexture.update();\n    }\n\n    return resolution;\n  };\n  /**\n   * Parser spritesheet from loaded data. This is done asynchronously\n   * to prevent creating too many Texture within a single process.\n   *\n   * @param {Function} callback - Callback when complete returns\n   *        a map of the Textures for this spritesheet.\n   */\n\n\n  Spritesheet.prototype.parse = function parse(callback) {\n    this._batchIndex = 0;\n    this._callback = callback;\n\n    if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {\n      this._processFrames(0);\n\n      this._processAnimations();\n\n      this._parseComplete();\n    } else {\n      this._nextBatch();\n    }\n  };\n  /**\n   * Process a batch of frames\n   *\n   * @private\n   * @param {number} initialFrameIndex - The index of frame to start.\n   */\n\n\n  Spritesheet.prototype._processFrames = function _processFrames(initialFrameIndex) {\n    var frameIndex = initialFrameIndex;\n    var maxFrames = Spritesheet.BATCH_SIZE;\n    var sourceScale = this.baseTexture.sourceScale;\n\n    while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n      var i = this._frameKeys[frameIndex];\n      var data = this._frames[i];\n      var rect = data.frame;\n\n      if (rect) {\n        var frame = null;\n        var trim = null;\n        var sourceSize = data.trimmed !== false && data.sourceSize ? data.sourceSize : data.frame;\n        var orig = new _.Rectangle(0, 0, Math.floor(sourceSize.w * sourceScale) / this.resolution, Math.floor(sourceSize.h * sourceScale) / this.resolution);\n\n        if (data.rotated) {\n          frame = new _.Rectangle(Math.floor(rect.x * sourceScale) / this.resolution, Math.floor(rect.y * sourceScale) / this.resolution, Math.floor(rect.h * sourceScale) / this.resolution, Math.floor(rect.w * sourceScale) / this.resolution);\n        } else {\n          frame = new _.Rectangle(Math.floor(rect.x * sourceScale) / this.resolution, Math.floor(rect.y * sourceScale) / this.resolution, Math.floor(rect.w * sourceScale) / this.resolution, Math.floor(rect.h * sourceScale) / this.resolution);\n        } //  Check to see if the sprite is trimmed\n\n\n        if (data.trimmed !== false && data.spriteSourceSize) {\n          trim = new _.Rectangle(Math.floor(data.spriteSourceSize.x * sourceScale) / this.resolution, Math.floor(data.spriteSourceSize.y * sourceScale) / this.resolution, Math.floor(rect.w * sourceScale) / this.resolution, Math.floor(rect.h * sourceScale) / this.resolution);\n        }\n\n        this.textures[i] = new _.Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor); // lets also add the frame to pixi's global cache for fromFrame and fromImage functions\n\n        _.Texture.addToCache(this.textures[i], i);\n      }\n\n      frameIndex++;\n    }\n  };\n  /**\n   * Parse animations config\n   *\n   * @private\n   */\n\n\n  Spritesheet.prototype._processAnimations = function _processAnimations() {\n    var animations = this.data.animations || {};\n\n    for (var animName in animations) {\n      this.animations[animName] = [];\n\n      for (var _iterator = animations[animName], _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var frameName = _ref;\n        this.animations[animName].push(this.textures[frameName]);\n      }\n    }\n  };\n  /**\n   * The parse has completed.\n   *\n   * @private\n   */\n\n\n  Spritesheet.prototype._parseComplete = function _parseComplete() {\n    var callback = this._callback;\n    this._callback = null;\n    this._batchIndex = 0;\n    callback.call(this, this.textures);\n  };\n  /**\n   * Begin the next batch of textures.\n   *\n   * @private\n   */\n\n\n  Spritesheet.prototype._nextBatch = function _nextBatch() {\n    var _this = this;\n\n    this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n\n    this._batchIndex++;\n    setTimeout(function () {\n      if (_this._batchIndex * Spritesheet.BATCH_SIZE < _this._frameKeys.length) {\n        _this._nextBatch();\n      } else {\n        _this._processAnimations();\n\n        _this._parseComplete();\n      }\n    }, 0);\n  };\n  /**\n   * Destroy Spritesheet and don't use after this.\n   *\n   * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n   */\n\n\n  Spritesheet.prototype.destroy = function destroy() {\n    var destroyBase = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    for (var i in this.textures) {\n      this.textures[i].destroy();\n    }\n\n    this._frames = null;\n    this._frameKeys = null;\n    this.data = null;\n    this.textures = null;\n\n    if (destroyBase) {\n      this.baseTexture.destroy();\n    }\n\n    this.baseTexture = null;\n  };\n\n  return Spritesheet;\n}();\n\nexports.default = Spritesheet;","map":{"version":3,"sources":["../../../src/core/textures/Spritesheet.js"],"names":["Spritesheet","resolutionFilename","Object","_updateResolution","scale","resolution","parseFloat","parse","callback","_processFrames","initialFrameIndex","frameIndex","maxFrames","sourceScale","i","data","rect","frame","trim","sourceSize","orig","Math","_processAnimations","animations","frameName","_parseComplete","_nextBatch","setTimeout","destroy","destroyBase"],"mappings":"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","sourcesContent":["import { Rectangle, Texture } from '../';\nimport { getResolutionOfUrl } from '../utils';\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.loader.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.loader.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @class\n * @memberof PIXI\n */\nexport default class Spritesheet\n{\n    /**\n     * The maximum number of Textures to build per process.\n     *\n     * @type {number}\n     * @default 1000\n     */\n    static get BATCH_SIZE()\n    {\n        return 1000;\n    }\n\n    /**\n     * @param {PIXI.BaseTexture} baseTexture Reference to the source BaseTexture object.\n     * @param {Object} data - Spritesheet image data.\n     * @param {string} [resolutionFilename] - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n    constructor(baseTexture, data, resolutionFilename = null)\n    {\n        /**\n         * Reference to ths source texture\n         * @type {PIXI.BaseTexture}\n         */\n        this.baseTexture = baseTexture;\n\n        /**\n         * A map containing all textures of the sprite sheet.\n         * Can be used to create a {@link PIXI.Sprite|Sprite}:\n         * ```js\n         * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n         * ```\n         * @member {Object}\n         */\n        this.textures = {};\n\n        /**\n         * A map containing the textures for each animation.\n         * Can be used to create an {@link PIXI.extras.AnimatedSprite|AnimatedSprite}:\n         * ```js\n         * new PIXI.extras.AnimatedSprite(sheet.animations[\"anim_name\"])\n         * ```\n         * @member {Object}\n         */\n        this.animations = {};\n\n        /**\n         * Reference to the original JSON data.\n         * @type {Object}\n         */\n        this.data = data;\n\n        /**\n         * The resolution of the spritesheet.\n         * @type {number}\n         */\n        this.resolution = this._updateResolution(\n            resolutionFilename || this.baseTexture.imageUrl\n        );\n\n        /**\n         * Map of spritesheet frames.\n         * @type {Object}\n         * @private\n         */\n        this._frames = this.data.frames;\n\n        /**\n         * Collection of frame names.\n         * @type {string[]}\n         * @private\n         */\n        this._frameKeys = Object.keys(this._frames);\n\n        /**\n         * Current batch index being processed.\n         * @type {number}\n         * @private\n         */\n        this._batchIndex = 0;\n\n        /**\n         * Callback when parse is completed.\n         * @type {Function}\n         * @private\n         */\n        this._callback = null;\n    }\n\n    /**\n     * Generate the resolution from the filename or fallback\n     * to the meta.scale field of the JSON data.\n     *\n     * @private\n     * @param {string} resolutionFilename - The filename to use for resolving\n     *        the default resolution.\n     * @return {number} Resolution to use for spritesheet.\n     */\n    _updateResolution(resolutionFilename)\n    {\n        const scale = this.data.meta.scale;\n\n        // Use a defaultValue of `null` to check if a url-based resolution is set\n        let resolution = getResolutionOfUrl(resolutionFilename, null);\n\n        // No resolution found via URL\n        if (resolution === null)\n        {\n            // Use the scale value or default to 1\n            resolution = scale !== undefined ? parseFloat(scale) : 1;\n        }\n\n        // For non-1 resolutions, update baseTexture\n        if (resolution !== 1)\n        {\n            this.baseTexture.resolution = resolution;\n            this.baseTexture.update();\n        }\n\n        return resolution;\n    }\n\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     *\n     * @param {Function} callback - Callback when complete returns\n     *        a map of the Textures for this spritesheet.\n     */\n    parse(callback)\n    {\n        this._batchIndex = 0;\n        this._callback = callback;\n\n        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE)\n        {\n            this._processFrames(0);\n            this._processAnimations();\n            this._parseComplete();\n        }\n        else\n        {\n            this._nextBatch();\n        }\n    }\n\n    /**\n     * Process a batch of frames\n     *\n     * @private\n     * @param {number} initialFrameIndex - The index of frame to start.\n     */\n    _processFrames(initialFrameIndex)\n    {\n        let frameIndex = initialFrameIndex;\n        const maxFrames = Spritesheet.BATCH_SIZE;\n        const sourceScale = this.baseTexture.sourceScale;\n\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length)\n        {\n            const i = this._frameKeys[frameIndex];\n            const data = this._frames[i];\n            const rect = data.frame;\n\n            if (rect)\n            {\n                let frame = null;\n                let trim = null;\n                const sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n\n                const orig = new Rectangle(\n                    0,\n                    0,\n                    Math.floor(sourceSize.w * sourceScale) / this.resolution,\n                    Math.floor(sourceSize.h * sourceScale) / this.resolution\n                );\n\n                if (data.rotated)\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x * sourceScale) / this.resolution,\n                        Math.floor(rect.y * sourceScale) / this.resolution,\n                        Math.floor(rect.h * sourceScale) / this.resolution,\n                        Math.floor(rect.w * sourceScale) / this.resolution\n                    );\n                }\n                else\n                {\n                    frame = new Rectangle(\n                        Math.floor(rect.x * sourceScale) / this.resolution,\n                        Math.floor(rect.y * sourceScale) / this.resolution,\n                        Math.floor(rect.w * sourceScale) / this.resolution,\n                        Math.floor(rect.h * sourceScale) / this.resolution\n                    );\n                }\n\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize)\n                {\n                    trim = new Rectangle(\n                        Math.floor(data.spriteSourceSize.x * sourceScale) / this.resolution,\n                        Math.floor(data.spriteSourceSize.y * sourceScale) / this.resolution,\n                        Math.floor(rect.w * sourceScale) / this.resolution,\n                        Math.floor(rect.h * sourceScale) / this.resolution\n                    );\n                }\n\n                this.textures[i] = new Texture(\n                    this.baseTexture,\n                    frame,\n                    orig,\n                    trim,\n                    data.rotated ? 2 : 0,\n                    data.anchor\n                );\n\n                // lets also add the frame to pixi's global cache for fromFrame and fromImage functions\n                Texture.addToCache(this.textures[i], i);\n            }\n\n            frameIndex++;\n        }\n    }\n\n    /**\n     * Parse animations config\n     *\n     * @private\n     */\n    _processAnimations()\n    {\n        const animations = this.data.animations || {};\n\n        for (const animName in animations)\n        {\n            this.animations[animName] = [];\n            for (const frameName of animations[animName])\n            {\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    }\n\n    /**\n     * The parse has completed.\n     *\n     * @private\n     */\n    _parseComplete()\n    {\n        const callback = this._callback;\n\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    }\n\n    /**\n     * Begin the next batch of textures.\n     *\n     * @private\n     */\n    _nextBatch()\n    {\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(() =>\n        {\n            if (this._batchIndex * Spritesheet.BATCH_SIZE < this._frameKeys.length)\n            {\n                this._nextBatch();\n            }\n            else\n            {\n                this._processAnimations();\n                this._parseComplete();\n            }\n        }, 0);\n    }\n\n    /**\n     * Destroy Spritesheet and don't use after this.\n     *\n     * @param {boolean} [destroyBase=false] Whether to destroy the base texture as well\n     */\n    destroy(destroyBase = false)\n    {\n        for (const i in this.textures)\n        {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase)\n        {\n            this.baseTexture.destroy();\n        }\n        this.baseTexture = null;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}