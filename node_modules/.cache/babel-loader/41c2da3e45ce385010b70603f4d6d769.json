{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _core = require('../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _utils = require('../core/utils');\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * The ParticleContainer class is a really fast version of the Container built solely for speed,\n * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that most advanced\n * functionality will not work. ParticleContainer implements the basic object transform (position, scale, rotation)\n * and some advanced functionality like tint (as of v4.5.6).\n * Other more advanced functionality like masking, children, filters, etc will not work on sprites in this batch.\n *\n * It's extremely easy to use :\n *\n * ```js\n * let container = new ParticleContainer();\n *\n * for (let i = 0; i < 100; ++i)\n * {\n *     let sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n *     container.addChild(sprite);\n * }\n * ```\n *\n * And here you have a hundred sprites that will be rendered at the speed of light.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.particles\n */\n\n\nvar ParticleContainer = function (_core$Container) {\n  _inherits(ParticleContainer, _core$Container);\n  /**\n   * @param {number} [maxSize=1500] - The maximum number of particles that can be rendered by the container.\n   *  Affects size of allocated buffers.\n   * @param {object} [properties] - The properties of children that should be uploaded to the gpu and applied.\n   * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.\n   *                  if sprite's ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.\n   * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.\n   * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.\n   * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.\n   * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.\n   * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.\n   * @param {boolean} [autoResize=false] If true, container allocates more batches in case\n   *  there are more than `maxSize` particles.\n   */\n\n\n  function ParticleContainer() {\n    var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1500;\n    var properties = arguments[1];\n    var batchSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16384;\n    var autoResize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    _classCallCheck(this, ParticleContainer); // Making sure the batch size is valid\n    // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n    // so max number of particles is 65536 / 4 = 16384\n\n\n    var _this = _possibleConstructorReturn(this, _core$Container.call(this));\n\n    var maxBatchSize = 16384;\n\n    if (batchSize > maxBatchSize) {\n      batchSize = maxBatchSize;\n    }\n\n    if (batchSize > maxSize) {\n      batchSize = maxSize;\n    }\n    /**\n     * Set properties to be dynamic (true) / static (false)\n     *\n     * @member {boolean[]}\n     * @private\n     */\n\n\n    _this._properties = [false, true, false, false, false];\n    /**\n     * @member {number}\n     * @private\n     */\n\n    _this._maxSize = maxSize;\n    /**\n     * @member {number}\n     * @private\n     */\n\n    _this._batchSize = batchSize;\n    /**\n     * @member {object<number, WebGLBuffer>}\n     * @private\n     */\n\n    _this._glBuffers = {};\n    /**\n     * for every batch stores _updateID corresponding to the last change in that batch\n     * @member {number[]}\n     * @private\n     */\n\n    _this._bufferUpdateIDs = [];\n    /**\n     * when child inserted, removed or changes position this number goes up\n     * @member {number[]}\n     * @private\n     */\n\n    _this._updateID = 0;\n    /**\n     * @member {boolean}\n     *\n     */\n\n    _this.interactiveChildren = false;\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`\n     * to reset the blend mode.\n     *\n     * @member {number}\n     * @default PIXI.BLEND_MODES.NORMAL\n     * @see PIXI.BLEND_MODES\n     */\n\n    _this.blendMode = core.BLEND_MODES.NORMAL;\n    /**\n     * If true, container allocates more batches in case there are more than `maxSize` particles.\n     * @member {boolean}\n     * @default false\n     */\n\n    _this.autoResize = autoResize;\n    /**\n     * Used for canvas renderering. If true then the elements will be positioned at the\n     * nearest pixel. This provides a nice speed boost.\n     *\n     * @member {boolean}\n     * @default true;\n     */\n\n    _this.roundPixels = true;\n    /**\n     * The texture used to render the children.\n     *\n     * @readonly\n     * @member {BaseTexture}\n     */\n\n    _this.baseTexture = null;\n\n    _this.setProperties(properties);\n    /**\n     * The tint applied to the container.\n     * This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @private\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n\n\n    _this._tint = 0;\n    _this.tintRgb = new Float32Array(4);\n    _this.tint = 0xFFFFFF;\n    return _this;\n  }\n  /**\n   * Sets the private properties array to dynamic / static based on the passed properties object\n   *\n   * @param {object} properties - The properties to be uploaded\n   */\n\n\n  ParticleContainer.prototype.setProperties = function setProperties(properties) {\n    if (properties) {\n      this._properties[0] = 'vertices' in properties || 'scale' in properties ? !!properties.vertices || !!properties.scale : this._properties[0];\n      this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];\n      this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];\n      this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];\n      this._properties[4] = 'tint' in properties || 'alpha' in properties ? !!properties.tint || !!properties.alpha : this._properties[4];\n    }\n  };\n  /**\n   * Updates the object transform for rendering\n   *\n   * @private\n   */\n\n\n  ParticleContainer.prototype.updateTransform = function updateTransform() {\n    // TODO don't need to!\n    this.displayObjectUpdateTransform(); //  PIXI.Container.prototype.updateTransform.call( this );\n  };\n  /**\n   * The tint applied to the container. This is a hex value.\n   * A value of 0xFFFFFF will remove any tint effect.\n   ** IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n   * @member {number}\n   * @default 0xFFFFFF\n   */\n\n  /**\n   * Renders the container using the WebGL renderer\n   *\n   * @private\n   * @param {PIXI.WebGLRenderer} renderer - The webgl renderer\n   */\n\n\n  ParticleContainer.prototype.renderWebGL = function renderWebGL(renderer) {\n    var _this2 = this;\n\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {\n      return;\n    }\n\n    if (!this.baseTexture) {\n      this.baseTexture = this.children[0]._texture.baseTexture;\n\n      if (!this.baseTexture.hasLoaded) {\n        this.baseTexture.once('update', function () {\n          return _this2.onChildrenChange(0);\n        });\n      }\n    }\n\n    renderer.setObjectRenderer(renderer.plugins.particle);\n    renderer.plugins.particle.render(this);\n  };\n  /**\n   * Set the flag that static data should be updated to true\n   *\n   * @private\n   * @param {number} smallestChildIndex - The smallest child index\n   */\n\n\n  ParticleContainer.prototype.onChildrenChange = function onChildrenChange(smallestChildIndex) {\n    var bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n\n    while (this._bufferUpdateIDs.length < bufferIndex) {\n      this._bufferUpdateIDs.push(0);\n    }\n\n    this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n  };\n  /**\n   * Renders the object using the Canvas renderer\n   *\n   * @private\n   * @param {PIXI.CanvasRenderer} renderer - The canvas renderer\n   */\n\n\n  ParticleContainer.prototype.renderCanvas = function renderCanvas(renderer) {\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {\n      return;\n    }\n\n    var context = renderer.context;\n    var transform = this.worldTransform;\n    var isRotated = true;\n    var positionX = 0;\n    var positionY = 0;\n    var finalWidth = 0;\n    var finalHeight = 0;\n    renderer.setBlendMode(this.blendMode);\n    context.globalAlpha = this.worldAlpha;\n    this.displayObjectUpdateTransform();\n\n    for (var i = 0; i < this.children.length; ++i) {\n      var child = this.children[i];\n\n      if (!child.visible) {\n        continue;\n      }\n\n      var frame = child._texture.frame;\n      context.globalAlpha = this.worldAlpha * child.alpha;\n\n      if (child.rotation % (Math.PI * 2) === 0) {\n        // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n        if (isRotated) {\n          context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx * renderer.resolution, transform.ty * renderer.resolution);\n          isRotated = false;\n        }\n\n        positionX = child.anchor.x * (-frame.width * child.scale.x) + child.position.x + 0.5;\n        positionY = child.anchor.y * (-frame.height * child.scale.y) + child.position.y + 0.5;\n        finalWidth = frame.width * child.scale.x;\n        finalHeight = frame.height * child.scale.y;\n      } else {\n        if (!isRotated) {\n          isRotated = true;\n        }\n\n        child.displayObjectUpdateTransform();\n        var childTransform = child.worldTransform;\n\n        if (renderer.roundPixels) {\n          context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx * renderer.resolution | 0, childTransform.ty * renderer.resolution | 0);\n        } else {\n          context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx * renderer.resolution, childTransform.ty * renderer.resolution);\n        }\n\n        positionX = child.anchor.x * -frame.width + 0.5;\n        positionY = child.anchor.y * -frame.height + 0.5;\n        finalWidth = frame.width;\n        finalHeight = frame.height;\n      }\n\n      var resolution = child._texture.baseTexture.resolution;\n      context.drawImage(child._texture.baseTexture.source, frame.x * resolution, frame.y * resolution, frame.width * resolution, frame.height * resolution, positionX * renderer.resolution, positionY * renderer.resolution, finalWidth * renderer.resolution, finalHeight * renderer.resolution);\n    }\n  };\n  /**\n   * Destroys the container\n   *\n   * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.children=false] - if set to true, all the children will have their\n   *  destroy method called as well. 'options' will be passed on to those calls.\n   * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the texture of the child sprite\n   * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n   *  Should it destroy the base texture of the child sprite\n   */\n\n\n  ParticleContainer.prototype.destroy = function destroy(options) {\n    _core$Container.prototype.destroy.call(this, options);\n\n    if (this._buffers) {\n      for (var i = 0; i < this._buffers.length; ++i) {\n        this._buffers[i].destroy();\n      }\n    }\n\n    this._properties = null;\n    this._buffers = null;\n    this._bufferUpdateIDs = null;\n  };\n\n  _createClass(ParticleContainer, [{\n    key: 'tint',\n    get: function get() {\n      return this._tint;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      this._tint = value;\n      (0, _utils.hex2rgb)(value, this.tintRgb);\n    }\n  }]);\n\n  return ParticleContainer;\n}(core.Container);\n\nexports.default = ParticleContainer;","map":{"version":3,"sources":["../../src/particles/ParticleContainer.js"],"names":["core","ParticleContainer","Container","maxSize","properties","batchSize","autoResize","maxBatchSize","setProperties","updateTransform","value","renderWebGL","renderer","onChildrenChange","smallestChildIndex","bufferIndex","Math","renderCanvas","context","transform","isRotated","positionX","positionY","finalWidth","finalHeight","i","child","frame","childTransform","resolution","destroy","options"],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,IAAA,KAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;IAAYA,I;;AACZ,IAAA,MAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;IAyBqBC,iB;;AAEjB;;;;;;;;;;;;;;;;AAcA,WAAA,iBAAA,GACA;AAAA,QADYE,OACZ,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADsB,IACtB;AAAA,QAD4BC,UAC5B,GAAA,SAAA,CAAA,CAAA,CAAA;AAAA,QADwCC,SACxC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADoD,KACpD;AAAA,QAD2DC,UAC3D,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADwE,KACxE;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,iBAAA,CAAA,CAAA,CAGI;AACA;AACA;;;AALJ,QAAA,KAAA,GAAA,0BAAA,CAAA,IAAA,EACI,eAAA,CAAA,IAAA,CADJ,IACI,CADJ,CAAA;;AAMI,QAAMC,YAAAA,GAAN,KAAA;;AAEA,QAAIF,SAAAA,GAAJ,YAAA,EACA;AACIA,MAAAA,SAAAA,GAAAA,YAAAA;AACH;;AAED,QAAIA,SAAAA,GAAJ,OAAA,EACA;AACIA,MAAAA,SAAAA,GAAAA,OAAAA;AACH;AAED;;;;;;;;AAMA,IAAA,KAAA,CAAA,WAAA,GAAmB,CAAA,KAAA,EAAA,IAAA,EAAA,KAAA,EAAA,KAAA,EAAnB,KAAmB,CAAnB;AAEA;;;;;AAIA,IAAA,KAAA,CAAA,QAAA,GAAA,OAAA;AAEA;;;;;AAIA,IAAA,KAAA,CAAA,UAAA,GAAA,SAAA;AAEA;;;;;AAIA,IAAA,KAAA,CAAA,UAAA,GAAA,EAAA;AAEA;;;;;;AAKA,IAAA,KAAA,CAAA,gBAAA,GAAA,EAAA;AAEA;;;;;;AAKA,IAAA,KAAA,CAAA,SAAA,GAAA,CAAA;AAEA;;;;;AAIA,IAAA,KAAA,CAAA,mBAAA,GAAA,KAAA;AAEA;;;;;;;;;AAQA,IAAA,KAAA,CAAA,SAAA,GAAiBL,IAAAA,CAAAA,WAAAA,CAAjB,MAAA;AAEA;;;;;;AAKA,IAAA,KAAA,CAAA,UAAA,GAAA,UAAA;AAEA;;;;;;;;AAOA,IAAA,KAAA,CAAA,WAAA,GAAA,IAAA;AAEA;;;;;;;AAMA,IAAA,KAAA,CAAA,WAAA,GAAA,IAAA;;AAEA,IAAA,KAAA,CAAA,aAAA,CAAA,UAAA;AAEA;;;;;;;;;;AAQA,IAAA,KAAA,CAAA,KAAA,GAAA,CAAA;AACA,IAAA,KAAA,CAAA,OAAA,GAAe,IAAA,YAAA,CAAf,CAAe,CAAf;AACA,IAAA,KAAA,CAAA,IAAA,GAAA,QAAA;AA9GJ,WAAA,KAAA;AA+GC;AAED;;;;;;;8BAKAQ,a,0BAAcJ,U,EACd;AACI,QAAA,UAAA,EACA;AACI,WAAA,WAAA,CAAA,CAAA,IAAsB,cAAA,UAAA,IAA4B,WAA5B,UAAA,GAChB,CAAC,CAACA,UAAAA,CAAF,QAAA,IAAyB,CAAC,CAACA,UAAAA,CADX,KAAA,GAC8B,KAAA,WAAA,CADpD,CACoD,CADpD;AAEA,WAAA,WAAA,CAAA,CAAA,IAAsB,cAAA,UAAA,GAA2B,CAAC,CAACA,UAAAA,CAA7B,QAAA,GAAmD,KAAA,WAAA,CAAzE,CAAyE,CAAzE;AACA,WAAA,WAAA,CAAA,CAAA,IAAsB,cAAA,UAAA,GAA2B,CAAC,CAACA,UAAAA,CAA7B,QAAA,GAAmD,KAAA,WAAA,CAAzE,CAAyE,CAAzE;AACA,WAAA,WAAA,CAAA,CAAA,IAAsB,SAAA,UAAA,GAAsB,CAAC,CAACA,UAAAA,CAAxB,GAAA,GAAyC,KAAA,WAAA,CAA/D,CAA+D,CAA/D;AACA,WAAA,WAAA,CAAA,CAAA,IAAsB,UAAA,UAAA,IAAwB,WAAxB,UAAA,GAChB,CAAC,CAACA,UAAAA,CAAF,IAAA,IAAqB,CAAC,CAACA,UAAAA,CADP,KAAA,GAC0B,KAAA,WAAA,CADhD,CACgD,CADhD;AAEH;;AAGL;;;;;;;8BAKAK,e,8BACA;AACI;AACA,SAAA,4BAAA,GAFJ,CAGI;;AAGJ;;;;;;;;AAkBA;;;;;;;;8BAMAE,W,wBAAYC,Q,EACZ;AAAA,QAAA,MAAA,GAAA,IAAA;;AACI,QAAI,CAAC,KAAD,OAAA,IAAiB,KAAA,UAAA,IAAjB,CAAA,IAAyC,CAAC,KAAA,QAAA,CAA1C,MAAA,IAAkE,CAAC,KAAvE,UAAA,EACA;AACI;AACH;;AAED,QAAI,CAAC,KAAL,WAAA,EACA;AACI,WAAA,WAAA,GAAmB,KAAA,QAAA,CAAA,CAAA,EAAA,QAAA,CAAnB,WAAA;;AACA,UAAI,CAAC,KAAA,WAAA,CAAL,SAAA,EACA;AACI,aAAA,WAAA,CAAA,IAAA,CAAA,QAAA,EAAgC,YAAA;AAAA,iBAAM,MAAA,CAAA,gBAAA,CAAN,CAAM,CAAN;AAAhC,SAAA;AACH;AACJ;;AAEDA,IAAAA,QAAAA,CAAAA,iBAAAA,CAA2BA,QAAAA,CAAAA,OAAAA,CAA3BA,QAAAA;AACAA,IAAAA,QAAAA,CAAAA,OAAAA,CAAAA,QAAAA,CAAAA,MAAAA,CAAAA,IAAAA;;AAGJ;;;;;;;;8BAMAC,gB,6BAAiBC,kB,EACjB;AACI,QAAMC,WAAAA,GAAcC,IAAAA,CAAAA,KAAAA,CAAWF,kBAAAA,GAAqB,KAApD,UAAoBE,CAApB;;AAEA,WAAO,KAAA,gBAAA,CAAA,MAAA,GAAP,WAAA,EACA;AACI,WAAA,gBAAA,CAAA,IAAA,CAAA,CAAA;AACH;;AACD,SAAA,gBAAA,CAAA,WAAA,IAAqC,EAAE,KAAvC,SAAA;;AAGJ;;;;;;;;8BAMAC,Y,yBAAaL,Q,EACb;AACI,QAAI,CAAC,KAAD,OAAA,IAAiB,KAAA,UAAA,IAAjB,CAAA,IAAyC,CAAC,KAAA,QAAA,CAA1C,MAAA,IAAkE,CAAC,KAAvE,UAAA,EACA;AACI;AACH;;AAED,QAAMM,OAAAA,GAAUN,QAAAA,CAAhB,OAAA;AACA,QAAMO,SAAAA,GAAY,KAAlB,cAAA;AACA,QAAIC,SAAAA,GAAJ,IAAA;AAEA,QAAIC,SAAAA,GAAJ,CAAA;AACA,QAAIC,SAAAA,GAAJ,CAAA;AAEA,QAAIC,UAAAA,GAAJ,CAAA;AACA,QAAIC,WAAAA,GAAJ,CAAA;AAEAZ,IAAAA,QAAAA,CAAAA,YAAAA,CAAsB,KAAtBA,SAAAA;AAEAM,IAAAA,OAAAA,CAAAA,WAAAA,GAAsB,KAAtBA,UAAAA;AAEA,SAAA,4BAAA;;AAEA,SAAK,IAAIO,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAI,KAAA,QAAA,CAApB,MAAA,EAA0C,EAA1C,CAAA,EACA;AACI,UAAMC,KAAAA,GAAQ,KAAA,QAAA,CAAd,CAAc,CAAd;;AAEA,UAAI,CAACA,KAAAA,CAAL,OAAA,EACA;AACI;AACH;;AAED,UAAMC,KAAAA,GAAQD,KAAAA,CAAAA,QAAAA,CAAd,KAAA;AAEAR,MAAAA,OAAAA,CAAAA,WAAAA,GAAsB,KAAA,UAAA,GAAkBQ,KAAAA,CAAxCR,KAAAA;;AAEA,UAAIQ,KAAAA,CAAAA,QAAAA,IAAkBV,IAAAA,CAAAA,EAAAA,GAAlBU,CAAAA,MAAJ,CAAA,EACA;AACI;AACA,YAAA,SAAA,EACA;AACIR,UAAAA,OAAAA,CAAAA,YAAAA,CACIC,SAAAA,CADJD,CAAAA,EAEIC,SAAAA,CAFJD,CAAAA,EAGIC,SAAAA,CAHJD,CAAAA,EAIIC,SAAAA,CAJJD,CAAAA,EAKIC,SAAAA,CAAAA,EAAAA,GAAeP,QAAAA,CALnBM,UAAAA,EAMIC,SAAAA,CAAAA,EAAAA,GAAeP,QAAAA,CANnBM,UAAAA;AASAE,UAAAA,SAAAA,GAAAA,KAAAA;AACH;;AAEDC,QAAAA,SAAAA,GAAcK,KAAAA,CAAAA,MAAAA,CAAD,CAACA,IAAmB,CAACC,KAAAA,CAAD,KAAA,GAAeD,KAAAA,CAAAA,KAAAA,CAApC,CAAEA,IAAoDA,KAAAA,CAAAA,QAAAA,CAAtD,CAAEA,GAAdL,GAAAA;AACAC,QAAAA,SAAAA,GAAcI,KAAAA,CAAAA,MAAAA,CAAD,CAACA,IAAmB,CAACC,KAAAA,CAAD,MAAA,GAAgBD,KAAAA,CAAAA,KAAAA,CAArC,CAAEA,IAAqDA,KAAAA,CAAAA,QAAAA,CAAvD,CAAEA,GAAdJ,GAAAA;AAEAC,QAAAA,UAAAA,GAAaI,KAAAA,CAAAA,KAAAA,GAAcD,KAAAA,CAAAA,KAAAA,CAA3BH,CAAAA;AACAC,QAAAA,WAAAA,GAAcG,KAAAA,CAAAA,MAAAA,GAAeD,KAAAA,CAAAA,KAAAA,CAA7BF,CAAAA;AArBJ,OAAA,MAwBA;AACI,YAAI,CAAJ,SAAA,EACA;AACIJ,UAAAA,SAAAA,GAAAA,IAAAA;AACH;;AAEDM,QAAAA,KAAAA,CAAAA,4BAAAA;AAEA,YAAME,cAAAA,GAAiBF,KAAAA,CAAvB,cAAA;;AAEA,YAAId,QAAAA,CAAJ,WAAA,EACA;AACIM,UAAAA,OAAAA,CAAAA,YAAAA,CACIU,cAAAA,CADJV,CAAAA,EAEIU,cAAAA,CAFJV,CAAAA,EAGIU,cAAAA,CAHJV,CAAAA,EAIIU,cAAAA,CAJJV,CAAAA,EAKKU,cAAAA,CAAAA,EAAAA,GAAoBhB,QAAAA,CAArB,UAACgB,GALLV,CAAAA,EAMKU,cAAAA,CAAAA,EAAAA,GAAoBhB,QAAAA,CAArB,UAACgB,GANLV,CAAAA;AAFJ,SAAA,MAYA;AACIA,UAAAA,OAAAA,CAAAA,YAAAA,CACIU,cAAAA,CADJV,CAAAA,EAEIU,cAAAA,CAFJV,CAAAA,EAGIU,cAAAA,CAHJV,CAAAA,EAIIU,cAAAA,CAJJV,CAAAA,EAKIU,cAAAA,CAAAA,EAAAA,GAAoBhB,QAAAA,CALxBM,UAAAA,EAMIU,cAAAA,CAAAA,EAAAA,GAAoBhB,QAAAA,CANxBM,UAAAA;AAQH;;AAEDG,QAAAA,SAAAA,GAAcK,KAAAA,CAAAA,MAAAA,CAAD,CAACA,GAAmB,CAACC,KAAAA,CAAtB,KAAED,GAAdL,GAAAA;AACAC,QAAAA,SAAAA,GAAcI,KAAAA,CAAAA,MAAAA,CAAD,CAACA,GAAmB,CAACC,KAAAA,CAAtB,MAAED,GAAdJ,GAAAA;AAEAC,QAAAA,UAAAA,GAAaI,KAAAA,CAAbJ,KAAAA;AACAC,QAAAA,WAAAA,GAAcG,KAAAA,CAAdH,MAAAA;AACH;;AAED,UAAMK,UAAAA,GAAaH,KAAAA,CAAAA,QAAAA,CAAAA,WAAAA,CAAnB,UAAA;AAEAR,MAAAA,OAAAA,CAAAA,SAAAA,CACIQ,KAAAA,CAAAA,QAAAA,CAAAA,WAAAA,CADJR,MAAAA,EAEIS,KAAAA,CAAAA,CAAAA,GAFJT,UAAAA,EAGIS,KAAAA,CAAAA,CAAAA,GAHJT,UAAAA,EAIIS,KAAAA,CAAAA,KAAAA,GAJJT,UAAAA,EAKIS,KAAAA,CAAAA,MAAAA,GALJT,UAAAA,EAMIG,SAAAA,GAAYT,QAAAA,CANhBM,UAAAA,EAOII,SAAAA,GAAYV,QAAAA,CAPhBM,UAAAA,EAQIK,UAAAA,GAAaX,QAAAA,CARjBM,UAAAA,EASIM,WAAAA,GAAcZ,QAAAA,CATlBM,UAAAA;AAWH;;AAGL;;;;;;;;;;;;;;8BAYAY,O,oBAAQC,O,EACR;AACI,IAAA,eAAA,CAAA,SAAA,CAAA,OAAA,CAAA,IAAA,CAAA,IAAA,EAAA,OAAA;;AAEA,QAAI,KAAJ,QAAA,EACA;AACI,WAAK,IAAIN,CAAAA,GAAT,CAAA,EAAgBA,CAAAA,GAAI,KAAA,QAAA,CAApB,MAAA,EAA0C,EAA1C,CAAA,EACA;AACI,aAAA,QAAA,CAAA,CAAA,EAAA,OAAA;AACH;AACJ;;AAED,SAAA,WAAA,GAAA,IAAA;AACA,SAAA,QAAA,GAAA,IAAA;AACA,SAAA,gBAAA,GAAA,IAAA;;;;;wBAzMJ;AACI,aAAO,KAAP,KAAA;;sBAGKf,K,EAAO;AAChB;AACI,WAAA,KAAA,GAAA,KAAA;AACA,OAAA,GAAA,MAAA,CAAA,OAAA,EAAA,KAAA,EAAe,KAAf,OAAA;AACH;;;;EAjL0CV,IAAAA,CAAKE,S;;kBAA/BD,iB","sourcesContent":["import * as core from '../core';\nimport { hex2rgb } from '../core/utils';\n\n/**\n * The ParticleContainer class is a really fast version of the Container built solely for speed,\n * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that most advanced\n * functionality will not work. ParticleContainer implements the basic object transform (position, scale, rotation)\n * and some advanced functionality like tint (as of v4.5.6).\n * Other more advanced functionality like masking, children, filters, etc will not work on sprites in this batch.\n *\n * It's extremely easy to use :\n *\n * ```js\n * let container = new ParticleContainer();\n *\n * for (let i = 0; i < 100; ++i)\n * {\n *     let sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n *     container.addChild(sprite);\n * }\n * ```\n *\n * And here you have a hundred sprites that will be rendered at the speed of light.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.particles\n */\nexport default class ParticleContainer extends core.Container\n{\n    /**\n     * @param {number} [maxSize=1500] - The maximum number of particles that can be rendered by the container.\n     *  Affects size of allocated buffers.\n     * @param {object} [properties] - The properties of children that should be uploaded to the gpu and applied.\n     * @param {boolean} [properties.vertices=false] - When true, vertices be uploaded and applied.\n     *                  if sprite's ` scale/anchor/trim/frame/orig` is dynamic, please set `true`.\n     * @param {boolean} [properties.position=true] - When true, position be uploaded and applied.\n     * @param {boolean} [properties.rotation=false] - When true, rotation be uploaded and applied.\n     * @param {boolean} [properties.uvs=false] - When true, uvs be uploaded and applied.\n     * @param {boolean} [properties.tint=false] - When true, alpha and tint be uploaded and applied.\n     * @param {number} [batchSize=16384] - Number of particles per batch. If less than maxSize, it uses maxSize instead.\n     * @param {boolean} [autoResize=false] If true, container allocates more batches in case\n     *  there are more than `maxSize` particles.\n     */\n    constructor(maxSize = 1500, properties, batchSize = 16384, autoResize = false)\n    {\n        super();\n\n        // Making sure the batch size is valid\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        const maxBatchSize = 16384;\n\n        if (batchSize > maxBatchSize)\n        {\n            batchSize = maxBatchSize;\n        }\n\n        if (batchSize > maxSize)\n        {\n            batchSize = maxSize;\n        }\n\n        /**\n         * Set properties to be dynamic (true) / static (false)\n         *\n         * @member {boolean[]}\n         * @private\n         */\n        this._properties = [false, true, false, false, false];\n\n        /**\n         * @member {number}\n         * @private\n         */\n        this._maxSize = maxSize;\n\n        /**\n         * @member {number}\n         * @private\n         */\n        this._batchSize = batchSize;\n\n        /**\n         * @member {object<number, WebGLBuffer>}\n         * @private\n         */\n        this._glBuffers = {};\n\n        /**\n         * for every batch stores _updateID corresponding to the last change in that batch\n         * @member {number[]}\n         * @private\n         */\n        this._bufferUpdateIDs = [];\n\n        /**\n         * when child inserted, removed or changes position this number goes up\n         * @member {number[]}\n         * @private\n         */\n        this._updateID = 0;\n\n        /**\n         * @member {boolean}\n         *\n         */\n        this.interactiveChildren = false;\n\n        /**\n         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL`\n         * to reset the blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL\n         * @see PIXI.BLEND_MODES\n         */\n        this.blendMode = core.BLEND_MODES.NORMAL;\n\n        /**\n         * If true, container allocates more batches in case there are more than `maxSize` particles.\n         * @member {boolean}\n         * @default false\n         */\n        this.autoResize = autoResize;\n\n        /**\n         * Used for canvas renderering. If true then the elements will be positioned at the\n         * nearest pixel. This provides a nice speed boost.\n         *\n         * @member {boolean}\n         * @default true;\n         */\n        this.roundPixels = true;\n\n        /**\n         * The texture used to render the children.\n         *\n         * @readonly\n         * @member {BaseTexture}\n         */\n        this.baseTexture = null;\n\n        this.setProperties(properties);\n\n        /**\n         * The tint applied to the container.\n         * This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n         *\n         * @private\n         * @member {number}\n         * @default 0xFFFFFF\n         */\n        this._tint = 0;\n        this.tintRgb = new Float32Array(4);\n        this.tint = 0xFFFFFF;\n    }\n\n    /**\n     * Sets the private properties array to dynamic / static based on the passed properties object\n     *\n     * @param {object} properties - The properties to be uploaded\n     */\n    setProperties(properties)\n    {\n        if (properties)\n        {\n            this._properties[0] = 'vertices' in properties || 'scale' in properties\n                ? !!properties.vertices || !!properties.scale : this._properties[0];\n            this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];\n            this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];\n            this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];\n            this._properties[4] = 'tint' in properties || 'alpha' in properties\n                ? !!properties.tint || !!properties.alpha : this._properties[4];\n        }\n    }\n\n    /**\n     * Updates the object transform for rendering\n     *\n     * @private\n     */\n    updateTransform()\n    {\n        // TODO don't need to!\n        this.displayObjectUpdateTransform();\n        //  PIXI.Container.prototype.updateTransform.call( this );\n    }\n\n    /**\n     * The tint applied to the container. This is a hex value.\n     * A value of 0xFFFFFF will remove any tint effect.\n     ** IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    get tint()\n    {\n        return this._tint;\n    }\n\n    set tint(value) // eslint-disable-line require-jsdoc\n    {\n        this._tint = value;\n        hex2rgb(value, this.tintRgb);\n    }\n\n    /**\n     * Renders the container using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The webgl renderer\n     */\n    renderWebGL(renderer)\n    {\n        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n        {\n            return;\n        }\n\n        if (!this.baseTexture)\n        {\n            this.baseTexture = this.children[0]._texture.baseTexture;\n            if (!this.baseTexture.hasLoaded)\n            {\n                this.baseTexture.once('update', () => this.onChildrenChange(0));\n            }\n        }\n\n        renderer.setObjectRenderer(renderer.plugins.particle);\n        renderer.plugins.particle.render(this);\n    }\n\n    /**\n     * Set the flag that static data should be updated to true\n     *\n     * @private\n     * @param {number} smallestChildIndex - The smallest child index\n     */\n    onChildrenChange(smallestChildIndex)\n    {\n        const bufferIndex = Math.floor(smallestChildIndex / this._batchSize);\n\n        while (this._bufferUpdateIDs.length < bufferIndex)\n        {\n            this._bufferUpdateIDs.push(0);\n        }\n        this._bufferUpdateIDs[bufferIndex] = ++this._updateID;\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer\n     */\n    renderCanvas(renderer)\n    {\n        if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n        {\n            return;\n        }\n\n        const context = renderer.context;\n        const transform = this.worldTransform;\n        let isRotated = true;\n\n        let positionX = 0;\n        let positionY = 0;\n\n        let finalWidth = 0;\n        let finalHeight = 0;\n\n        renderer.setBlendMode(this.blendMode);\n\n        context.globalAlpha = this.worldAlpha;\n\n        this.displayObjectUpdateTransform();\n\n        for (let i = 0; i < this.children.length; ++i)\n        {\n            const child = this.children[i];\n\n            if (!child.visible)\n            {\n                continue;\n            }\n\n            const frame = child._texture.frame;\n\n            context.globalAlpha = this.worldAlpha * child.alpha;\n\n            if (child.rotation % (Math.PI * 2) === 0)\n            {\n                // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n                if (isRotated)\n                {\n                    context.setTransform(\n                        transform.a,\n                        transform.b,\n                        transform.c,\n                        transform.d,\n                        transform.tx * renderer.resolution,\n                        transform.ty * renderer.resolution\n                    );\n\n                    isRotated = false;\n                }\n\n                positionX = ((child.anchor.x) * (-frame.width * child.scale.x)) + child.position.x + 0.5;\n                positionY = ((child.anchor.y) * (-frame.height * child.scale.y)) + child.position.y + 0.5;\n\n                finalWidth = frame.width * child.scale.x;\n                finalHeight = frame.height * child.scale.y;\n            }\n            else\n            {\n                if (!isRotated)\n                {\n                    isRotated = true;\n                }\n\n                child.displayObjectUpdateTransform();\n\n                const childTransform = child.worldTransform;\n\n                if (renderer.roundPixels)\n                {\n                    context.setTransform(\n                        childTransform.a,\n                        childTransform.b,\n                        childTransform.c,\n                        childTransform.d,\n                        (childTransform.tx * renderer.resolution) | 0,\n                        (childTransform.ty * renderer.resolution) | 0\n                    );\n                }\n                else\n                {\n                    context.setTransform(\n                        childTransform.a,\n                        childTransform.b,\n                        childTransform.c,\n                        childTransform.d,\n                        childTransform.tx * renderer.resolution,\n                        childTransform.ty * renderer.resolution\n                    );\n                }\n\n                positionX = ((child.anchor.x) * (-frame.width)) + 0.5;\n                positionY = ((child.anchor.y) * (-frame.height)) + 0.5;\n\n                finalWidth = frame.width;\n                finalHeight = frame.height;\n            }\n\n            const resolution = child._texture.baseTexture.resolution;\n\n            context.drawImage(\n                child._texture.baseTexture.source,\n                frame.x * resolution,\n                frame.y * resolution,\n                frame.width * resolution,\n                frame.height * resolution,\n                positionX * renderer.resolution,\n                positionY * renderer.resolution,\n                finalWidth * renderer.resolution,\n                finalHeight * renderer.resolution\n            );\n        }\n    }\n\n    /**\n     * Destroys the container\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their\n     *  destroy method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the texture of the child sprite\n     * @param {boolean} [options.baseTexture=false] - Only used for child Sprites if options.children is set to true\n     *  Should it destroy the base texture of the child sprite\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        if (this._buffers)\n        {\n            for (let i = 0; i < this._buffers.length; ++i)\n            {\n                this._buffers[i].destroy();\n            }\n        }\n\n        this._properties = null;\n        this._buffers = null;\n        this._bufferUpdateIDs = null;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}