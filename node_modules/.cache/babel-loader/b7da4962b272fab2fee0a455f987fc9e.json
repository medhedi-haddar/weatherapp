{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _BaseTexture2 = require('./BaseTexture');\n\nvar _BaseTexture3 = _interopRequireDefault(_BaseTexture2);\n\nvar _utils = require('../utils');\n\nvar _ticker = require('../ticker');\n\nvar _const = require('../const');\n\nvar _determineCrossOrigin = require('../utils/determineCrossOrigin');\n\nvar _determineCrossOrigin2 = _interopRequireDefault(_determineCrossOrigin);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * A texture of a [playing] Video.\n *\n * Video base textures mimic PixiJS BaseTexture.from.... method in their creation process.\n *\n * This can be used in several ways, such as:\n *\n * ```js\n * let texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');\n *\n * let texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls([\n *     { src: '/video.webm', mime: 'video/webm' },\n *     { src: '/video.mp4', mime: 'video/mp4' }\n * ]);\n * ```\n *\n * See the [\"deus\" demo](http://www.goodboydigital.com/pixijs/examples/deus/).\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n */\n\n\nvar VideoBaseTexture = function (_BaseTexture) {\n  _inherits(VideoBaseTexture, _BaseTexture);\n  /**\n   * @param {HTMLVideoElement} source - Video source\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   */\n\n\n  function VideoBaseTexture(source, scaleMode) {\n    var autoPlay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    _classCallCheck(this, VideoBaseTexture);\n\n    if (!source) {\n      throw new Error('No video source element specified.');\n    } // hook in here to check if video is already available.\n    // BaseTexture looks for a source.complete boolean, plus width & height.\n\n\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n      source.complete = true;\n    }\n\n    var _this = _possibleConstructorReturn(this, _BaseTexture.call(this, source, scaleMode));\n\n    _this.width = source.videoWidth;\n    _this.height = source.videoHeight;\n    _this._autoUpdate = true;\n    _this._isAutoUpdating = false;\n    /**\n     * When set to true will automatically play videos used by this texture once\n     * they are loaded. If false, it will not modify the playing state.\n     *\n     * @member {boolean}\n     * @default true\n     */\n\n    _this.autoPlay = autoPlay;\n    _this.update = _this.update.bind(_this);\n    _this._onCanPlay = _this._onCanPlay.bind(_this);\n    source.addEventListener('play', _this._onPlayStart.bind(_this));\n    source.addEventListener('pause', _this._onPlayStop.bind(_this));\n    _this.hasLoaded = false;\n    _this.__loaded = false;\n\n    if (!_this._isSourceReady()) {\n      source.addEventListener('canplay', _this._onCanPlay);\n      source.addEventListener('canplaythrough', _this._onCanPlay);\n    } else {\n      _this._onCanPlay();\n    }\n\n    return _this;\n  }\n  /**\n   * Returns true if the underlying source is playing.\n   *\n   * @private\n   * @return {boolean} True if playing.\n   */\n\n\n  VideoBaseTexture.prototype._isSourcePlaying = function _isSourcePlaying() {\n    var source = this.source;\n    return source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2;\n  };\n  /**\n   * Returns true if the underlying source is ready for playing.\n   *\n   * @private\n   * @return {boolean} True if ready.\n   */\n\n\n  VideoBaseTexture.prototype._isSourceReady = function _isSourceReady() {\n    return this.source.readyState === 3 || this.source.readyState === 4;\n  };\n  /**\n   * Runs the update loop when the video is ready to play\n   *\n   * @private\n   */\n\n\n  VideoBaseTexture.prototype._onPlayStart = function _onPlayStart() {\n    // Just in case the video has not received its can play even yet..\n    if (!this.hasLoaded) {\n      this._onCanPlay();\n    }\n\n    if (!this._isAutoUpdating && this.autoUpdate) {\n      _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);\n\n      this._isAutoUpdating = true;\n    }\n  };\n  /**\n   * Fired when a pause event is triggered, stops the update loop\n   *\n   * @private\n   */\n\n\n  VideoBaseTexture.prototype._onPlayStop = function _onPlayStop() {\n    if (this._isAutoUpdating) {\n      _ticker.shared.remove(this.update, this);\n\n      this._isAutoUpdating = false;\n    }\n  };\n  /**\n   * Fired when the video is loaded and ready to play\n   *\n   * @private\n   */\n\n\n  VideoBaseTexture.prototype._onCanPlay = function _onCanPlay() {\n    this.hasLoaded = true;\n\n    if (this.source) {\n      this.source.removeEventListener('canplay', this._onCanPlay);\n      this.source.removeEventListener('canplaythrough', this._onCanPlay);\n      this.width = this.source.videoWidth;\n      this.height = this.source.videoHeight; // prevent multiple loaded dispatches..\n\n      if (!this.__loaded) {\n        this.__loaded = true;\n        this.emit('loaded', this);\n      }\n\n      if (this._isSourcePlaying()) {\n        this._onPlayStart();\n      } else if (this.autoPlay) {\n        this.source.play();\n      }\n    }\n  };\n  /**\n   * Destroys this texture\n   *\n   */\n\n\n  VideoBaseTexture.prototype.destroy = function destroy() {\n    if (this._isAutoUpdating) {\n      _ticker.shared.remove(this.update, this);\n    }\n\n    if (this.source && this.source._pixiId) {\n      _BaseTexture3.default.removeFromCache(this.source._pixiId);\n\n      delete this.source._pixiId;\n      this.source.pause();\n      this.source.src = '';\n      this.source.load();\n    }\n\n    _BaseTexture.prototype.destroy.call(this);\n  };\n  /**\n   * Mimic PixiJS BaseTexture.from.... method.\n   *\n   * @static\n   * @param {HTMLVideoElement} video - Video to create texture from\n   * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n   */\n\n\n  VideoBaseTexture.fromVideo = function fromVideo(video, scaleMode, autoPlay) {\n    if (!video._pixiId) {\n      video._pixiId = 'video_' + (0, _utils.uid)();\n    }\n\n    var baseTexture = _utils.BaseTextureCache[video._pixiId];\n\n    if (!baseTexture) {\n      baseTexture = new VideoBaseTexture(video, scaleMode, autoPlay);\n\n      _BaseTexture3.default.addToCache(baseTexture, video._pixiId);\n    }\n\n    return baseTexture;\n  };\n  /**\n   * Helper function that creates a new BaseTexture based on the given video element.\n   * This BaseTexture can then be used to create a texture\n   *\n   * @static\n   * @param {string|object|string[]|object[]} videoSrc - The URL(s) for the video.\n   * @param {string} [videoSrc.src] - One of the source urls for the video\n   * @param {string} [videoSrc.mime] - The mimetype of the video (e.g. 'video/mp4'). If not specified\n   *  the url's extension will be used as the second part of the mime type.\n   * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values\n   * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n   * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n   * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n   */\n\n\n  VideoBaseTexture.fromUrl = function fromUrl(videoSrc, scaleMode, crossorigin, autoPlay) {\n    var video = document.createElement('video');\n    video.setAttribute('webkit-playsinline', '');\n    video.setAttribute('playsinline', '');\n    var url = Array.isArray(videoSrc) ? videoSrc[0].src || videoSrc[0] : videoSrc.src || videoSrc;\n\n    if (crossorigin === undefined && url.indexOf('data:') !== 0) {\n      video.crossOrigin = (0, _determineCrossOrigin2.default)(url);\n    } else if (crossorigin) {\n      video.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n    } // array of objects or strings\n\n\n    if (Array.isArray(videoSrc)) {\n      for (var i = 0; i < videoSrc.length; ++i) {\n        video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));\n      }\n    } // single object or string\n    else {\n      video.appendChild(createSource(url, videoSrc.mime));\n    }\n\n    video.load();\n    return VideoBaseTexture.fromVideo(video, scaleMode, autoPlay);\n  };\n  /**\n   * Should the base texture automatically update itself, set to true by default\n   *\n   * @member {boolean}\n   */\n\n\n  _createClass(VideoBaseTexture, [{\n    key: 'autoUpdate',\n    get: function get() {\n      return this._autoUpdate;\n    },\n    set: function set(value) // eslint-disable-line require-jsdoc\n    {\n      if (value !== this._autoUpdate) {\n        this._autoUpdate = value;\n\n        if (!this._autoUpdate && this._isAutoUpdating) {\n          _ticker.shared.remove(this.update, this);\n\n          this._isAutoUpdating = false;\n        } else if (this._autoUpdate && !this._isAutoUpdating) {\n          _ticker.shared.add(this.update, this, _const.UPDATE_PRIORITY.HIGH);\n\n          this._isAutoUpdating = true;\n        }\n      }\n    }\n  }]);\n\n  return VideoBaseTexture;\n}(_BaseTexture3.default);\n\nexports.default = VideoBaseTexture;\nVideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;\n\nfunction createSource(path, type) {\n  if (!type) {\n    var purePath = path.split('?').shift().toLowerCase();\n    type = 'video/' + purePath.substr(purePath.lastIndexOf('.') + 1);\n  }\n\n  var source = document.createElement('source');\n  source.src = path;\n  source.type = type;\n  return source;\n}","map":{"version":3,"sources":["../../../src/core/textures/VideoBaseTexture.js"],"names":["VideoBaseTexture","autoPlay","source","_isSourcePlaying","_isSourceReady","_onPlayStart","_onPlayStop","_onCanPlay","destroy","fromVideo","video","scaleMode","baseTexture","fromUrl","videoSrc","crossorigin","document","url","Array","i","createSource","value","purePath","path","type"],"mappings":"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","sourcesContent":["import BaseTexture from './BaseTexture';\nimport { uid, BaseTextureCache } from '../utils';\nimport { shared } from '../ticker';\nimport { UPDATE_PRIORITY } from '../const';\nimport determineCrossOrigin from '../utils/determineCrossOrigin';\n\n/**\n * A texture of a [playing] Video.\n *\n * Video base textures mimic PixiJS BaseTexture.from.... method in their creation process.\n *\n * This can be used in several ways, such as:\n *\n * ```js\n * let texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');\n *\n * let texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);\n *\n * let texture = PIXI.VideoBaseTexture.fromUrls([\n *     { src: '/video.webm', mime: 'video/webm' },\n *     { src: '/video.mp4', mime: 'video/mp4' }\n * ]);\n * ```\n *\n * See the [\"deus\" demo](http://www.goodboydigital.com/pixijs/examples/deus/).\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n */\nexport default class VideoBaseTexture extends BaseTexture\n{\n    /**\n     * @param {HTMLVideoElement} source - Video source\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     */\n    constructor(source, scaleMode, autoPlay = true)\n    {\n        if (!source)\n        {\n            throw new Error('No video source element specified.');\n        }\n\n        // hook in here to check if video is already available.\n        // BaseTexture looks for a source.complete boolean, plus width & height.\n\n        if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA)\n            && source.width && source.height)\n        {\n            source.complete = true;\n        }\n\n        super(source, scaleMode);\n\n        this.width = source.videoWidth;\n        this.height = source.videoHeight;\n\n        this._autoUpdate = true;\n        this._isAutoUpdating = false;\n\n        /**\n         * When set to true will automatically play videos used by this texture once\n         * they are loaded. If false, it will not modify the playing state.\n         *\n         * @member {boolean}\n         * @default true\n         */\n        this.autoPlay = autoPlay;\n\n        this.update = this.update.bind(this);\n        this._onCanPlay = this._onCanPlay.bind(this);\n\n        source.addEventListener('play', this._onPlayStart.bind(this));\n        source.addEventListener('pause', this._onPlayStop.bind(this));\n        this.hasLoaded = false;\n        this.__loaded = false;\n\n        if (!this._isSourceReady())\n        {\n            source.addEventListener('canplay', this._onCanPlay);\n            source.addEventListener('canplaythrough', this._onCanPlay);\n        }\n        else\n        {\n            this._onCanPlay();\n        }\n    }\n\n    /**\n     * Returns true if the underlying source is playing.\n     *\n     * @private\n     * @return {boolean} True if playing.\n     */\n    _isSourcePlaying()\n    {\n        const source = this.source;\n\n        return (source.currentTime > 0 && source.paused === false && source.ended === false && source.readyState > 2);\n    }\n\n    /**\n     * Returns true if the underlying source is ready for playing.\n     *\n     * @private\n     * @return {boolean} True if ready.\n     */\n    _isSourceReady()\n    {\n        return this.source.readyState === 3 || this.source.readyState === 4;\n    }\n\n    /**\n     * Runs the update loop when the video is ready to play\n     *\n     * @private\n     */\n    _onPlayStart()\n    {\n        // Just in case the video has not received its can play even yet..\n        if (!this.hasLoaded)\n        {\n            this._onCanPlay();\n        }\n\n        if (!this._isAutoUpdating && this.autoUpdate)\n        {\n            shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isAutoUpdating = true;\n        }\n    }\n\n    /**\n     * Fired when a pause event is triggered, stops the update loop\n     *\n     * @private\n     */\n    _onPlayStop()\n    {\n        if (this._isAutoUpdating)\n        {\n            shared.remove(this.update, this);\n            this._isAutoUpdating = false;\n        }\n    }\n\n    /**\n     * Fired when the video is loaded and ready to play\n     *\n     * @private\n     */\n    _onCanPlay()\n    {\n        this.hasLoaded = true;\n\n        if (this.source)\n        {\n            this.source.removeEventListener('canplay', this._onCanPlay);\n            this.source.removeEventListener('canplaythrough', this._onCanPlay);\n\n            this.width = this.source.videoWidth;\n            this.height = this.source.videoHeight;\n\n            // prevent multiple loaded dispatches..\n            if (!this.__loaded)\n            {\n                this.__loaded = true;\n                this.emit('loaded', this);\n            }\n\n            if (this._isSourcePlaying())\n            {\n                this._onPlayStart();\n            }\n            else if (this.autoPlay)\n            {\n                this.source.play();\n            }\n        }\n    }\n\n    /**\n     * Destroys this texture\n     *\n     */\n    destroy()\n    {\n        if (this._isAutoUpdating)\n        {\n            shared.remove(this.update, this);\n        }\n\n        if (this.source && this.source._pixiId)\n        {\n            BaseTexture.removeFromCache(this.source._pixiId);\n            delete this.source._pixiId;\n\n            this.source.pause();\n            this.source.src = '';\n            this.source.load();\n        }\n\n        super.destroy();\n    }\n\n    /**\n     * Mimic PixiJS BaseTexture.from.... method.\n     *\n     * @static\n     * @param {HTMLVideoElement} video - Video to create texture from\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n     */\n    static fromVideo(video, scaleMode, autoPlay)\n    {\n        if (!video._pixiId)\n        {\n            video._pixiId = `video_${uid()}`;\n        }\n\n        let baseTexture = BaseTextureCache[video._pixiId];\n\n        if (!baseTexture)\n        {\n            baseTexture = new VideoBaseTexture(video, scaleMode, autoPlay);\n            BaseTexture.addToCache(baseTexture, video._pixiId);\n        }\n\n        return baseTexture;\n    }\n\n    /**\n     * Helper function that creates a new BaseTexture based on the given video element.\n     * This BaseTexture can then be used to create a texture\n     *\n     * @static\n     * @param {string|object|string[]|object[]} videoSrc - The URL(s) for the video.\n     * @param {string} [videoSrc.src] - One of the source urls for the video\n     * @param {string} [videoSrc.mime] - The mimetype of the video (e.g. 'video/mp4'). If not specified\n     *  the url's extension will be used as the second part of the mime type.\n     * @param {number} scaleMode - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {boolean} [crossorigin=(auto)] - Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n     * @param {boolean} [autoPlay=true] - Start playing video as soon as it is loaded\n     * @return {PIXI.VideoBaseTexture} Newly created VideoBaseTexture\n     */\n    static fromUrl(videoSrc, scaleMode, crossorigin, autoPlay)\n    {\n        const video = document.createElement('video');\n\n        video.setAttribute('webkit-playsinline', '');\n        video.setAttribute('playsinline', '');\n\n        const url = Array.isArray(videoSrc) ? (videoSrc[0].src || videoSrc[0]) : (videoSrc.src || videoSrc);\n\n        if (crossorigin === undefined && url.indexOf('data:') !== 0)\n        {\n            video.crossOrigin = determineCrossOrigin(url);\n        }\n        else if (crossorigin)\n        {\n            video.crossOrigin = typeof crossorigin === 'string' ? crossorigin : 'anonymous';\n        }\n\n        // array of objects or strings\n        if (Array.isArray(videoSrc))\n        {\n            for (let i = 0; i < videoSrc.length; ++i)\n            {\n                video.appendChild(createSource(videoSrc[i].src || videoSrc[i], videoSrc[i].mime));\n            }\n        }\n        // single object or string\n        else\n        {\n            video.appendChild(createSource(url, videoSrc.mime));\n        }\n\n        video.load();\n\n        return VideoBaseTexture.fromVideo(video, scaleMode, autoPlay);\n    }\n\n    /**\n     * Should the base texture automatically update itself, set to true by default\n     *\n     * @member {boolean}\n     */\n    get autoUpdate()\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value) // eslint-disable-line require-jsdoc\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isAutoUpdating)\n            {\n                shared.remove(this.update, this);\n                this._isAutoUpdating = false;\n            }\n            else if (this._autoUpdate && !this._isAutoUpdating)\n            {\n                shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n                this._isAutoUpdating = true;\n            }\n        }\n    }\n}\n\nVideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;\n\nfunction createSource(path, type)\n{\n    if (!type)\n    {\n        const purePath = path.split('?').shift().toLowerCase();\n\n        type = `video/${purePath.substr(purePath.lastIndexOf('.') + 1)}`;\n    }\n\n    const source = document.createElement('source');\n\n    source.src = path;\n    source.type = type;\n\n    return source;\n}\n"]},"metadata":{},"sourceType":"script"}