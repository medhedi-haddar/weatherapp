{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * Internal class for handling the priority sorting of ticker handlers.\n *\n * @private\n * @class\n * @memberof PIXI.ticker\n */\n\n\nvar TickerListener = function () {\n  /**\n   * Constructor\n   *\n   * @param {Function} fn - The listener function to be added for one update\n   * @param {Function} [context=null] - The listener context\n   * @param {number} [priority=0] - The priority for emitting\n   * @param {boolean} [once=false] - If the handler should fire once\n   */\n  function TickerListener(fn) {\n    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var once = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    _classCallCheck(this, TickerListener);\n    /**\n     * The handler function to execute.\n     * @member {Function}\n     */\n\n\n    this.fn = fn;\n    /**\n     * The calling to execute.\n     * @member {Function}\n     */\n\n    this.context = context;\n    /**\n     * The current priority.\n     * @member {number}\n     */\n\n    this.priority = priority;\n    /**\n     * If this should only execute once.\n     * @member {boolean}\n     */\n\n    this.once = once;\n    /**\n     * The next item in chain.\n     * @member {TickerListener}\n     */\n\n    this.next = null;\n    /**\n     * The previous item in chain.\n     * @member {TickerListener}\n     */\n\n    this.previous = null;\n    /**\n     * `true` if this listener has been destroyed already.\n     * @member {boolean}\n     * @private\n     */\n\n    this._destroyed = false;\n  }\n  /**\n   * Simple compare function to figure out if a function and context match.\n   *\n   * @param {Function} fn - The listener function to be added for one update\n   * @param {Function} context - The listener context\n   * @return {boolean} `true` if the listener match the arguments\n   */\n\n\n  TickerListener.prototype.match = function match(fn, context) {\n    context = context || null;\n    return this.fn === fn && this.context === context;\n  };\n  /**\n   * Emit by calling the current function.\n   * @param {number} deltaTime - time since the last emit.\n   * @return {TickerListener} Next ticker\n   */\n\n\n  TickerListener.prototype.emit = function emit(deltaTime) {\n    if (this.fn) {\n      if (this.context) {\n        this.fn.call(this.context, deltaTime);\n      } else {\n        this.fn(deltaTime);\n      }\n    }\n\n    var redirect = this.next;\n\n    if (this.once) {\n      this.destroy(true);\n    } // Soft-destroying should remove\n    // the next reference\n\n\n    if (this._destroyed) {\n      this.next = null;\n    }\n\n    return redirect;\n  };\n  /**\n   * Connect to the list.\n   * @param {TickerListener} previous - Input node, previous listener\n   */\n\n\n  TickerListener.prototype.connect = function connect(previous) {\n    this.previous = previous;\n\n    if (previous.next) {\n      previous.next.previous = this;\n    }\n\n    this.next = previous.next;\n    previous.next = this;\n  };\n  /**\n   * Destroy and don't use after this.\n   * @param {boolean} [hard = false] `true` to remove the `next` reference, this\n   *        is considered a hard destroy. Soft destroy maintains the next reference.\n   * @return {TickerListener} The listener to redirect while emitting or removing.\n   */\n\n\n  TickerListener.prototype.destroy = function destroy() {\n    var hard = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this._destroyed = true;\n    this.fn = null;\n    this.context = null; // Disconnect, hook up next and previous\n\n    if (this.previous) {\n      this.previous.next = this.next;\n    }\n\n    if (this.next) {\n      this.next.previous = this.previous;\n    } // Redirect to the next item\n\n\n    var redirect = this.next; // Remove references\n\n    this.next = hard ? null : redirect;\n    this.previous = null;\n    return redirect;\n  };\n\n  return TickerListener;\n}();\n\nexports.default = TickerListener;","map":{"version":3,"sources":["../../../src/core/ticker/TickerListener.js"],"names":["TickerListener","context","priority","once","match","fn","emit","deltaTime","redirect","connect","previous","destroy","hard"],"mappings":";;;;;;;;;AAAA;;;;;;;;;IAOqBA,c;AAEjB;;;;;;;;AAQA,WAAA,cAAA,CAAA,EAAA,EACA;AAAA,QADgBC,OAChB,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAD0B,IAC1B;AAAA,QADgCC,QAChC,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAD2C,CAC3C;AAAA,QAD8CC,IAC9C,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADqD,KACrD;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,cAAA,CAAA;AACI;;;;;;AAIA,SAAA,EAAA,GAAA,EAAA;AAEA;;;;;AAIA,SAAA,OAAA,GAAA,OAAA;AAEA;;;;;AAIA,SAAA,QAAA,GAAA,QAAA;AAEA;;;;;AAIA,SAAA,IAAA,GAAA,IAAA;AAEA;;;;;AAIA,SAAA,IAAA,GAAA,IAAA;AAEA;;;;;AAIA,SAAA,QAAA,GAAA,IAAA;AAEA;;;;;;AAKA,SAAA,UAAA,GAAA,KAAA;AACH;AAED;;;;;;;;;2BAOAC,K,kBAAMC,E,EAAIJ,O,EACV;AACIA,IAAAA,OAAAA,GAAUA,OAAAA,IAAVA,IAAAA;AAEA,WAAO,KAAA,EAAA,KAAA,EAAA,IAAkB,KAAA,OAAA,KAAzB,OAAA;;AAGJ;;;;;;;2BAKAK,I,iBAAKC,S,EACL;AACI,QAAI,KAAJ,EAAA,EACA;AACI,UAAI,KAAJ,OAAA,EACA;AACI,aAAA,EAAA,CAAA,IAAA,CAAa,KAAb,OAAA,EAAA,SAAA;AAFJ,OAAA,MAKA;AACI,aAAA,EAAA,CAAA,SAAA;AACH;AACJ;;AAED,QAAMC,QAAAA,GAAW,KAAjB,IAAA;;AAEA,QAAI,KAAJ,IAAA,EACA;AACI,WAAA,OAAA,CAAA,IAAA;AACH,KAlBL,CAoBI;AACA;;;AACA,QAAI,KAAJ,UAAA,EACA;AACI,WAAA,IAAA,GAAA,IAAA;AACH;;AAED,WAAA,QAAA;;AAGJ;;;;;;2BAIAC,O,oBAAQC,Q,EACR;AACI,SAAA,QAAA,GAAA,QAAA;;AACA,QAAIA,QAAAA,CAAJ,IAAA,EACA;AACIA,MAAAA,QAAAA,CAAAA,IAAAA,CAAAA,QAAAA,GAAAA,IAAAA;AACH;;AACD,SAAA,IAAA,GAAYA,QAAAA,CAAZ,IAAA;AACAA,IAAAA,QAAAA,CAAAA,IAAAA,GAAAA,IAAAA;;AAGJ;;;;;;;;2BAMAC,O,sBACA;AAAA,QADQC,IACR,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADe,KACf;AACI,SAAA,UAAA,GAAA,IAAA;AACA,SAAA,EAAA,GAAA,IAAA;AACA,SAAA,OAAA,GAAA,IAAA,CAHJ,CAKI;;AACA,QAAI,KAAJ,QAAA,EACA;AACI,WAAA,QAAA,CAAA,IAAA,GAAqB,KAArB,IAAA;AACH;;AAED,QAAI,KAAJ,IAAA,EACA;AACI,WAAA,IAAA,CAAA,QAAA,GAAqB,KAArB,QAAA;AACH,KAdL,CAgBI;;;AACA,QAAMJ,QAAAA,GAAW,KAAjB,IAAA,CAjBJ,CAmBI;;AACA,SAAA,IAAA,GAAYI,IAAAA,GAAAA,IAAAA,GAAZ,QAAA;AACA,SAAA,QAAA,GAAA,IAAA;AAEA,WAAA,QAAA;;;;;;kBAvJaZ,c","sourcesContent":["/**\n * Internal class for handling the priority sorting of ticker handlers.\n *\n * @private\n * @class\n * @memberof PIXI.ticker\n */\nexport default class TickerListener\n{\n    /**\n     * Constructor\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} [context=null] - The listener context\n     * @param {number} [priority=0] - The priority for emitting\n     * @param {boolean} [once=false] - If the handler should fire once\n     */\n    constructor(fn, context = null, priority = 0, once = false)\n    {\n        /**\n         * The handler function to execute.\n         * @member {Function}\n         */\n        this.fn = fn;\n\n        /**\n         * The calling to execute.\n         * @member {Function}\n         */\n        this.context = context;\n\n        /**\n         * The current priority.\n         * @member {number}\n         */\n        this.priority = priority;\n\n        /**\n         * If this should only execute once.\n         * @member {boolean}\n         */\n        this.once = once;\n\n        /**\n         * The next item in chain.\n         * @member {TickerListener}\n         */\n        this.next = null;\n\n        /**\n         * The previous item in chain.\n         * @member {TickerListener}\n         */\n        this.previous = null;\n\n        /**\n         * `true` if this listener has been destroyed already.\n         * @member {boolean}\n         * @private\n         */\n        this._destroyed = false;\n    }\n\n    /**\n     * Simple compare function to figure out if a function and context match.\n     *\n     * @param {Function} fn - The listener function to be added for one update\n     * @param {Function} context - The listener context\n     * @return {boolean} `true` if the listener match the arguments\n     */\n    match(fn, context)\n    {\n        context = context || null;\n\n        return this.fn === fn && this.context === context;\n    }\n\n    /**\n     * Emit by calling the current function.\n     * @param {number} deltaTime - time since the last emit.\n     * @return {TickerListener} Next ticker\n     */\n    emit(deltaTime)\n    {\n        if (this.fn)\n        {\n            if (this.context)\n            {\n                this.fn.call(this.context, deltaTime);\n            }\n            else\n            {\n                this.fn(deltaTime);\n            }\n        }\n\n        const redirect = this.next;\n\n        if (this.once)\n        {\n            this.destroy(true);\n        }\n\n        // Soft-destroying should remove\n        // the next reference\n        if (this._destroyed)\n        {\n            this.next = null;\n        }\n\n        return redirect;\n    }\n\n    /**\n     * Connect to the list.\n     * @param {TickerListener} previous - Input node, previous listener\n     */\n    connect(previous)\n    {\n        this.previous = previous;\n        if (previous.next)\n        {\n            previous.next.previous = this;\n        }\n        this.next = previous.next;\n        previous.next = this;\n    }\n\n    /**\n     * Destroy and don't use after this.\n     * @param {boolean} [hard = false] `true` to remove the `next` reference, this\n     *        is considered a hard destroy. Soft destroy maintains the next reference.\n     * @return {TickerListener} The listener to redirect while emitting or removing.\n     */\n    destroy(hard = false)\n    {\n        this._destroyed = true;\n        this.fn = null;\n        this.context = null;\n\n        // Disconnect, hook up next and previous\n        if (this.previous)\n        {\n            this.previous.next = this.next;\n        }\n\n        if (this.next)\n        {\n            this.next.previous = this.previous;\n        }\n\n        // Redirect to the next item\n        const redirect = this.next;\n\n        // Remove references\n        this.next = hard ? null : redirect;\n        this.previous = null;\n\n        return redirect;\n    }\n}\n"]},"metadata":{},"sourceType":"script"}