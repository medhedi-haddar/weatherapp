{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _SystemRenderer2 = require('../SystemRenderer');\n\nvar _SystemRenderer3 = _interopRequireDefault(_SystemRenderer2);\n\nvar _MaskManager = require('./managers/MaskManager');\n\nvar _MaskManager2 = _interopRequireDefault(_MaskManager);\n\nvar _StencilManager = require('./managers/StencilManager');\n\nvar _StencilManager2 = _interopRequireDefault(_StencilManager);\n\nvar _FilterManager = require('./managers/FilterManager');\n\nvar _FilterManager2 = _interopRequireDefault(_FilterManager);\n\nvar _RenderTarget = require('./utils/RenderTarget');\n\nvar _RenderTarget2 = _interopRequireDefault(_RenderTarget);\n\nvar _ObjectRenderer = require('./utils/ObjectRenderer');\n\nvar _ObjectRenderer2 = _interopRequireDefault(_ObjectRenderer);\n\nvar _TextureManager = require('./TextureManager');\n\nvar _TextureManager2 = _interopRequireDefault(_TextureManager);\n\nvar _BaseTexture = require('../../textures/BaseTexture');\n\nvar _BaseTexture2 = _interopRequireDefault(_BaseTexture);\n\nvar _TextureGarbageCollector = require('./TextureGarbageCollector');\n\nvar _TextureGarbageCollector2 = _interopRequireDefault(_TextureGarbageCollector);\n\nvar _WebGLState = require('./WebGLState');\n\nvar _WebGLState2 = _interopRequireDefault(_WebGLState);\n\nvar _mapWebGLDrawModesToPixi = require('./utils/mapWebGLDrawModesToPixi');\n\nvar _mapWebGLDrawModesToPixi2 = _interopRequireDefault(_mapWebGLDrawModesToPixi);\n\nvar _validateContext = require('./utils/validateContext');\n\nvar _validateContext2 = _interopRequireDefault(_validateContext);\n\nvar _utils = require('../../utils');\n\nvar _pixiGlCore = require('pixi-gl-core');\n\nvar _pixiGlCore2 = _interopRequireDefault(_pixiGlCore);\n\nvar _const = require('../../const');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar CONTEXT_UID = 0;\n/**\n * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\n\nvar WebGLRenderer = function (_SystemRenderer) {\n  _inherits(WebGLRenderer, _SystemRenderer); // eslint-disable-next-line valid-jsdoc\n\n  /**\n   *\n   * @param {object} [options] - The optional renderer parameters\n   * @param {number} [options.width=800] - the width of the screen\n   * @param {number} [options.height=600] - the height of the screen\n   * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n   * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n   * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n   * @param {boolean} [options.antialias=false] - sets antialias. If not available natively then FXAA\n   *  antialiasing is used\n   * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.\n   *  FXAA is faster, but may not always look as great\n   * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.\n   *  The resolution of the renderer retina would be 2.\n   * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear\n   *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set\n   *  preserveDrawingBuffer to `true`.\n   * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n   *  enable this if you need to call toDataUrl on the webgl context.\n   * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when\n   *  rendering, stopping pixel interpolation.\n   * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n   *  (shown if not transparent).\n   * @param {boolean} [options.legacy=false] - If true PixiJS will aim to ensure compatibility\n   *  with older / less advanced devices. If you experience unexplained flickering try setting this to true.\n   * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to \"high-performance\"\n   *  for devices with dual graphics card\n   */\n\n\n  function WebGLRenderer(options, arg2, arg3) {\n    _classCallCheck(this, WebGLRenderer);\n\n    var _this = _possibleConstructorReturn(this, _SystemRenderer.call(this, 'WebGL', options, arg2, arg3));\n\n    _this.legacy = _this.options.legacy;\n\n    if (_this.legacy) {\n      _pixiGlCore2.default.VertexArrayObject.FORCE_NATIVE = true;\n    }\n    /**\n     * The type of this renderer as a standardised const\n     *\n     * @member {number}\n     * @see PIXI.RENDERER_TYPE\n     */\n\n\n    _this.type = _const.RENDERER_TYPE.WEBGL;\n    _this.handleContextLost = _this.handleContextLost.bind(_this);\n    _this.handleContextRestored = _this.handleContextRestored.bind(_this);\n\n    _this.view.addEventListener('webglcontextlost', _this.handleContextLost, false);\n\n    _this.view.addEventListener('webglcontextrestored', _this.handleContextRestored, false);\n    /**\n     * The options passed in to create a new webgl context.\n     *\n     * @member {object}\n     * @private\n     */\n\n\n    _this._contextOptions = {\n      alpha: _this.transparent,\n      antialias: _this.options.antialias,\n      premultipliedAlpha: _this.transparent && _this.transparent !== 'notMultiplied',\n      stencil: true,\n      preserveDrawingBuffer: _this.options.preserveDrawingBuffer,\n      powerPreference: _this.options.powerPreference\n    };\n    _this._backgroundColorRgba[3] = _this.transparent ? 0 : 1;\n    /**\n     * Manages the masks using the stencil buffer.\n     *\n     * @member {PIXI.MaskManager}\n     */\n\n    _this.maskManager = new _MaskManager2.default(_this);\n    /**\n     * Manages the stencil buffer.\n     *\n     * @member {PIXI.StencilManager}\n     */\n\n    _this.stencilManager = new _StencilManager2.default(_this);\n    /**\n     * An empty renderer.\n     *\n     * @member {PIXI.ObjectRenderer}\n     */\n\n    _this.emptyRenderer = new _ObjectRenderer2.default(_this);\n    /**\n     * The currently active ObjectRenderer.\n     *\n     * @member {PIXI.ObjectRenderer}\n     */\n\n    _this.currentRenderer = _this.emptyRenderer;\n    /**\n     * Manages textures\n     * @member {PIXI.TextureManager}\n     */\n\n    _this.textureManager = null;\n    /**\n     * Manages the filters.\n     *\n     * @member {PIXI.FilterManager}\n     */\n\n    _this.filterManager = null;\n\n    _this.initPlugins();\n    /**\n     * The current WebGL rendering context, it is created here\n     *\n     * @member {WebGLRenderingContext}\n     */\n    // initialize the context so it is ready for the managers.\n\n\n    if (_this.options.context) {\n      // checks to see if a context is valid..\n      (0, _validateContext2.default)(_this.options.context);\n    }\n\n    _this.gl = _this.options.context || _pixiGlCore2.default.createContext(_this.view, _this._contextOptions);\n    _this.CONTEXT_UID = CONTEXT_UID++;\n    /**\n     * The currently active ObjectRenderer.\n     *\n     * @member {PIXI.WebGLState}\n     */\n\n    _this.state = new _WebGLState2.default(_this.gl);\n    _this.renderingToScreen = true;\n    /**\n     * Holds the current state of textures bound to the GPU.\n     * @type {Array}\n     */\n\n    _this.boundTextures = null;\n    /**\n     * Holds the current shader\n     *\n     * @member {PIXI.Shader}\n     */\n\n    _this._activeShader = null;\n    _this._activeVao = null;\n    /**\n     * Holds the current render target\n     *\n     * @member {PIXI.RenderTarget}\n     */\n\n    _this._activeRenderTarget = null;\n\n    _this._initContext(); // map some webGL blend and drawmodes..\n\n\n    _this.drawModes = (0, _mapWebGLDrawModesToPixi2.default)(_this.gl);\n    _this._nextTextureLocation = 0;\n\n    _this.setBlendMode(0);\n    /**\n     * Fired after rendering finishes.\n     *\n     * @event PIXI.WebGLRenderer#postrender\n     */\n\n    /**\n     * Fired before rendering starts.\n     *\n     * @event PIXI.WebGLRenderer#prerender\n     */\n\n    /**\n     * Fired when the WebGL context is set.\n     *\n     * @event PIXI.WebGLRenderer#context\n     * @param {WebGLRenderingContext} gl - WebGL context.\n     */\n\n\n    return _this;\n  }\n  /**\n   * Creates the WebGL context\n   *\n   * @private\n   */\n\n\n  WebGLRenderer.prototype._initContext = function _initContext() {\n    var gl = this.gl; // restore a context if it was previously lost\n\n    if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context')) {\n      gl.getExtension('WEBGL_lose_context').restoreContext();\n    }\n\n    var maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this._activeShader = null;\n    this._activeVao = null;\n    this.boundTextures = new Array(maxTextures);\n    this.emptyTextures = new Array(maxTextures);\n    /**\n     * Did someone temper with textures state? We'll overwrite them when we need to unbind something.\n     * @member {boolean}\n     * @private\n     */\n\n    this._unknownBoundTextures = false; // create a texture manager...\n\n    this.textureManager = new _TextureManager2.default(this);\n    this.filterManager = new _FilterManager2.default(this);\n    this.textureGC = new _TextureGarbageCollector2.default(this);\n    this.state.resetToDefault();\n    this.rootRenderTarget = new _RenderTarget2.default(gl, this.width, this.height, null, this.resolution, true);\n    this.rootRenderTarget.clearColor = this._backgroundColorRgba;\n    this.bindRenderTarget(this.rootRenderTarget); // now lets fill up the textures with empty ones!\n\n    var emptyGLTexture = new _pixiGlCore2.default.GLTexture.fromData(gl, null, 1, 1);\n    var tempObj = {\n      _glTextures: {}\n    };\n    tempObj._glTextures[this.CONTEXT_UID] = {};\n\n    for (var i = 0; i < maxTextures; i++) {\n      var empty = new _BaseTexture2.default();\n      empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;\n      this.boundTextures[i] = tempObj;\n      this.emptyTextures[i] = empty;\n      this.bindTexture(null, i);\n    }\n\n    this.emit('context', gl); // setup the width/height properties and gl viewport\n\n    this.resize(this.screen.width, this.screen.height);\n  };\n  /**\n   * Renders the object to its webGL view\n   *\n   * @param {PIXI.DisplayObject} displayObject - the object to be rendered\n   * @param {PIXI.RenderTexture} renderTexture - The render texture to render to.\n   * @param {boolean} [clear] - Should the canvas be cleared before the new render\n   * @param {PIXI.Matrix} [transform] - A transform to apply to the render texture before rendering.\n   * @param {boolean} [skipUpdateTransform] - Should we skip the update transform pass?\n   */\n\n\n  WebGLRenderer.prototype.render = function render(displayObject, renderTexture, clear, transform, skipUpdateTransform) {\n    // can be handy to know!\n    this.renderingToScreen = !renderTexture;\n    this.emit('prerender'); // no point rendering if our context has been blown up!\n\n    if (!this.gl || this.gl.isContextLost()) {\n      return;\n    }\n\n    this._nextTextureLocation = 0;\n\n    if (!renderTexture) {\n      this._lastObjectRendered = displayObject;\n    }\n\n    if (!skipUpdateTransform) {\n      // update the scene graph\n      var cacheParent = displayObject.parent;\n      displayObject.parent = this._tempDisplayObjectParent;\n      displayObject.updateTransform();\n      displayObject.parent = cacheParent; // displayObject.hitArea = //TODO add a temp hit area\n    }\n\n    this.bindRenderTexture(renderTexture, transform);\n    this.currentRenderer.start();\n\n    if (clear !== undefined ? clear : this.clearBeforeRender) {\n      this._activeRenderTarget.clear();\n    }\n\n    displayObject.renderWebGL(this); // apply transform..\n\n    this.currentRenderer.flush(); // this.setObjectRenderer(this.emptyRenderer);\n\n    this.textureGC.update();\n    this.emit('postrender');\n  };\n  /**\n   * Changes the current renderer to the one given in parameter\n   *\n   * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.\n   */\n\n\n  WebGLRenderer.prototype.setObjectRenderer = function setObjectRenderer(objectRenderer) {\n    if (this.currentRenderer === objectRenderer) {\n      return;\n    }\n\n    this.currentRenderer.stop();\n    this.currentRenderer = objectRenderer;\n    this.currentRenderer.start();\n  };\n  /**\n   * This should be called if you wish to do some custom rendering\n   * It will basically render anything that may be batched up such as sprites\n   *\n   */\n\n\n  WebGLRenderer.prototype.flush = function flush() {\n    this.setObjectRenderer(this.emptyRenderer);\n  };\n  /**\n   * Resizes the webGL view to the specified width and height.\n   *\n   * @param {number} screenWidth - the new width of the screen\n   * @param {number} screenHeight - the new height of the screen\n   */\n\n\n  WebGLRenderer.prototype.resize = function resize(screenWidth, screenHeight) {\n    //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;\n    _SystemRenderer3.default.prototype.resize.call(this, screenWidth, screenHeight);\n\n    this.rootRenderTarget.resize(screenWidth, screenHeight);\n\n    if (this._activeRenderTarget === this.rootRenderTarget) {\n      this.rootRenderTarget.activate();\n\n      if (this._activeShader) {\n        this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);\n      }\n    }\n  };\n  /**\n   * Resizes the webGL view to the specified width and height.\n   *\n   * @param {number} blendMode - the desired blend mode\n   */\n\n\n  WebGLRenderer.prototype.setBlendMode = function setBlendMode(blendMode) {\n    this.state.setBlendMode(blendMode);\n  };\n  /**\n   * Erases the active render target and fills the drawing area with a colour\n   *\n   * @param {number} [clearColor] - The colour\n   */\n\n\n  WebGLRenderer.prototype.clear = function clear(clearColor) {\n    this._activeRenderTarget.clear(clearColor);\n  };\n  /**\n   * Sets the transform of the active render target to the given matrix\n   *\n   * @param {PIXI.Matrix} matrix - The transformation matrix\n   */\n\n\n  WebGLRenderer.prototype.setTransform = function setTransform(matrix) {\n    this._activeRenderTarget.transform = matrix;\n  };\n  /**\n   * Erases the render texture and fills the drawing area with a colour\n   *\n   * @param {PIXI.RenderTexture} renderTexture - The render texture to clear\n   * @param {number} [clearColor] - The colour\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n\n  WebGLRenderer.prototype.clearRenderTexture = function clearRenderTexture(renderTexture, clearColor) {\n    var baseTexture = renderTexture.baseTexture;\n    var renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n\n    if (renderTarget) {\n      renderTarget.clear(clearColor);\n    }\n\n    return this;\n  };\n  /**\n   * Binds a render texture for rendering\n   *\n   * @param {PIXI.RenderTexture} renderTexture - The render texture to render\n   * @param {PIXI.Matrix} transform - The transform to be applied to the render texture\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n\n  WebGLRenderer.prototype.bindRenderTexture = function bindRenderTexture(renderTexture, transform) {\n    var renderTarget = void 0;\n\n    if (renderTexture) {\n      var baseTexture = renderTexture.baseTexture;\n\n      if (!baseTexture._glRenderTargets[this.CONTEXT_UID]) {\n        // bind the current texture\n        this.textureManager.updateTexture(baseTexture, 0);\n      }\n\n      this.unbindTexture(baseTexture);\n      renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n      renderTarget.setFrame(renderTexture.frame);\n    } else {\n      renderTarget = this.rootRenderTarget;\n    }\n\n    renderTarget.transform = transform;\n    this.bindRenderTarget(renderTarget);\n    return this;\n  };\n  /**\n   * Changes the current render target to the one given in parameter\n   *\n   * @param {PIXI.RenderTarget} renderTarget - the new render target\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n\n  WebGLRenderer.prototype.bindRenderTarget = function bindRenderTarget(renderTarget) {\n    if (renderTarget !== this._activeRenderTarget) {\n      this._activeRenderTarget = renderTarget;\n      renderTarget.activate();\n\n      if (this._activeShader) {\n        this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);\n      }\n\n      this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);\n    }\n\n    return this;\n  };\n  /**\n   * Changes the current shader to the one given in parameter\n   *\n   * @param {PIXI.Shader} shader - the new shader\n   * @param {boolean} [autoProject=true] - Whether automatically set the projection matrix\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n\n  WebGLRenderer.prototype.bindShader = function bindShader(shader, autoProject) {\n    // TODO cache\n    if (this._activeShader !== shader) {\n      this._activeShader = shader;\n      shader.bind(); // `autoProject` normally would be a default parameter set to true\n      // but because of how Babel transpiles default parameters\n      // it hinders the performance of this method.\n\n      if (autoProject !== false) {\n        // automatically set the projection matrix\n        shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Binds the texture. This will return the location of the bound texture.\n   * It may not be the same as the one you pass in. This is due to optimisation that prevents\n   * needless binding of textures. For example if the texture is already bound it will return the\n   * current location of the texture instead of the one provided. To bypass this use force location\n   *\n   * @param {PIXI.Texture} texture - the new texture\n   * @param {number} location - the suggested texture location\n   * @param {boolean} forceLocation - force the location\n   * @return {number} bound texture location\n   */\n\n\n  WebGLRenderer.prototype.bindTexture = function bindTexture(texture, location, forceLocation) {\n    texture = texture || this.emptyTextures[location];\n    texture = texture.baseTexture || texture;\n    texture.touched = this.textureGC.count;\n\n    if (!forceLocation) {\n      // TODO - maybe look into adding boundIds.. save us the loop?\n      for (var i = 0; i < this.boundTextures.length; i++) {\n        if (this.boundTextures[i] === texture) {\n          return i;\n        }\n      }\n\n      if (location === undefined) {\n        this._nextTextureLocation++;\n        this._nextTextureLocation %= this.boundTextures.length;\n        location = this.boundTextures.length - this._nextTextureLocation - 1;\n      }\n    } else {\n      location = location || 0;\n    }\n\n    var gl = this.gl;\n    var glTexture = texture._glTextures[this.CONTEXT_UID];\n\n    if (!glTexture) {\n      // this will also bind the texture..\n      this.textureManager.updateTexture(texture, location);\n    } else {\n      // bind the current texture\n      this.boundTextures[location] = texture;\n      gl.activeTexture(gl.TEXTURE0 + location);\n      gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n    }\n\n    return location;\n  };\n  /**\n  * unbinds the texture ...\n  *\n  * @param {PIXI.Texture} texture - the texture to unbind\n  * @return {PIXI.WebGLRenderer} Returns itself.\n  */\n\n\n  WebGLRenderer.prototype.unbindTexture = function unbindTexture(texture) {\n    var gl = this.gl;\n    texture = texture.baseTexture || texture;\n\n    if (this._unknownBoundTextures) {\n      this._unknownBoundTextures = false; // someone changed webGL state,\n      // we have to be sure that our texture does not appear in multitexture renderer samplers\n\n      for (var i = 0; i < this.boundTextures.length; i++) {\n        if (this.boundTextures[i] === this.emptyTextures[i]) {\n          gl.activeTexture(gl.TEXTURE0 + i);\n          gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);\n        }\n      }\n    }\n\n    for (var _i = 0; _i < this.boundTextures.length; _i++) {\n      if (this.boundTextures[_i] === texture) {\n        this.boundTextures[_i] = this.emptyTextures[_i];\n        gl.activeTexture(gl.TEXTURE0 + _i);\n        gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[_i]._glTextures[this.CONTEXT_UID].texture);\n      }\n    }\n\n    return this;\n  };\n  /**\n   * Creates a new VAO from this renderer's context and state.\n   *\n   * @return {VertexArrayObject} The new VAO.\n   */\n\n\n  WebGLRenderer.prototype.createVao = function createVao() {\n    return new _pixiGlCore2.default.VertexArrayObject(this.gl, this.state.attribState);\n  };\n  /**\n   * Changes the current Vao to the one given in parameter\n   *\n   * @param {PIXI.VertexArrayObject} vao - the new Vao\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n\n  WebGLRenderer.prototype.bindVao = function bindVao(vao) {\n    if (this._activeVao === vao) {\n      return this;\n    }\n\n    if (vao) {\n      vao.bind();\n    } else if (this._activeVao) {\n      // TODO this should always be true i think?\n      this._activeVao.unbind();\n    }\n\n    this._activeVao = vao;\n    return this;\n  };\n  /**\n   * Resets the WebGL state so you can render things however you fancy!\n   *\n   * @return {PIXI.WebGLRenderer} Returns itself.\n   */\n\n\n  WebGLRenderer.prototype.reset = function reset() {\n    this.setObjectRenderer(this.emptyRenderer);\n    this.bindVao(null);\n    this._activeShader = null;\n    this._activeRenderTarget = this.rootRenderTarget;\n    this._unknownBoundTextures = true;\n\n    for (var i = 0; i < this.boundTextures.length; i++) {\n      this.boundTextures[i] = this.emptyTextures[i];\n    } // bind the main frame buffer (the screen);\n\n\n    this.rootRenderTarget.activate();\n    this.state.resetToDefault();\n    return this;\n  };\n  /**\n   * Handles a lost webgl context\n   *\n   * @private\n   * @param {WebGLContextEvent} event - The context lost event.\n   */\n\n\n  WebGLRenderer.prototype.handleContextLost = function handleContextLost(event) {\n    event.preventDefault();\n  };\n  /**\n   * Handles a restored webgl context\n   *\n   * @private\n   */\n\n\n  WebGLRenderer.prototype.handleContextRestored = function handleContextRestored() {\n    this.textureManager.removeAll();\n    this.filterManager.destroy(true);\n\n    this._initContext();\n  };\n  /**\n   * Removes everything from the renderer (event listeners, spritebatch, etc...)\n   *\n   * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n   *  See: https://github.com/pixijs/pixi.js/issues/2233\n   */\n\n\n  WebGLRenderer.prototype.destroy = function destroy(removeView) {\n    this.destroyPlugins(); // remove listeners\n\n    this.view.removeEventListener('webglcontextlost', this.handleContextLost);\n    this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);\n    this.textureManager.destroy(); // call base destroy\n\n    _SystemRenderer.prototype.destroy.call(this, removeView);\n\n    this.uid = 0; // destroy the managers\n\n    this.maskManager.destroy();\n    this.stencilManager.destroy();\n    this.filterManager.destroy();\n    this.maskManager = null;\n    this.filterManager = null;\n    this.textureManager = null;\n    this.currentRenderer = null;\n    this.handleContextLost = null;\n    this.handleContextRestored = null;\n    this._contextOptions = null;\n    this.gl.useProgram(null);\n\n    if (this.gl.getExtension('WEBGL_lose_context')) {\n      this.gl.getExtension('WEBGL_lose_context').loseContext();\n    }\n\n    this.gl = null; // this = null;\n  };\n\n  return WebGLRenderer;\n}(_SystemRenderer3.default);\n/**\n * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n * by creating a custom build. Consult the README for more information about creating custom\n * builds and excluding plugins.\n * @name PIXI.WebGLRenderer#plugins\n * @type {object}\n * @readonly\n * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.\n * @property {PIXI.extract.WebGLExtract} extract Extract image data from renderer.\n * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.\n * @property {PIXI.prepare.WebGLPrepare} prepare Pre-render display objects.\n */\n\n/**\n * Adds a plugin to the renderer.\n *\n * @method PIXI.WebGLRenderer#registerPlugin\n * @param {string} pluginName - The name of the plugin.\n * @param {Function} ctor - The constructor function or class for the plugin.\n */\n\n\nexports.default = WebGLRenderer;\n\n_utils.pluginTarget.mixin(WebGLRenderer);","map":{"version":3,"sources":["../../../../src/core/renderers/webgl/WebGLRenderer.js"],"names":["CONTEXT_UID","WebGLRenderer","alpha","antialias","premultipliedAlpha","stencil","preserveDrawingBuffer","powerPreference","_initContext","gl","maxTextures","emptyGLTexture","tempObj","_glTextures","i","empty","render","displayObject","renderTexture","clear","transform","skipUpdateTransform","cacheParent","setObjectRenderer","objectRenderer","flush","resize","screenWidth","screenHeight","setBlendMode","blendMode","clearColor","setTransform","matrix","clearRenderTexture","baseTexture","renderTarget","bindRenderTexture","bindRenderTarget","bindShader","shader","autoProject","bindTexture","texture","location","forceLocation","glTexture","unbindTexture","createVao","bindVao","vao","reset","handleContextLost","event","handleContextRestored","destroy","removeView"],"mappings":"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","sourcesContent":["import SystemRenderer from '../SystemRenderer';\nimport MaskManager from './managers/MaskManager';\nimport StencilManager from './managers/StencilManager';\nimport FilterManager from './managers/FilterManager';\nimport RenderTarget from './utils/RenderTarget';\nimport ObjectRenderer from './utils/ObjectRenderer';\nimport TextureManager from './TextureManager';\nimport BaseTexture from '../../textures/BaseTexture';\nimport TextureGarbageCollector from './TextureGarbageCollector';\nimport WebGLState from './WebGLState';\nimport mapWebGLDrawModesToPixi from './utils/mapWebGLDrawModesToPixi';\nimport validateContext from './utils/validateContext';\nimport { pluginTarget } from '../../utils';\nimport glCore from 'pixi-gl-core';\nimport { RENDERER_TYPE } from '../../const';\n\nlet CONTEXT_UID = 0;\n\n/**\n * The WebGLRenderer draws the scene and all its content onto a webGL enabled canvas. This renderer\n * should be used for browsers that support webGL. This Render works by automatically managing webGLBatchs.\n * So no need for Sprite Batches or Sprite Clouds.\n * Don't forget to add the view to your DOM or you will not see anything :)\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.SystemRenderer\n */\nexport default class WebGLRenderer extends SystemRenderer\n{\n    // eslint-disable-next-line valid-jsdoc\n    /**\n     *\n     * @param {object} [options] - The optional renderer parameters\n     * @param {number} [options.width=800] - the width of the screen\n     * @param {number} [options.height=600] - the height of the screen\n     * @param {HTMLCanvasElement} [options.view] - the canvas to use as a view, optional\n     * @param {boolean} [options.transparent=false] - If the render view is transparent, default false\n     * @param {boolean} [options.autoResize=false] - If the render view is automatically resized, default false\n     * @param {boolean} [options.antialias=false] - sets antialias. If not available natively then FXAA\n     *  antialiasing is used\n     * @param {boolean} [options.forceFXAA=false] - forces FXAA antialiasing to be used over native.\n     *  FXAA is faster, but may not always look as great\n     * @param {number} [options.resolution=1] - The resolution / device pixel ratio of the renderer.\n     *  The resolution of the renderer retina would be 2.\n     * @param {boolean} [options.clearBeforeRender=true] - This sets if the renderer will clear\n     *  the canvas or not before the new render pass. If you wish to set this to false, you *must* set\n     *  preserveDrawingBuffer to `true`.\n     * @param {boolean} [options.preserveDrawingBuffer=false] - enables drawing buffer preservation,\n     *  enable this if you need to call toDataUrl on the webgl context.\n     * @param {boolean} [options.roundPixels=false] - If true PixiJS will Math.floor() x/y values when\n     *  rendering, stopping pixel interpolation.\n     * @param {number} [options.backgroundColor=0x000000] - The background color of the rendered area\n     *  (shown if not transparent).\n     * @param {boolean} [options.legacy=false] - If true PixiJS will aim to ensure compatibility\n     *  with older / less advanced devices. If you experience unexplained flickering try setting this to true.\n     * @param {string} [options.powerPreference] - Parameter passed to webgl context, set to \"high-performance\"\n     *  for devices with dual graphics card\n     */\n    constructor(options, arg2, arg3)\n    {\n        super('WebGL', options, arg2, arg3);\n\n        this.legacy = this.options.legacy;\n\n        if (this.legacy)\n        {\n            glCore.VertexArrayObject.FORCE_NATIVE = true;\n        }\n\n        /**\n         * The type of this renderer as a standardised const\n         *\n         * @member {number}\n         * @see PIXI.RENDERER_TYPE\n         */\n        this.type = RENDERER_TYPE.WEBGL;\n\n        this.handleContextLost = this.handleContextLost.bind(this);\n        this.handleContextRestored = this.handleContextRestored.bind(this);\n\n        this.view.addEventListener('webglcontextlost', this.handleContextLost, false);\n        this.view.addEventListener('webglcontextrestored', this.handleContextRestored, false);\n\n        /**\n         * The options passed in to create a new webgl context.\n         *\n         * @member {object}\n         * @private\n         */\n        this._contextOptions = {\n            alpha: this.transparent,\n            antialias: this.options.antialias,\n            premultipliedAlpha: this.transparent && this.transparent !== 'notMultiplied',\n            stencil: true,\n            preserveDrawingBuffer: this.options.preserveDrawingBuffer,\n            powerPreference: this.options.powerPreference,\n        };\n\n        this._backgroundColorRgba[3] = this.transparent ? 0 : 1;\n\n        /**\n         * Manages the masks using the stencil buffer.\n         *\n         * @member {PIXI.MaskManager}\n         */\n        this.maskManager = new MaskManager(this);\n\n        /**\n         * Manages the stencil buffer.\n         *\n         * @member {PIXI.StencilManager}\n         */\n        this.stencilManager = new StencilManager(this);\n\n        /**\n         * An empty renderer.\n         *\n         * @member {PIXI.ObjectRenderer}\n         */\n        this.emptyRenderer = new ObjectRenderer(this);\n\n        /**\n         * The currently active ObjectRenderer.\n         *\n         * @member {PIXI.ObjectRenderer}\n         */\n        this.currentRenderer = this.emptyRenderer;\n\n        /**\n         * Manages textures\n         * @member {PIXI.TextureManager}\n         */\n        this.textureManager = null;\n\n        /**\n         * Manages the filters.\n         *\n         * @member {PIXI.FilterManager}\n         */\n        this.filterManager = null;\n\n        this.initPlugins();\n\n        /**\n         * The current WebGL rendering context, it is created here\n         *\n         * @member {WebGLRenderingContext}\n         */\n        // initialize the context so it is ready for the managers.\n        if (this.options.context)\n        {\n            // checks to see if a context is valid..\n            validateContext(this.options.context);\n        }\n\n        this.gl = this.options.context || glCore.createContext(this.view, this._contextOptions);\n\n        this.CONTEXT_UID = CONTEXT_UID++;\n\n        /**\n         * The currently active ObjectRenderer.\n         *\n         * @member {PIXI.WebGLState}\n         */\n        this.state = new WebGLState(this.gl);\n\n        this.renderingToScreen = true;\n\n        /**\n         * Holds the current state of textures bound to the GPU.\n         * @type {Array}\n         */\n        this.boundTextures = null;\n\n        /**\n         * Holds the current shader\n         *\n         * @member {PIXI.Shader}\n         */\n        this._activeShader = null;\n\n        this._activeVao = null;\n\n        /**\n         * Holds the current render target\n         *\n         * @member {PIXI.RenderTarget}\n         */\n        this._activeRenderTarget = null;\n\n        this._initContext();\n\n        // map some webGL blend and drawmodes..\n        this.drawModes = mapWebGLDrawModesToPixi(this.gl);\n\n        this._nextTextureLocation = 0;\n\n        this.setBlendMode(0);\n\n        /**\n         * Fired after rendering finishes.\n         *\n         * @event PIXI.WebGLRenderer#postrender\n         */\n\n        /**\n         * Fired before rendering starts.\n         *\n         * @event PIXI.WebGLRenderer#prerender\n         */\n\n        /**\n         * Fired when the WebGL context is set.\n         *\n         * @event PIXI.WebGLRenderer#context\n         * @param {WebGLRenderingContext} gl - WebGL context.\n         */\n    }\n\n    /**\n     * Creates the WebGL context\n     *\n     * @private\n     */\n    _initContext()\n    {\n        const gl = this.gl;\n\n        // restore a context if it was previously lost\n        if (gl.isContextLost() && gl.getExtension('WEBGL_lose_context'))\n        {\n            gl.getExtension('WEBGL_lose_context').restoreContext();\n        }\n\n        const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\n        this._activeShader = null;\n        this._activeVao = null;\n\n        this.boundTextures = new Array(maxTextures);\n        this.emptyTextures = new Array(maxTextures);\n\n        /**\n         * Did someone temper with textures state? We'll overwrite them when we need to unbind something.\n         * @member {boolean}\n         * @private\n         */\n        this._unknownBoundTextures = false;\n\n        // create a texture manager...\n        this.textureManager = new TextureManager(this);\n        this.filterManager = new FilterManager(this);\n        this.textureGC = new TextureGarbageCollector(this);\n\n        this.state.resetToDefault();\n\n        this.rootRenderTarget = new RenderTarget(gl, this.width, this.height, null, this.resolution, true);\n        this.rootRenderTarget.clearColor = this._backgroundColorRgba;\n\n        this.bindRenderTarget(this.rootRenderTarget);\n\n        // now lets fill up the textures with empty ones!\n        const emptyGLTexture = new glCore.GLTexture.fromData(gl, null, 1, 1);\n\n        const tempObj = { _glTextures: {} };\n\n        tempObj._glTextures[this.CONTEXT_UID] = {};\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            const empty = new BaseTexture();\n\n            empty._glTextures[this.CONTEXT_UID] = emptyGLTexture;\n\n            this.boundTextures[i] = tempObj;\n            this.emptyTextures[i] = empty;\n            this.bindTexture(null, i);\n        }\n\n        this.emit('context', gl);\n\n        // setup the width/height properties and gl viewport\n        this.resize(this.screen.width, this.screen.height);\n    }\n\n    /**\n     * Renders the object to its webGL view\n     *\n     * @param {PIXI.DisplayObject} displayObject - the object to be rendered\n     * @param {PIXI.RenderTexture} renderTexture - The render texture to render to.\n     * @param {boolean} [clear] - Should the canvas be cleared before the new render\n     * @param {PIXI.Matrix} [transform] - A transform to apply to the render texture before rendering.\n     * @param {boolean} [skipUpdateTransform] - Should we skip the update transform pass?\n     */\n    render(displayObject, renderTexture, clear, transform, skipUpdateTransform)\n    {\n        // can be handy to know!\n        this.renderingToScreen = !renderTexture;\n\n        this.emit('prerender');\n\n        // no point rendering if our context has been blown up!\n        if (!this.gl || this.gl.isContextLost())\n        {\n            return;\n        }\n\n        this._nextTextureLocation = 0;\n\n        if (!renderTexture)\n        {\n            this._lastObjectRendered = displayObject;\n        }\n\n        if (!skipUpdateTransform)\n        {\n            // update the scene graph\n            const cacheParent = displayObject.parent;\n\n            displayObject.parent = this._tempDisplayObjectParent;\n            displayObject.updateTransform();\n            displayObject.parent = cacheParent;\n           // displayObject.hitArea = //TODO add a temp hit area\n        }\n\n        this.bindRenderTexture(renderTexture, transform);\n\n        this.currentRenderer.start();\n\n        if (clear !== undefined ? clear : this.clearBeforeRender)\n        {\n            this._activeRenderTarget.clear();\n        }\n\n        displayObject.renderWebGL(this);\n\n        // apply transform..\n        this.currentRenderer.flush();\n\n        // this.setObjectRenderer(this.emptyRenderer);\n\n        this.textureGC.update();\n\n        this.emit('postrender');\n    }\n\n    /**\n     * Changes the current renderer to the one given in parameter\n     *\n     * @param {PIXI.ObjectRenderer} objectRenderer - The object renderer to use.\n     */\n    setObjectRenderer(objectRenderer)\n    {\n        if (this.currentRenderer === objectRenderer)\n        {\n            return;\n        }\n\n        this.currentRenderer.stop();\n        this.currentRenderer = objectRenderer;\n        this.currentRenderer.start();\n    }\n\n    /**\n     * This should be called if you wish to do some custom rendering\n     * It will basically render anything that may be batched up such as sprites\n     *\n     */\n    flush()\n    {\n        this.setObjectRenderer(this.emptyRenderer);\n    }\n\n    /**\n     * Resizes the webGL view to the specified width and height.\n     *\n     * @param {number} screenWidth - the new width of the screen\n     * @param {number} screenHeight - the new height of the screen\n     */\n    resize(screenWidth, screenHeight)\n    {\n      //  if(width * this.resolution === this.width && height * this.resolution === this.height)return;\n\n        SystemRenderer.prototype.resize.call(this, screenWidth, screenHeight);\n\n        this.rootRenderTarget.resize(screenWidth, screenHeight);\n\n        if (this._activeRenderTarget === this.rootRenderTarget)\n        {\n            this.rootRenderTarget.activate();\n\n            if (this._activeShader)\n            {\n                this._activeShader.uniforms.projectionMatrix = this.rootRenderTarget.projectionMatrix.toArray(true);\n            }\n        }\n    }\n\n    /**\n     * Resizes the webGL view to the specified width and height.\n     *\n     * @param {number} blendMode - the desired blend mode\n     */\n    setBlendMode(blendMode)\n    {\n        this.state.setBlendMode(blendMode);\n    }\n\n    /**\n     * Erases the active render target and fills the drawing area with a colour\n     *\n     * @param {number} [clearColor] - The colour\n     */\n    clear(clearColor)\n    {\n        this._activeRenderTarget.clear(clearColor);\n    }\n\n    /**\n     * Sets the transform of the active render target to the given matrix\n     *\n     * @param {PIXI.Matrix} matrix - The transformation matrix\n     */\n    setTransform(matrix)\n    {\n        this._activeRenderTarget.transform = matrix;\n    }\n\n    /**\n     * Erases the render texture and fills the drawing area with a colour\n     *\n     * @param {PIXI.RenderTexture} renderTexture - The render texture to clear\n     * @param {number} [clearColor] - The colour\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    clearRenderTexture(renderTexture, clearColor)\n    {\n        const baseTexture = renderTexture.baseTexture;\n        const renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n\n        if (renderTarget)\n        {\n            renderTarget.clear(clearColor);\n        }\n\n        return this;\n    }\n\n    /**\n     * Binds a render texture for rendering\n     *\n     * @param {PIXI.RenderTexture} renderTexture - The render texture to render\n     * @param {PIXI.Matrix} transform - The transform to be applied to the render texture\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindRenderTexture(renderTexture, transform)\n    {\n        let renderTarget;\n\n        if (renderTexture)\n        {\n            const baseTexture = renderTexture.baseTexture;\n\n            if (!baseTexture._glRenderTargets[this.CONTEXT_UID])\n            {\n                // bind the current texture\n                this.textureManager.updateTexture(baseTexture, 0);\n            }\n\n            this.unbindTexture(baseTexture);\n\n            renderTarget = baseTexture._glRenderTargets[this.CONTEXT_UID];\n            renderTarget.setFrame(renderTexture.frame);\n        }\n        else\n        {\n            renderTarget = this.rootRenderTarget;\n        }\n\n        renderTarget.transform = transform;\n        this.bindRenderTarget(renderTarget);\n\n        return this;\n    }\n\n    /**\n     * Changes the current render target to the one given in parameter\n     *\n     * @param {PIXI.RenderTarget} renderTarget - the new render target\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindRenderTarget(renderTarget)\n    {\n        if (renderTarget !== this._activeRenderTarget)\n        {\n            this._activeRenderTarget = renderTarget;\n            renderTarget.activate();\n\n            if (this._activeShader)\n            {\n                this._activeShader.uniforms.projectionMatrix = renderTarget.projectionMatrix.toArray(true);\n            }\n\n            this.stencilManager.setMaskStack(renderTarget.stencilMaskStack);\n        }\n\n        return this;\n    }\n\n    /**\n     * Changes the current shader to the one given in parameter\n     *\n     * @param {PIXI.Shader} shader - the new shader\n     * @param {boolean} [autoProject=true] - Whether automatically set the projection matrix\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindShader(shader, autoProject)\n    {\n        // TODO cache\n        if (this._activeShader !== shader)\n        {\n            this._activeShader = shader;\n            shader.bind();\n\n            // `autoProject` normally would be a default parameter set to true\n            // but because of how Babel transpiles default parameters\n            // it hinders the performance of this method.\n            if (autoProject !== false)\n            {\n                // automatically set the projection matrix\n                shader.uniforms.projectionMatrix = this._activeRenderTarget.projectionMatrix.toArray(true);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Binds the texture. This will return the location of the bound texture.\n     * It may not be the same as the one you pass in. This is due to optimisation that prevents\n     * needless binding of textures. For example if the texture is already bound it will return the\n     * current location of the texture instead of the one provided. To bypass this use force location\n     *\n     * @param {PIXI.Texture} texture - the new texture\n     * @param {number} location - the suggested texture location\n     * @param {boolean} forceLocation - force the location\n     * @return {number} bound texture location\n     */\n    bindTexture(texture, location, forceLocation)\n    {\n        texture = texture || this.emptyTextures[location];\n        texture = texture.baseTexture || texture;\n        texture.touched = this.textureGC.count;\n\n        if (!forceLocation)\n        {\n            // TODO - maybe look into adding boundIds.. save us the loop?\n            for (let i = 0; i < this.boundTextures.length; i++)\n            {\n                if (this.boundTextures[i] === texture)\n                {\n                    return i;\n                }\n            }\n\n            if (location === undefined)\n            {\n                this._nextTextureLocation++;\n                this._nextTextureLocation %= this.boundTextures.length;\n                location = this.boundTextures.length - this._nextTextureLocation - 1;\n            }\n        }\n        else\n        {\n            location = location || 0;\n        }\n\n        const gl = this.gl;\n        const glTexture = texture._glTextures[this.CONTEXT_UID];\n\n        if (!glTexture)\n        {\n            // this will also bind the texture..\n            this.textureManager.updateTexture(texture, location);\n        }\n        else\n        {\n            // bind the current texture\n            this.boundTextures[location] = texture;\n            gl.activeTexture(gl.TEXTURE0 + location);\n            gl.bindTexture(gl.TEXTURE_2D, glTexture.texture);\n        }\n\n        return location;\n    }\n\n     /**\n     * unbinds the texture ...\n     *\n     * @param {PIXI.Texture} texture - the texture to unbind\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    unbindTexture(texture)\n    {\n        const gl = this.gl;\n\n        texture = texture.baseTexture || texture;\n\n        if (this._unknownBoundTextures)\n        {\n            this._unknownBoundTextures = false;\n            // someone changed webGL state,\n            // we have to be sure that our texture does not appear in multitexture renderer samplers\n\n            for (let i = 0; i < this.boundTextures.length; i++)\n            {\n                if (this.boundTextures[i] === this.emptyTextures[i])\n                {\n                    gl.activeTexture(gl.TEXTURE0 + i);\n                    gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);\n                }\n            }\n        }\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            if (this.boundTextures[i] === texture)\n            {\n                this.boundTextures[i] = this.emptyTextures[i];\n\n                gl.activeTexture(gl.TEXTURE0 + i);\n                gl.bindTexture(gl.TEXTURE_2D, this.emptyTextures[i]._glTextures[this.CONTEXT_UID].texture);\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Creates a new VAO from this renderer's context and state.\n     *\n     * @return {VertexArrayObject} The new VAO.\n     */\n    createVao()\n    {\n        return new glCore.VertexArrayObject(this.gl, this.state.attribState);\n    }\n\n    /**\n     * Changes the current Vao to the one given in parameter\n     *\n     * @param {PIXI.VertexArrayObject} vao - the new Vao\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    bindVao(vao)\n    {\n        if (this._activeVao === vao)\n        {\n            return this;\n        }\n\n        if (vao)\n        {\n            vao.bind();\n        }\n        else if (this._activeVao)\n        {\n            // TODO this should always be true i think?\n            this._activeVao.unbind();\n        }\n\n        this._activeVao = vao;\n\n        return this;\n    }\n\n    /**\n     * Resets the WebGL state so you can render things however you fancy!\n     *\n     * @return {PIXI.WebGLRenderer} Returns itself.\n     */\n    reset()\n    {\n        this.setObjectRenderer(this.emptyRenderer);\n\n        this.bindVao(null);\n        this._activeShader = null;\n        this._activeRenderTarget = this.rootRenderTarget;\n\n        this._unknownBoundTextures = true;\n\n        for (let i = 0; i < this.boundTextures.length; i++)\n        {\n            this.boundTextures[i] = this.emptyTextures[i];\n        }\n\n        // bind the main frame buffer (the screen);\n        this.rootRenderTarget.activate();\n\n        this.state.resetToDefault();\n\n        return this;\n    }\n\n    /**\n     * Handles a lost webgl context\n     *\n     * @private\n     * @param {WebGLContextEvent} event - The context lost event.\n     */\n    handleContextLost(event)\n    {\n        event.preventDefault();\n    }\n\n    /**\n     * Handles a restored webgl context\n     *\n     * @private\n     */\n    handleContextRestored()\n    {\n        this.textureManager.removeAll();\n        this.filterManager.destroy(true);\n        this._initContext();\n    }\n\n    /**\n     * Removes everything from the renderer (event listeners, spritebatch, etc...)\n     *\n     * @param {boolean} [removeView=false] - Removes the Canvas element from the DOM.\n     *  See: https://github.com/pixijs/pixi.js/issues/2233\n     */\n    destroy(removeView)\n    {\n        this.destroyPlugins();\n\n        // remove listeners\n        this.view.removeEventListener('webglcontextlost', this.handleContextLost);\n        this.view.removeEventListener('webglcontextrestored', this.handleContextRestored);\n\n        this.textureManager.destroy();\n\n        // call base destroy\n        super.destroy(removeView);\n\n        this.uid = 0;\n\n        // destroy the managers\n        this.maskManager.destroy();\n        this.stencilManager.destroy();\n        this.filterManager.destroy();\n\n        this.maskManager = null;\n        this.filterManager = null;\n        this.textureManager = null;\n        this.currentRenderer = null;\n\n        this.handleContextLost = null;\n        this.handleContextRestored = null;\n\n        this._contextOptions = null;\n        this.gl.useProgram(null);\n\n        if (this.gl.getExtension('WEBGL_lose_context'))\n        {\n            this.gl.getExtension('WEBGL_lose_context').loseContext();\n        }\n\n        this.gl = null;\n\n        // this = null;\n    }\n}\n\n/**\n * Collection of installed plugins. These are included by default in PIXI, but can be excluded\n * by creating a custom build. Consult the README for more information about creating custom\n * builds and excluding plugins.\n * @name PIXI.WebGLRenderer#plugins\n * @type {object}\n * @readonly\n * @property {PIXI.accessibility.AccessibilityManager} accessibility Support tabbing interactive elements.\n * @property {PIXI.extract.WebGLExtract} extract Extract image data from renderer.\n * @property {PIXI.interaction.InteractionManager} interaction Handles mouse, touch and pointer events.\n * @property {PIXI.prepare.WebGLPrepare} prepare Pre-render display objects.\n */\n\n/**\n * Adds a plugin to the renderer.\n *\n * @method PIXI.WebGLRenderer#registerPlugin\n * @param {string} pluginName - The name of the plugin.\n * @param {Function} ctor - The constructor function or class for the plugin.\n */\n\npluginTarget.mixin(WebGLRenderer);\n"]},"metadata":{},"sourceType":"script"}