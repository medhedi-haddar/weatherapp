{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _core = require('../../core');\n\nvar core = _interopRequireWildcard(_core);\n\nvar _ParticleShader = require('./ParticleShader');\n\nvar _ParticleShader2 = _interopRequireDefault(_ParticleShader);\n\nvar _ParticleBuffer = require('./ParticleBuffer');\n\nvar _ParticleBuffer2 = _interopRequireDefault(_ParticleBuffer);\n\nvar _utils = require('../../core/utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI\n */\n\n\nvar ParticleRenderer = function (_core$ObjectRenderer) {\n  _inherits(ParticleRenderer, _core$ObjectRenderer);\n  /**\n   * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n   */\n\n\n  function ParticleRenderer(renderer) {\n    _classCallCheck(this, ParticleRenderer); // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n    // so max number of particles is 65536 / 4 = 16384\n    // and max number of element in the index buffer is 16384 * 6 = 98304\n    // Creating a full index buffer, overhead is 98304 * 2 = 196Ko\n    // let numIndices = 98304;\n\n    /**\n     * The default shader that is used if a sprite doesn't have a more specific one.\n     *\n     * @member {PIXI.Shader}\n     */\n\n\n    var _this = _possibleConstructorReturn(this, _core$ObjectRenderer.call(this, renderer));\n\n    _this.shader = null;\n    _this.indexBuffer = null;\n    _this.properties = null;\n    _this.tempMatrix = new core.Matrix();\n    _this.CONTEXT_UID = 0;\n    return _this;\n  }\n  /**\n   * When there is a WebGL context change\n   *\n   * @private\n   */\n\n\n  ParticleRenderer.prototype.onContextChange = function onContextChange() {\n    var gl = this.renderer.gl;\n    this.CONTEXT_UID = this.renderer.CONTEXT_UID; // setup default shader\n\n    this.shader = new _ParticleShader2.default(gl);\n    this.properties = [// verticesData\n    {\n      attribute: this.shader.attributes.aVertexPosition,\n      size: 2,\n      uploadFunction: this.uploadVertices,\n      offset: 0\n    }, // positionData\n    {\n      attribute: this.shader.attributes.aPositionCoord,\n      size: 2,\n      uploadFunction: this.uploadPosition,\n      offset: 0\n    }, // rotationData\n    {\n      attribute: this.shader.attributes.aRotation,\n      size: 1,\n      uploadFunction: this.uploadRotation,\n      offset: 0\n    }, // uvsData\n    {\n      attribute: this.shader.attributes.aTextureCoord,\n      size: 2,\n      uploadFunction: this.uploadUvs,\n      offset: 0\n    }, // tintData\n    {\n      attribute: this.shader.attributes.aColor,\n      size: 1,\n      unsignedByte: true,\n      uploadFunction: this.uploadTint,\n      offset: 0\n    }];\n  };\n  /**\n   * Starts a new particle batch.\n   *\n   */\n\n\n  ParticleRenderer.prototype.start = function start() {\n    this.renderer.bindShader(this.shader);\n  };\n  /**\n   * Renders the particle container object.\n   *\n   * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n   */\n\n\n  ParticleRenderer.prototype.render = function render(container) {\n    var children = container.children;\n    var maxSize = container._maxSize;\n    var batchSize = container._batchSize;\n    var renderer = this.renderer;\n    var totalChildren = children.length;\n\n    if (totalChildren === 0) {\n      return;\n    } else if (totalChildren > maxSize) {\n      totalChildren = maxSize;\n    }\n\n    var buffers = container._glBuffers[renderer.CONTEXT_UID];\n\n    if (!buffers) {\n      buffers = container._glBuffers[renderer.CONTEXT_UID] = this.generateBuffers(container);\n    }\n\n    var baseTexture = children[0]._texture.baseTexture; // if the uvs have not updated then no point rendering just yet!\n\n    this.renderer.setBlendMode(core.utils.correctBlendMode(container.blendMode, baseTexture.premultipliedAlpha));\n    var gl = renderer.gl;\n    var m = container.worldTransform.copy(this.tempMatrix);\n    m.prepend(renderer._activeRenderTarget.projectionMatrix);\n    this.shader.uniforms.projectionMatrix = m.toArray(true);\n    this.shader.uniforms.uColor = core.utils.premultiplyRgba(container.tintRgb, container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultipliedAlpha); // make sure the texture is bound..\n\n    this.shader.uniforms.uSampler = renderer.bindTexture(baseTexture);\n    var updateStatic = false; // now lets upload and render the buffers..\n\n    for (var i = 0, j = 0; i < totalChildren; i += batchSize, j += 1) {\n      var amount = totalChildren - i;\n\n      if (amount > batchSize) {\n        amount = batchSize;\n      }\n\n      if (j >= buffers.length) {\n        if (!container.autoResize) {\n          break;\n        }\n\n        buffers.push(this._generateOneMoreBuffer(container));\n      }\n\n      var buffer = buffers[j]; // we always upload the dynamic\n\n      buffer.uploadDynamic(children, i, amount);\n      var bid = container._bufferUpdateIDs[j] || 0;\n      updateStatic = updateStatic || buffer._updateID < bid; // we only upload the static content when we have to!\n\n      if (updateStatic) {\n        buffer._updateID = container._updateID;\n        buffer.uploadStatic(children, i, amount);\n      } // bind the buffer\n\n\n      renderer.bindVao(buffer.vao);\n      buffer.vao.draw(gl.TRIANGLES, amount * 6);\n    }\n  };\n  /**\n   * Creates one particle buffer for each child in the container we want to render and updates internal properties\n   *\n   * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n   * @return {PIXI.ParticleBuffer[]} The buffers\n   */\n\n\n  ParticleRenderer.prototype.generateBuffers = function generateBuffers(container) {\n    var gl = this.renderer.gl;\n    var buffers = [];\n    var size = container._maxSize;\n    var batchSize = container._batchSize;\n    var dynamicPropertyFlags = container._properties;\n\n    for (var i = 0; i < size; i += batchSize) {\n      buffers.push(new _ParticleBuffer2.default(gl, this.properties, dynamicPropertyFlags, batchSize));\n    }\n\n    return buffers;\n  };\n  /**\n   * Creates one more particle buffer, because container has autoResize feature\n   *\n   * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n   * @return {PIXI.ParticleBuffer} generated buffer\n   * @private\n   */\n\n\n  ParticleRenderer.prototype._generateOneMoreBuffer = function _generateOneMoreBuffer(container) {\n    var gl = this.renderer.gl;\n    var batchSize = container._batchSize;\n    var dynamicPropertyFlags = container._properties;\n    return new _ParticleBuffer2.default(gl, this.properties, dynamicPropertyFlags, batchSize);\n  };\n  /**\n   * Uploads the verticies.\n   *\n   * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n   * @param {number} startIndex - the index to start from in the children array\n   * @param {number} amount - the amount of children that will have their vertices uploaded\n   * @param {number[]} array - The vertices to upload.\n   * @param {number} stride - Stride to use for iteration.\n   * @param {number} offset - Offset to start at.\n   */\n\n\n  ParticleRenderer.prototype.uploadVertices = function uploadVertices(children, startIndex, amount, array, stride, offset) {\n    var w0 = 0;\n    var w1 = 0;\n    var h0 = 0;\n    var h1 = 0;\n\n    for (var i = 0; i < amount; ++i) {\n      var sprite = children[startIndex + i];\n      var texture = sprite._texture;\n      var sx = sprite.scale.x;\n      var sy = sprite.scale.y;\n      var trim = texture.trim;\n      var orig = texture.orig;\n\n      if (trim) {\n        // if the sprite is trimmed and is not a tilingsprite then we need to add the\n        // extra space before transforming the sprite coords..\n        w1 = trim.x - sprite.anchor.x * orig.width;\n        w0 = w1 + trim.width;\n        h1 = trim.y - sprite.anchor.y * orig.height;\n        h0 = h1 + trim.height;\n      } else {\n        w0 = orig.width * (1 - sprite.anchor.x);\n        w1 = orig.width * -sprite.anchor.x;\n        h0 = orig.height * (1 - sprite.anchor.y);\n        h1 = orig.height * -sprite.anchor.y;\n      }\n\n      array[offset] = w1 * sx;\n      array[offset + 1] = h1 * sy;\n      array[offset + stride] = w0 * sx;\n      array[offset + stride + 1] = h1 * sy;\n      array[offset + stride * 2] = w0 * sx;\n      array[offset + stride * 2 + 1] = h0 * sy;\n      array[offset + stride * 3] = w1 * sx;\n      array[offset + stride * 3 + 1] = h0 * sy;\n      offset += stride * 4;\n    }\n  };\n  /**\n   *\n   * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n   * @param {number} startIndex - the index to start from in the children array\n   * @param {number} amount - the amount of children that will have their positions uploaded\n   * @param {number[]} array - The vertices to upload.\n   * @param {number} stride - Stride to use for iteration.\n   * @param {number} offset - Offset to start at.\n   */\n\n\n  ParticleRenderer.prototype.uploadPosition = function uploadPosition(children, startIndex, amount, array, stride, offset) {\n    for (var i = 0; i < amount; i++) {\n      var spritePosition = children[startIndex + i].position;\n      array[offset] = spritePosition.x;\n      array[offset + 1] = spritePosition.y;\n      array[offset + stride] = spritePosition.x;\n      array[offset + stride + 1] = spritePosition.y;\n      array[offset + stride * 2] = spritePosition.x;\n      array[offset + stride * 2 + 1] = spritePosition.y;\n      array[offset + stride * 3] = spritePosition.x;\n      array[offset + stride * 3 + 1] = spritePosition.y;\n      offset += stride * 4;\n    }\n  };\n  /**\n   *\n   * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n   * @param {number} startIndex - the index to start from in the children array\n   * @param {number} amount - the amount of children that will have their rotation uploaded\n   * @param {number[]} array - The vertices to upload.\n   * @param {number} stride - Stride to use for iteration.\n   * @param {number} offset - Offset to start at.\n   */\n\n\n  ParticleRenderer.prototype.uploadRotation = function uploadRotation(children, startIndex, amount, array, stride, offset) {\n    for (var i = 0; i < amount; i++) {\n      var spriteRotation = children[startIndex + i].rotation;\n      array[offset] = spriteRotation;\n      array[offset + stride] = spriteRotation;\n      array[offset + stride * 2] = spriteRotation;\n      array[offset + stride * 3] = spriteRotation;\n      offset += stride * 4;\n    }\n  };\n  /**\n   *\n   * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n   * @param {number} startIndex - the index to start from in the children array\n   * @param {number} amount - the amount of children that will have their rotation uploaded\n   * @param {number[]} array - The vertices to upload.\n   * @param {number} stride - Stride to use for iteration.\n   * @param {number} offset - Offset to start at.\n   */\n\n\n  ParticleRenderer.prototype.uploadUvs = function uploadUvs(children, startIndex, amount, array, stride, offset) {\n    for (var i = 0; i < amount; ++i) {\n      var textureUvs = children[startIndex + i]._texture._uvs;\n\n      if (textureUvs) {\n        array[offset] = textureUvs.x0;\n        array[offset + 1] = textureUvs.y0;\n        array[offset + stride] = textureUvs.x1;\n        array[offset + stride + 1] = textureUvs.y1;\n        array[offset + stride * 2] = textureUvs.x2;\n        array[offset + stride * 2 + 1] = textureUvs.y2;\n        array[offset + stride * 3] = textureUvs.x3;\n        array[offset + stride * 3 + 1] = textureUvs.y3;\n        offset += stride * 4;\n      } else {\n        // TODO you know this can be easier!\n        array[offset] = 0;\n        array[offset + 1] = 0;\n        array[offset + stride] = 0;\n        array[offset + stride + 1] = 0;\n        array[offset + stride * 2] = 0;\n        array[offset + stride * 2 + 1] = 0;\n        array[offset + stride * 3] = 0;\n        array[offset + stride * 3 + 1] = 0;\n        offset += stride * 4;\n      }\n    }\n  };\n  /**\n   *\n   * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n   * @param {number} startIndex - the index to start from in the children array\n   * @param {number} amount - the amount of children that will have their rotation uploaded\n   * @param {number[]} array - The vertices to upload.\n   * @param {number} stride - Stride to use for iteration.\n   * @param {number} offset - Offset to start at.\n   */\n\n\n  ParticleRenderer.prototype.uploadTint = function uploadTint(children, startIndex, amount, array, stride, offset) {\n    for (var i = 0; i < amount; ++i) {\n      var sprite = children[startIndex + i];\n      var premultiplied = sprite._texture.baseTexture.premultipliedAlpha;\n      var alpha = sprite.alpha; // we dont call extra function if alpha is 1.0, that's faster\n\n      var argb = alpha < 1.0 && premultiplied ? (0, _utils.premultiplyTint)(sprite._tintRGB, alpha) : sprite._tintRGB + (alpha * 255 << 24);\n      array[offset] = argb;\n      array[offset + stride] = argb;\n      array[offset + stride * 2] = argb;\n      array[offset + stride * 3] = argb;\n      offset += stride * 4;\n    }\n  };\n  /**\n   * Destroys the ParticleRenderer.\n   *\n   */\n\n\n  ParticleRenderer.prototype.destroy = function destroy() {\n    if (this.renderer.gl) {\n      this.renderer.gl.deleteBuffer(this.indexBuffer);\n    }\n\n    _core$ObjectRenderer.prototype.destroy.call(this);\n\n    this.shader.destroy();\n    this.indices = null;\n    this.tempMatrix = null;\n  };\n\n  return ParticleRenderer;\n}(core.ObjectRenderer);\n\nexports.default = ParticleRenderer;\ncore.WebGLRenderer.registerPlugin('particle', ParticleRenderer);","map":{"version":3,"sources":["../../../src/particles/webgl/ParticleRenderer.js"],"names":["core","ParticleRenderer","ObjectRenderer","onContextChange","gl","attribute","size","uploadFunction","offset","unsignedByte","start","render","container","children","maxSize","batchSize","renderer","totalChildren","buffers","baseTexture","m","updateStatic","i","j","amount","buffer","bid","generateBuffers","dynamicPropertyFlags","_generateOneMoreBuffer","uploadVertices","startIndex","array","stride","w0","w1","h0","h1","sprite","texture","sx","sy","trim","orig","uploadPosition","spritePosition","uploadRotation","spriteRotation","uploadUvs","textureUvs","uploadTint","premultiplied","alpha","argb","destroy"],"mappings":"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","sourcesContent":["import * as core from '../../core';\nimport ParticleShader from './ParticleShader';\nimport ParticleBuffer from './ParticleBuffer';\nimport { premultiplyTint } from '../../core/utils';\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original PixiJS version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now\n * share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI\n */\nexport default class ParticleRenderer extends core.ObjectRenderer\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this sprite batch works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        // 65535 is max vertex index in the index buffer (see ParticleRenderer)\n        // so max number of particles is 65536 / 4 = 16384\n        // and max number of element in the index buffer is 16384 * 6 = 98304\n        // Creating a full index buffer, overhead is 98304 * 2 = 196Ko\n        // let numIndices = 98304;\n\n        /**\n         * The default shader that is used if a sprite doesn't have a more specific one.\n         *\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        this.indexBuffer = null;\n\n        this.properties = null;\n\n        this.tempMatrix = new core.Matrix();\n\n        this.CONTEXT_UID = 0;\n    }\n\n    /**\n     * When there is a WebGL context change\n     *\n     * @private\n     */\n    onContextChange()\n    {\n        const gl = this.renderer.gl;\n\n        this.CONTEXT_UID = this.renderer.CONTEXT_UID;\n\n        // setup default shader\n        this.shader = new ParticleShader(gl);\n\n        this.properties = [\n            // verticesData\n            {\n                attribute: this.shader.attributes.aVertexPosition,\n                size: 2,\n                uploadFunction: this.uploadVertices,\n                offset: 0,\n            },\n            // positionData\n            {\n                attribute: this.shader.attributes.aPositionCoord,\n                size: 2,\n                uploadFunction: this.uploadPosition,\n                offset: 0,\n            },\n            // rotationData\n            {\n                attribute: this.shader.attributes.aRotation,\n                size: 1,\n                uploadFunction: this.uploadRotation,\n                offset: 0,\n            },\n            // uvsData\n            {\n                attribute: this.shader.attributes.aTextureCoord,\n                size: 2,\n                uploadFunction: this.uploadUvs,\n                offset: 0,\n            },\n            // tintData\n            {\n                attribute: this.shader.attributes.aColor,\n                size: 1,\n                unsignedByte: true,\n                uploadFunction: this.uploadTint,\n                offset: 0,\n            },\n        ];\n    }\n\n    /**\n     * Starts a new particle batch.\n     *\n     */\n    start()\n    {\n        this.renderer.bindShader(this.shader);\n    }\n\n    /**\n     * Renders the particle container object.\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     */\n    render(container)\n    {\n        const children = container.children;\n        const maxSize = container._maxSize;\n        const batchSize = container._batchSize;\n        const renderer = this.renderer;\n        let totalChildren = children.length;\n\n        if (totalChildren === 0)\n        {\n            return;\n        }\n        else if (totalChildren > maxSize)\n        {\n            totalChildren = maxSize;\n        }\n\n        let buffers = container._glBuffers[renderer.CONTEXT_UID];\n\n        if (!buffers)\n        {\n            buffers = container._glBuffers[renderer.CONTEXT_UID] = this.generateBuffers(container);\n        }\n\n        const baseTexture = children[0]._texture.baseTexture;\n\n        // if the uvs have not updated then no point rendering just yet!\n        this.renderer.setBlendMode(core.utils.correctBlendMode(container.blendMode, baseTexture.premultipliedAlpha));\n\n        const gl = renderer.gl;\n\n        const m = container.worldTransform.copy(this.tempMatrix);\n\n        m.prepend(renderer._activeRenderTarget.projectionMatrix);\n\n        this.shader.uniforms.projectionMatrix = m.toArray(true);\n\n        this.shader.uniforms.uColor = core.utils.premultiplyRgba(container.tintRgb,\n            container.worldAlpha, this.shader.uniforms.uColor, baseTexture.premultipliedAlpha);\n\n        // make sure the texture is bound..\n        this.shader.uniforms.uSampler = renderer.bindTexture(baseTexture);\n\n        let updateStatic = false;\n\n        // now lets upload and render the buffers..\n        for (let i = 0, j = 0; i < totalChildren; i += batchSize, j += 1)\n        {\n            let amount = (totalChildren - i);\n\n            if (amount > batchSize)\n            {\n                amount = batchSize;\n            }\n\n            if (j >= buffers.length)\n            {\n                if (!container.autoResize)\n                {\n                    break;\n                }\n                buffers.push(this._generateOneMoreBuffer(container));\n            }\n\n            const buffer = buffers[j];\n\n            // we always upload the dynamic\n            buffer.uploadDynamic(children, i, amount);\n\n            const bid = container._bufferUpdateIDs[j] || 0;\n\n            updateStatic = updateStatic || (buffer._updateID < bid);\n            // we only upload the static content when we have to!\n            if (updateStatic)\n            {\n                buffer._updateID = container._updateID;\n                buffer.uploadStatic(children, i, amount);\n            }\n\n            // bind the buffer\n            renderer.bindVao(buffer.vao);\n            buffer.vao.draw(gl.TRIANGLES, amount * 6);\n        }\n    }\n\n    /**\n     * Creates one particle buffer for each child in the container we want to render and updates internal properties\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     * @return {PIXI.ParticleBuffer[]} The buffers\n     */\n    generateBuffers(container)\n    {\n        const gl = this.renderer.gl;\n        const buffers = [];\n        const size = container._maxSize;\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        for (let i = 0; i < size; i += batchSize)\n        {\n            buffers.push(new ParticleBuffer(gl, this.properties, dynamicPropertyFlags, batchSize));\n        }\n\n        return buffers;\n    }\n\n    /**\n     * Creates one more particle buffer, because container has autoResize feature\n     *\n     * @param {PIXI.ParticleContainer} container - The container to render using this ParticleRenderer\n     * @return {PIXI.ParticleBuffer} generated buffer\n     * @private\n     */\n    _generateOneMoreBuffer(container)\n    {\n        const gl = this.renderer.gl;\n        const batchSize = container._batchSize;\n        const dynamicPropertyFlags = container._properties;\n\n        return new ParticleBuffer(gl, this.properties, dynamicPropertyFlags, batchSize);\n    }\n\n    /**\n     * Uploads the verticies.\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their vertices uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadVertices(children, startIndex, amount, array, stride, offset)\n    {\n        let w0 = 0;\n        let w1 = 0;\n        let h0 = 0;\n        let h1 = 0;\n\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const texture = sprite._texture;\n            const sx = sprite.scale.x;\n            const sy = sprite.scale.y;\n            const trim = texture.trim;\n            const orig = texture.orig;\n\n            if (trim)\n            {\n                // if the sprite is trimmed and is not a tilingsprite then we need to add the\n                // extra space before transforming the sprite coords..\n                w1 = trim.x - (sprite.anchor.x * orig.width);\n                w0 = w1 + trim.width;\n\n                h1 = trim.y - (sprite.anchor.y * orig.height);\n                h0 = h1 + trim.height;\n            }\n            else\n            {\n                w0 = (orig.width) * (1 - sprite.anchor.x);\n                w1 = (orig.width) * -sprite.anchor.x;\n\n                h0 = orig.height * (1 - sprite.anchor.y);\n                h1 = orig.height * -sprite.anchor.y;\n            }\n\n            array[offset] = w1 * sx;\n            array[offset + 1] = h1 * sy;\n\n            array[offset + stride] = w0 * sx;\n            array[offset + stride + 1] = h1 * sy;\n\n            array[offset + (stride * 2)] = w0 * sx;\n            array[offset + (stride * 2) + 1] = h0 * sy;\n\n            array[offset + (stride * 3)] = w1 * sx;\n            array[offset + (stride * 3) + 1] = h0 * sy;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their positions uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadPosition(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spritePosition = children[startIndex + i].position;\n\n            array[offset] = spritePosition.x;\n            array[offset + 1] = spritePosition.y;\n\n            array[offset + stride] = spritePosition.x;\n            array[offset + stride + 1] = spritePosition.y;\n\n            array[offset + (stride * 2)] = spritePosition.x;\n            array[offset + (stride * 2) + 1] = spritePosition.y;\n\n            array[offset + (stride * 3)] = spritePosition.x;\n            array[offset + (stride * 3) + 1] = spritePosition.y;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadRotation(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; i++)\n        {\n            const spriteRotation = children[startIndex + i].rotation;\n\n            array[offset] = spriteRotation;\n            array[offset + stride] = spriteRotation;\n            array[offset + (stride * 2)] = spriteRotation;\n            array[offset + (stride * 3)] = spriteRotation;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadUvs(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const textureUvs = children[startIndex + i]._texture._uvs;\n\n            if (textureUvs)\n            {\n                array[offset] = textureUvs.x0;\n                array[offset + 1] = textureUvs.y0;\n\n                array[offset + stride] = textureUvs.x1;\n                array[offset + stride + 1] = textureUvs.y1;\n\n                array[offset + (stride * 2)] = textureUvs.x2;\n                array[offset + (stride * 2) + 1] = textureUvs.y2;\n\n                array[offset + (stride * 3)] = textureUvs.x3;\n                array[offset + (stride * 3) + 1] = textureUvs.y3;\n\n                offset += stride * 4;\n            }\n            else\n            {\n                // TODO you know this can be easier!\n                array[offset] = 0;\n                array[offset + 1] = 0;\n\n                array[offset + stride] = 0;\n                array[offset + stride + 1] = 0;\n\n                array[offset + (stride * 2)] = 0;\n                array[offset + (stride * 2) + 1] = 0;\n\n                array[offset + (stride * 3)] = 0;\n                array[offset + (stride * 3) + 1] = 0;\n\n                offset += stride * 4;\n            }\n        }\n    }\n\n    /**\n     *\n     * @param {PIXI.DisplayObject[]} children - the array of display objects to render\n     * @param {number} startIndex - the index to start from in the children array\n     * @param {number} amount - the amount of children that will have their rotation uploaded\n     * @param {number[]} array - The vertices to upload.\n     * @param {number} stride - Stride to use for iteration.\n     * @param {number} offset - Offset to start at.\n     */\n    uploadTint(children, startIndex, amount, array, stride, offset)\n    {\n        for (let i = 0; i < amount; ++i)\n        {\n            const sprite = children[startIndex + i];\n            const premultiplied = sprite._texture.baseTexture.premultipliedAlpha;\n            const alpha = sprite.alpha;\n            // we dont call extra function if alpha is 1.0, that's faster\n            const argb = alpha < 1.0 && premultiplied ? premultiplyTint(sprite._tintRGB, alpha)\n                : sprite._tintRGB + (alpha * 255 << 24);\n\n            array[offset] = argb;\n            array[offset + stride] = argb;\n            array[offset + (stride * 2)] = argb;\n            array[offset + (stride * 3)] = argb;\n\n            offset += stride * 4;\n        }\n    }\n\n    /**\n     * Destroys the ParticleRenderer.\n     *\n     */\n    destroy()\n    {\n        if (this.renderer.gl)\n        {\n            this.renderer.gl.deleteBuffer(this.indexBuffer);\n        }\n\n        super.destroy();\n\n        this.shader.destroy();\n\n        this.indices = null;\n        this.tempMatrix = null;\n    }\n\n}\n\ncore.WebGLRenderer.registerPlugin('particle', ParticleRenderer);\n"]},"metadata":{},"sourceType":"script"}