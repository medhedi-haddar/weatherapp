{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.default = buildPoly;\n\nvar _buildLine = require('./buildLine');\n\nvar _buildLine2 = _interopRequireDefault(_buildLine);\n\nvar _utils = require('../../../utils');\n\nvar _earcut = require('earcut');\n\nvar _earcut2 = _interopRequireDefault(_earcut);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the webGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines\n */\n\n\nfunction buildPoly(graphicsData, webGLData, webGLDataNativeLines) {\n  graphicsData.points = graphicsData.shape.points.slice();\n  var points = graphicsData.points;\n\n  if (graphicsData.fill && points.length >= 6) {\n    var holeArray = []; // Process holes..\n\n    var holes = graphicsData.holes;\n\n    for (var i = 0; i < holes.length; i++) {\n      var hole = holes[i];\n      holeArray.push(points.length / 2);\n      points = points.concat(hole.points);\n    } // get first and last point.. figure out the middle!\n\n\n    var verts = webGLData.points;\n    var indices = webGLData.indices;\n    var length = points.length / 2; // sort color\n\n    var color = (0, _utils.hex2rgb)(graphicsData.fillColor);\n    var alpha = graphicsData.fillAlpha;\n    var r = color[0] * alpha;\n    var g = color[1] * alpha;\n    var b = color[2] * alpha;\n    var triangles = (0, _earcut2.default)(points, holeArray, 2);\n\n    if (!triangles) {\n      return;\n    }\n\n    var vertPos = verts.length / 6;\n\n    for (var _i = 0; _i < triangles.length; _i += 3) {\n      indices.push(triangles[_i] + vertPos);\n      indices.push(triangles[_i] + vertPos);\n      indices.push(triangles[_i + 1] + vertPos);\n      indices.push(triangles[_i + 2] + vertPos);\n      indices.push(triangles[_i + 2] + vertPos);\n    }\n\n    for (var _i2 = 0; _i2 < length; _i2++) {\n      verts.push(points[_i2 * 2], points[_i2 * 2 + 1], r, g, b, alpha);\n    }\n  }\n\n  if (graphicsData.lineWidth > 0) {\n    (0, _buildLine2.default)(graphicsData, webGLData, webGLDataNativeLines);\n  }\n}","map":{"version":3,"sources":["../../../../../src/core/graphics/webgl/utils/buildPoly.js"],"names":["buildPoly","graphicsData","points","holeArray","holes","i","hole","verts","webGLData","indices","length","color","alpha","r","g","b","triangles","vertPos"],"mappings":"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","sourcesContent":["import buildLine from './buildLine';\nimport { hex2rgb } from '../../../utils';\nimport earcut from 'earcut';\n\n/**\n * Builds a polygon to draw\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {PIXI.WebGLGraphicsData} graphicsData - The graphics object containing all the necessary properties\n * @param {object} webGLData - an object containing all the webGL-specific information to create this shape\n * @param {object} webGLDataNativeLines - an object containing all the webGL-specific information to create nativeLines\n */\nexport default function buildPoly(graphicsData, webGLData, webGLDataNativeLines)\n{\n    graphicsData.points = graphicsData.shape.points.slice();\n\n    let points = graphicsData.points;\n\n    if (graphicsData.fill && points.length >= 6)\n    {\n        const holeArray = [];\n        // Process holes..\n        const holes = graphicsData.holes;\n\n        for (let i = 0; i < holes.length; i++)\n        {\n            const hole = holes[i];\n\n            holeArray.push(points.length / 2);\n\n            points = points.concat(hole.points);\n        }\n\n        // get first and last point.. figure out the middle!\n        const verts = webGLData.points;\n        const indices = webGLData.indices;\n\n        const length = points.length / 2;\n\n        // sort color\n        const color = hex2rgb(graphicsData.fillColor);\n        const alpha = graphicsData.fillAlpha;\n        const r = color[0] * alpha;\n        const g = color[1] * alpha;\n        const b = color[2] * alpha;\n\n        const triangles = earcut(points, holeArray, 2);\n\n        if (!triangles)\n        {\n            return;\n        }\n\n        const vertPos = verts.length / 6;\n\n        for (let i = 0; i < triangles.length; i += 3)\n        {\n            indices.push(triangles[i] + vertPos);\n            indices.push(triangles[i] + vertPos);\n            indices.push(triangles[i + 1] + vertPos);\n            indices.push(triangles[i + 2] + vertPos);\n            indices.push(triangles[i + 2] + vertPos);\n        }\n\n        for (let i = 0; i < length; i++)\n        {\n            verts.push(points[i * 2], points[(i * 2) + 1],\n                r, g, b, alpha);\n        }\n    }\n\n    if (graphicsData.lineWidth > 0)\n    {\n        buildLine(graphicsData, webGLData, webGLDataNativeLines);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}